[라우팅]
라우팅(예: URL 라우팅)은 대규모 리액트 애플리케이션 구축에서 매우 중요하다
이를 통해 사용자들이 다양한 뷰와 컴포넌트를 탐색하게 할 수 있으며, 매끄럽고 직관적인 사용자 경험을 제공할 수 있다
애플리케이션 규모가 커짐에 따라 유지보수성, 확장성, 성능을 보장하기 위해 효과적인 라우팅의 중요성은 기하급수적으로 늘어난다

리액트 라우팅의 다양한 접근법 및 모범 사례에 관해 알아보고, 리액트 라우터 및 Next.js 앱 라우터 같은 솔루션에 관해서도 논의해본다
또한 중첩된 라우팅, 데이터 로딩 같은 주제도 다루어본다

    - 사용자에게 라우팅이 중요한 이유는 무엇인가?
        : 라우팅은 웹 애플리케이션 안에서 매끄럽고 직관적인 사용자 경험을 만드는 데 중요한 역할을 하기 때문에 사용자에게 매우 중요하다
        : 라우팅은 다음을 촉진한다
            - 내비게이션 및 발견 가능성
                : 라우팅은 애플리케이션에 명확하고 논리적인 구조를 제공하며 사용자는 이를 활용해 여러 섹션을 이동하고,
                  사용할 수 있는 콘텐츠와 기능을 찾아낼 수 있다
                : 잘 정의된 라우트는 애플리케이션에 관한 직관적인 지도 역할을 하며 전체적인 사용자 경험을 제공한다
            
            - 북마킹 및 공유
                : 라우팅을 사용하면 애플리케이션의 각 뷰 혹은 각 페이지는 하나의 고유한 URL을 갖는다
                : 사용자는 미래의 빠른 접근을 위해 특정한 라우트를 북마크로 등록하거나 URL을 복사해서 붙여 넣어
                  간단하게 다른 사용자와 콘텐츠나 기능을 쉽게 공유할 수 있다

            - 이전 페이지로 및 다음 페이지로 탐색
                : 적절한 라우팅을 사용하면 사용자들이 브라우저의 이전 페이지로, 다음 페이지로 버튼을 효과적으로 사용하게 할 수 있다
                : 이는 방문 기록을 탐색할 때 애플리케이션의 상태를 보존하고 웹 애플리케이션에 대한 사용자의 기대에 맞는 매끄럽고 직관적인 경험을 제공한다

            - 검색 엔진 최적화 및 인덱싱
                : 각 뷰 혹은 페이지의 고유한 URL은 검색 엔진에 대한 애플리케이션의 가시성을 개선한다
                : 검색 엔진은 콘텐츠를 크롤링하고 인덱싱할 수 있고, 결과적으로 해당 콘텐츠는 검색 엔진을 통해 발견할 수 있게 되어 
                  애플리케이션의 오가닉 트래픽을 잠재적으로 증가시킬 수 있다

            - 깊은 링킹 및 외부 접근
                : 라우팅을 사용하면 깊은 링킹을 촉진할 수 있다. 사용자들은 이를 활용해 특정한 뷰 혹은 페이지에 URL을 통해 직접 접근할 수 있다.
                : 이는 사용자들이 외부 링크를 사용하거나 다른 채널을 통해 URL을 공유 받았을 때 유용하다
                : 사용자들은 애플리케이션의 관련 부분에 곧바로 접근할 수 있기 때문이다

            - 상태 관리 및 데이터 보존
                : 적절한 라우팅을 사용하면 애플리케이션은 다른 뷰 사이에서 상태를 관리하고 유지할 수 있다
                : 사용자가 다른 영역을 탐색하더라도 관련 데이터와 사용자 정보를 유지할 수 있으며, 일관성 있고 방해받지 않는 경험을 제공한다

            - 권한 기반 접근 및 인증
                : 라우팅을 사용하면 권한 기반 접근 제어와 인증 매커니즘을 구현할 수 있다
                : 사용자 역할과 인증 상태에 기반해 서로 다른 라우트를 보호 또는 제한할 수 있으며, 이를 통해 사용자들이
                  애플리케이션의 적절한 영역에만 접근하도록 함으로써 보안과 사용자 신뢰를 향상시킨다

            >>> 효과적인 라우팅을 구현함으로써 개발자들은 애플리케이션을 보다 조직화되고 유지보수 가능하게 만들 수 있을 뿐만 아니라
                한층 개선된 사용자 경험을 제공할 수 있다. 라우팅은 일련의 컴포넌트와 뷰의 조합을 웹 표준과 사용자 기대에 부합하는
                응집되고, 탐색 가능하고, 사용자 친화적인 애플리케이션으로 바꾼다

    - 리액트의 라우팅 이해하기
        : 라우팅의 정의
            - 라우팅(URL 라우팅)은 URL을 애플리케이션 안의 특정 컴포넌트 혹은 페이지로 매핑하는 과정이다
            - 라우팅을 통해 사용자들은 브라우저의 주소창에 URL을 입력하거나 하이퍼링크를 클릭해 다른 뷰 사이를 탐색할 수 있다

            - 예를 들면 클릭했을 때, https://website.com 이라는 URL을 https://website.com/about/ 이라는 URL로 변경한다고 가정해보자
            - URL의 변경은 라우팅을 나타낸다. 우리가 웹사이트의 루트 경로에 방문하면 일반적으로 홈 페이지에 접근한다
            - 마찬가지로 /about에 방문하면 'about 페이지'에 접근하는 식이다

            - 라우팅을 사용하지 않고도 애플리케이션을 만들 수는 있다. 하지만 애플리케이션의 규모가 커지면 기하급수적으로 난해해진다
            - 라우트를 구현하면 특정한 URL을 관련된 컴포넌트 혹은 컴포넌트 집합과 연결할 수 있어, 구조화 및 조직화된 애플리케이션 아키텍처를 만들 수 있다

    - 전통적 웹 애플리케이션 vs 단일 페이지 애플리케이션
        : 전통적 애플리케이션에서는 일반적으로 각 URL이 서버에서 제공되는 별도의 HTML에 해당한다
        : 사용자가 다른 URL을 탐색하면 브라우저는 요청을 서버에 보내고, 서버는 새로운 HTML 페이지를를 응답한다
        : 이 접근법은 잠재적으로 전체 페이지 리로딩이 필요하기 때문에 더 느리고, 유연하지 않은 사용자 경험을 제공하게 된다

        : 이와 달리 리액트를 사용해 구축한 단일 페이지 애플리케이션(SPA)은 다른 접근법을 따른다
        : SPA에서는 전체 페이지를 단일 페이지로 로딩하고 콘텐츠를 현재 URL에 따라 동적으로 업데이트한다
        : 사용자가 다르 URL을 탐색하면 리액트는 전체 페이지 리로딩을 요청하지 않고 적절한 컴포넌트만 렌더링함으로써 UI를 업데이트한다
        : 이 접근법은 네이티브 데스크톱 혹은 모바일 애플리케이션처럼 느껴지는, 보다 매끄럽고 응답성 있는 사용자 경험을 제공한다

        > 각 접근법은 고유한 장점과 유스 케이스를 갖는다. 전통적 웹 애플리케이션은 SEO 및 첫 번째 페이지 로딩 시간이 중요한 시나리오에서 뛰어나다
          일반적으로 이들은 간단하게 개발할 수 있고 많은 콘텐츠를 담은 사이트에 보다 적합하다
        
        > 한편 SPA는 보다 대화형의, 애플리케이션 같은 경험을 만들 때 빛을 발한다. SPA는 보다 부드러운 네비게이션,
          첫 번째 로딩 이후의 보다 나은 성능, 높은 응답성을 보이는 느낌을 제공한다
          SPA는 사용자 참여와 상호작용성이 핵심인 복잡한 웹 애플리케이션에 이상적이다

        >>> 리액트 개발 컨텍스트에서는 SPA 접근법을 보다 일반적으로 사용한다. 하지만 모던 프레임워크와 기법들은
            이 두 패러다임의 경계를 모호하게 만들고 있기 때문에 개발자들은 두 접근법의 이점을 활용할 수 있다

    - 리액트의 라우팅에 관한 접근법
        : 리액트는 내장 라우팅 솔루션을 제공하지 않는다. 하지만 리액트 생태계에서 라우팅과 관련된 강력한 라이브러리와 프레임워크를 제공한다
        : 리액트에는 크게 '클라이언트 사이드 라우팅', '서버 사이드 라우팅'이라는 두 가지 접근법이 있다
            - 클라이언트 사이드 라우팅
                : 클라이언트 사이드 라우팅은 리액트 애플리케이션에서 가장 일반적인 사용 방식이다
                : 라우팅 로직은 전적으로 브라우저가 자바스크립트를 사용해 처리한다
                : 사용자가 다른 URL을 탐색하거나 링크를 클릭하면, 애플리케이션은 탐색 이벤트를 가로채 서버에 요청하지 않고 UI를 업데이트한다
                : 이 접근법은 SPA에게 대단히 중요하다. 페이지 사이를 빠르게 전환할 수 있게 해 서버 사이드 라우팅과 관련된
                  전통적 페이지 리로딩을 하지 않음으로써 매끄럽고 연속적인 경험을 제공하기 때문이다

                : 장점
                    - 빠르고 매끄러운 네비게이션  
                        : 추가적인 서버 요청이 필요하지 않으므로 부드러운 네비게이션이 가능하다
                    - 프론트엔드와 백엔드 분리
                        : 명확한 분리를 통해 독립된 개발과 유지보수가 가능하다

                : 제한
                    - 보다 느린 초기 로딩 시간
                        : 전체 애플리케이션을 사전에 로딩해야 한다
                    - SEO 어려움
                        : 검색 엔진 크롤러는 동적으로 렌더링된 컴포넌트에 대해 색인을 만들기 어려울 수 있다

            - 서버 사이드 라우팅
                : 서버 사이드 라우팅은 라우팅 로직을 서버에서 다룬다. 사용자가 URL을 입력하거나 링크를 클릭하면,
                  서버는 해당 요청을 처리한 뒤 적절한 HTML 컴포넌트를 반환한다
                : 이 접근법은 각 페이지 요청이 서버에서 완전하게 처리되기 때문에, 기본적으로 전통적 웹 애플리케이션에서 채택하는 방식이다

                : 장점 
                    - 보다 나은 SEO
                        : 검색 엔진 크롤러는 완전히 렌더링된 HTML 페이지들에 대해 쉽게 색인을 만들 수 있다
                    - 보다 빠른 초기 로딩 시간
                        : 서버는 HTML 콘텐츠를 빠르게 렌더링하고 전송할 수 있다

                : 제한
                    - 보다 느린 네비게이션
                        : 각 네비게이션 요청마다 서버와 통신을 주고받아야 한다
                    - 프론트엔드와 백엔드가 밀접하게 결합
                        : 프론트엔드와 백엔드가 보다 밀접하게 통합되어야 하며, 이는 개발과 유지보수를 복잡하게 만든다

            
        >>> 두 접근법 모두 모던 웹 개발에서 각자의 영역이 있으며, 이는 애플리케이션의 구체적인 요구사항에 따라 선택해야 한다
        >>> Next.js 같은 일부 프레임워크들은 클라이언트 사이드 라우팅, 서버 사이드 라우팅의 장점을 조합한 하이브리드 솔루션을 제공하기도 한다

    
    - 리액트의 라우팅 솔루션
        : 리액트 에코시스템에서 사용할 수 있는 몇 가지 유명한 라우팅 솔루션에 대해 살펴보자
        : 예제에서는 리액트 라우터와 Next.js의 앱 라우터에 관해 살펴본다

            - 리액트 라우터
                : 리액트 라우터는 독립 라이브러리이며, 이를 사용하면 리액트 애플리케이션에서 클라이언트 사이드 라우팅을 할 수 있다
                : 이 라이브러리에서는 선언적 방식을 사용해 라우트를 정의하고 관련 컴포넌트와 매핑할 수 있고, 이를 통해 애플리케이션의 네비게이션 구조를 만들 수 있다
                : 리액트 라우터를 사용하면 UI를 URL과 동기화할 수 있어 쉽게 클라이언트 사이드 라우팅을 처리하고 매끄러운 네비게이션 경험을 만들 수 있다

                : 리액트 라우터는 종합적인 기능들을 제공한다. 선언적 라우팅, 동적 라우트 매칭, 중첩된 라우트,
                  프로그래밍 가능한 네비게이션, 라우트 가드, 지연 로딩을 지원한다.

                - 라우트 구성하기
                    : 리액트 라우터 v6를 사용해서 리액트 애플리케이션의 라우팅을 설정할 때는 그 이전 버전과 접근법이 조금 다르다
                    : 라우트 설정 방법의 하나로 createBrowserRoute와 RouterProvider를 조합해서 활용해 라우트를 관리할 수 있다
                    : 이 방법은 HTML5 history API를 활용해서 사용자 인터페이스를 URL과 동기화하는 동시에 보다 모듈화된 설정을 할 수 있다
                    * createBrowserRoute와 RouterProvider를 사용해 라우트를 구성하는 예시는 router.jsx. 참고

                    : createBrowserRoute를 사용해 라우트 인스턴스를 만들고 createRoutesFromElements()를 사용해 라우트를 정의한다
                    : 이를 통해 JSX 기반 라우트를 구성할 수 있으며, 각 Route 컴포넌트는 하나의 경로와 해당 경로가 일치했을 때 렌더링될 하나의 요소를 지정한다

                - 라우트 이동하기
                    : 리액트 라우터는 Link 컴포넌트를 제공하며, 이를 사용하면 라우트 사이에 선언적 네비게이션을 할 수 있다
                    : Link 컴포넌트를 사용해 클릭할 수 있는 링크를 만들고, 해당 링크를 클릭하면 전체 페이지 새로 고침을 하지 않고도 다른 라우트로 이동할 수 있다
                    (to prop은 해당 링크를 클릭했을 때 이동할 라우트를 지정한다. 자세한 내용은 Navigation.jsx 참고)

                - 라우트 매개변수와 데이터 로딩
                    : 리액트 라우터를 사용하면 매개변수를 받는 동적 라우트를 정의할 수 있다.
                    : URL을 통해 데이터를 전달하고, 해당 매개변수에 기반해 컴포넌트를 렌더링하고 싶을 때 유용하다       
                    : 해당 라우트는 매개변수를 받고 해당 매개변수에 지정된 데이터를 로딩한다    
                    (자세한 내용은 UserProfile.jsx 참고)       

                - 중첩된 라우트
                    : 리액트 라우터는 중첩된 라우트를 지원한다. 중첩된 라우트를 사용하면 라우트와 컴포넌트의 계층적 구조를 만들 수 있다
                    : 복잡한 애플리케이션 구조를 갖고 있거나 URL에 기반해 중첩된 컴포넌트를 렌더링하고자 할 때 유용하다            
                    : Outlet 컴포넌트를 사용하여, 현재 URL 경로에 기반해 적절한 자식 컴포넌트를 렌더링한다
                    : 해당 설정은 애플리케이션 안에 명확한 계층 구조를 제공하며, 이는 URL 조각을 레이아웃과 연결하는 리액트 라우터의 철학과도 일치한다

                - 지연 로딩과 코드 분할
                    : 리액트 라우터는 지연 로딩과 코드 분할을 지원한다. 이를 활용하면 컴포넌트, 로더, 액션 및 다른 라우터 기반 코드를 필요할 때 로딩할 수 있다
                    : 이는 초기 번들의 크기를 줄이고 라우터 기반 코드를 필요할 때만 로딩함으로써 애플리케이션의 성능을 개선한다

                    : 지연 로딩을 수해하는 방법의 하나는 lazy prop을 사용하는 것이다. lazy prop은 일반적으로 동적 임포트의 결과를 반환하는 하나의 비동기 함수를 받는다
                    : 이 함수는 라우트가 매칭되면 실행되며, 라우트 정의의 매칭되지 않은 라우트 부분을 지연 로딩할 수 있다          
                    : lazy 함수는 각 모듈의 동적 임포트를 반환하고, 지연 로딩된 라우트 모듈 안에서 라우트에 정의하고자 하는 속성을 익스포트할 수 있다            

                    : lazy 함수는 다양한 라우트 속성을 해결하고 반환할 수 있다. 이 속성들은 해당 라우트에 접근할 때 라우트 정의에 통합된다
                    : 공식 문서에 따르면 lazy는 라우트 매칭 속성을 정의할 때 사용할 수 없다(예: path, pindex, children, caseSenstive 등)
                    이 속성들은 초기 라우트 매칭에 사용되며 이후 지연 함수가 실행된다

                    : lazy prop을 사용하면 초기 번들 크기를 상당히 줄이고 리액트 라우터 애플리케이션의 성능을 개선할 수 있다
                    : 이는 특히 많은 라우트를 가진 대규모 애플리케이션에 효과적이다

                - 결론
                    : 리액트 라우터는 리액트 애플리케이션에서 클라이언트 사이드 라우팅을 단순화하는 라이브러리이다
                    : 해당 라이브러리는 라우트를 정의하고, 라우트를 컴포넌트에 매핑하는 선언적 접근법을 제공한다
                    : 이를 활용하면 구조화되고 직관적인 네비게이션 프레임워크를 만들 수 있다
                    * 보다 종합적인 이해 및 고급 기능에 관해 알고 싶다면 공식 문서를 확인한다

            - Next.js와 앱 라우터
                : 리액트 라우터는 리액트 애플리케이션에서의 유연하고 강력한 해결책을 제공한다
                : 한편 Next.js는 통합된 다른 방법을 취하는데, 파일 시스템 기반 라우팅 솔루션인 '앱 라우터'이다
                : 이 라우팅 시스템은 Next.js 프레임워크 자체에 구현되어 있으며, 리액트 애플리케이션에서
                  라우팅을 다루기 위한 보다 완고하고 잠재적으로 단순한 방법을 제공한다

                : 서버 사이드 렌더링은 이 접근법에 통합되어 있으며, SEO를 개선하고 초기 페이지 로딩 시간을 개선하고
                  느린 디바이스 혹은 연결 상태에서 보다 나은 성능을 제공한다

                : 리액트 애플리케이션에서 SSR을 구현할 때는 서버와 클라이언트 모두에서 라우팅 로직을 처리해야 한다
                : 반면 Next.js 프레임워크들은 SSR을 내장 지원하기 때문에 구현을 보다 쉽게 할 수 있다
                : Next.js는 서버 사이드 렌더링과 라우팅을 기본적으로 다루므로, 개발자들은 이를 활용해 컴포넌트를 구현하고 라우트를 정의하는 데 초점을 둘 수 있다
                : 또한 새로운 앱 라우터 아키텍처 발표와 함께 Next.js는 리액트 서버 컴포넌트를 전면 지원한다

                    - 리액트 라우터와의 주요 차이
                        : 파일 시스템 기반 라우팅
                            - Next.js는 라우트를 프로그래밍적으로 정의하는 대신, 애플리케이션의 파일과 폴더 구조를 사용해 자동으로 라우트를 생성한다
                        : 서버 사이드 렌더링과 정적 사이트 생성
                            - Next.js는 이 렌더링 메소드들을 기본 지원하며, 이를 활용하면 성능과 SEO를 개선할 수 있다
                        : 자동 코드 분할
                            - Next.js는 코드를 라우트에 따라 자동으로 분할하며, 이는 로딩 시간을 잠재적으로 개선할 수 있다
                        : API 라우트
                            - Next.js를 사용하면 애플리케이션 구조의 일부로 API 엔드포인트를 만들 수 있다

                    - 파일 기반 라우팅
                        : Next.js 앱 라우터 설정에서는 app 디렉토리에 파일을 추가해 라우트를 만들 수 있으며, 파일 경로가 그대로 URL 경로가 된다
                            * app 디렉토리
                                app/
                                    page.js
                                    about/
                                        page.js
                                    blog/
                                        [slug]/
                                            page.js
                            > '/' 라우트는 app/page.js 이다
                            > '/about' 라우트는 app/about/page.js 이다
                            > '/blog/[slug]' 라우트는 app/blog/[slug]/page.js 이다

                    - 서버 컴포넌트와 클라이언트 컴포넌트
                        : 서버 컴포넌트는 리액트의 새로운 기능이다. 이를 활용하면 서버에서 실행되는 상태가 없는 리액트 컴포넌트를 만들 수 있다
                        : 이 컴포넌트들은 리액트 아키텍처에 서버 사이드 프로세싱의 능력을 더해주며, 이를 통해 몇 가지 계산 및
                          데이터 가져오기 태스크를 클라이언트로부터 서버로 옮긴다
                        : 한편, 클라이언트 컴포넌트는 클라이언트 사이드에서 실행되면서 애플리케이션의 상호작용(예: 사용자 입력 및 동적 업데이트 등)을 처리한다

                        : Next.js 앱 라우터를 사용하면 서버 컴포넌트/클라이언트 컴포넌트 모두를 강력하고 효율적인 방법으로 활용할 수 있다
                        : 서버 컴포넌트는 기본값이지만, 클라이언트 컴포넌트를 만들려면 파일 첫 부분에 'use client' 지시자를 사용해서 옵트인(opt-int)해야 한다 

                    - 데이터 가져오기
                        : 서버 컴포넌트를 사용하면 컴포넌트 안에서 직접 데이터를 가져올 수 있고, Next.js는 자동으로 서버에서 데이터 가져오기를 처리한다
                        * ProductPage.jsx 참고

                    - 상태 로딩하기와 에러 핸들링
                        : 앱 라우터 설정은 상태 로딩과 에러 처리에 관한 관습을 제공한다
                        : loading.js 와 error.js 파일을 작성해 이 상태들을 처리할 수 있다
                            * loading.js 및 error.js 파일
                                app/
                                    products/
                                        [id]/
                                            page.js # /products/:id에 대한 메인 페이지
                                            loading.js # /products/:id에 대한 로딩 UI
                                            error.js # /products/:id에 대한 에러 UI          

                        : Next.js는 자동으로 데이터 가져오기를 진행하는 동안 로딩 UI를 보여주고, 처리되지 않은 에러가 발생하면 에러 UI를 보여준다

                    - 모범 사례들
                        : Next.js 앱 라우터와 리액트 서버 커모넌트를 사용핼 때는 다음 모법 사례와 잠재적인 이점을 고려하자
                            - 기본적으로 서버 컴포넌트를 사용하되, 상호작용이나 클라이언트 상태 관리가 필요할 때만 클라이언트 컴포넌트로 opt-in 한다
                            - 이를 통해 클라이언트 사이드 자바스크립트 번들을 가볍게 유지할 수 있다

                            - 서버 컴포넌트와 클라이언트 컴포넌트 사이의 경계에 유의하라. 서버 컴포넌트는 클라이언트 사이드 API 혹은 상태를 유지 및 사용할 수 없다는 것을 기억하자
                            
                            - loading.js와 error.js 파일을 활용해 데이터 가져오기 및 에러 처리를 하는 동안 보다 나은 사용작 경험을 제공하자
                            
                            - Link 컴포넌트를 사용해 라우트 사이에서 클라이언트 네비게이션을 하라. 이 방법으로 사용하면 앱 라우터가 네비게이션을 최적으로 처리한다

                            - 서버 컴포넌트는 심지어 클라이언트 사이드 네비게이션에 대해서도 항상 서버에서 렌더링한다는 것을 기억하자
                            - 따라서 서버 사이드 컴포넌트를 가볍게 유지하고 무거운 계산을 피해야 한다

                            - 서버 컴포넌트와 클라이언트 컴포넌트 사이에서 데이터를 전달할 때는 조심하라. 큰 데이터를 전송하면 성능에 영향을 줄 수 있다
                            - 초기 렌더링이 필요하지 않다면 클라이언트 컴포넌트에서 데이터를 가져오는 것도 고려하자

                            - 캐싱 메커니즘을 활용해 서버 컴포넌트에서 데이터를 가져옴으로써 서버에 대한 불필요한 왕복을 피하자

                            - 서버 컴포넌트 사이에서 상태를 공유해야 한다면 해당 상태를 공유된 클라이언트 컴포넌트로 전달하는 것을 고려하자

                            - 정기적으로 애플리케이션의 성능을 감시하고 측정해 병목을 식별하고 최적화하자

                    - 결론 
                        : Next.js 앱 라우터는 리액트 애플리케이션의 라우팅 처리 방법의 중요한 진화를 보여준다
                        : 앱 라우터는 서버 컴포넌트와 클라이언트 컴포넌트를 혁신적으로 사용함으로써 서버 사이드 효율성과 
                          클라이언트 사이드의 상호작용성을 합쳤다
                        : 파일 시스템 기반 라우팅과 서버 컴포넌트의 견고한 기능을 활용함으로써 데이터 가져오기와 계산에 필요한 부담을 
                          서버로 이동시켰으며, Next.js는 다양한 웹 애플리케이션에서의 성능을 최적화하는 동시에 사용자 경험을 개선한다

    >>> 라우팅은 대규모 리액트 애플리케이션의 핵심적인 측면이다. 라우팅을 사용하면 사용자들은 다양한 뷰와 컴포넌트를 이동할 수 있으며
        매끄럽고 직관적인 사용자 경험을 제공한다. 대규모 리액트 애플리케이션을 구축한다면 다음 사항들을 유념하자
            - 애플리케이션의 요구사항(성능, SEO, 서버 사이드 렌더링 등)에 기반해 적절한 라우팅 접근법을 선택하라
            - 중첩된 라우팅의 능력을 활용해 모듈화되고 유지보수 가능한 애플리케이션 구조를 만들라
            - 지연 로딩, 코드 분할 및 다른 성능 최적화 기법들을 구현해 애플리케이션의 로딩 시간과 사용자 경험을 개선하라
            - 라우팅과 데이터 가져오기, 상태 관리 및 애플리케이션의 필수적인 측면들을 통합해 응집되고 효율적인 개발 경험을 만들라
            - 라우트와 컴포넌트를 충분히 테스트해서 버그를 찾아냄으로써 신뢰성을 보장하고, 높은 품질의 코드베이스를 유지하라

            >>> 대규모 리액트 애플리케이션의 성공적인 라우팅의 핵심은 단순함, 성능, 유지보수성의 올바른 균형을 찾는 것에 있음을 기억하자
                모범 사례들을 따르고, 강력한 도구와 라이브러리를 활용하고, 지속적으로 라우팅 구현을 다듬음으로써 뛰어난 사용자 경험을
                제공하는 강건하고 확장 가능한 애플리케이션을 만들 수 있다                      