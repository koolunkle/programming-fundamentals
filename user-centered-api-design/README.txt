[사용자 중심 API 디자인]
API를 사용하면 서로 다른 소프트웨어 시스템 사이에서 통신할 수 있다
API는 메소드와 데이터 구조를 지정하며 개발자들은 이를 사용해 서비스 혹은 플랫폼과 상호 작용할 수 있다

API 디자인은 모던 소프트웨어 개발의 가장 중요한 기반 요소이다
API는 서로 다른 시스템들이 통신하고 기능을 공유할 수 있게 한다

API 디자인의 품질은 개발 프로세스, 사용자 경험, 그리고 장기적인 유지보수성에 큰 영향을 준다
이번에는 효과적이고 사용자 친화적인 API를 만들기 위한 가이드를 확인한다

API는 내부 애플리케이션과 도구를 위한 빌딩 블록(조직 내 다양한 시스템들이 매끄럽게 함께 작동하게 하는)인 동시에,
종종 '제품 그 자체'이기도 하다. 많은 경우 API는 기업의 서비스와 사용자가 상호작용하는 주된 방법이다
특히 데이터 서비스, 결제 및 지불 처리, 혹은 다른 클라우드 기반 기능을 제공하는 기업에게 그렇다

예를 들어 Stripe, PayPal 같은 기업들은 결제 프로세싱 API를 제공하며, 개발자들은 이를 애플리케이션에 통합해 트랜잭션을 처리할 수 있다
API 자체가 제품이며, 개발자들은 이를 구입하고 활용해 자신의 애플리케이션에 핵심적인 기능을 추가할 수 있다
좋은 API 디자인은, API가 제품이자 서비스 자체인 경우, 고객 만족과 비즈니스 성공에 직접적인 영향을 주기 때문에 특별히 중요하다

잘 정의된 API는 효율적인 개발과 강건한 애플리케이션을 만드는 데 도움이 된다. 한편, 잘 정의되지 앟ㄴ은 API는 유지보수의 악몽을 만든다
API 디자인은 개발자가 이를 얼마나 쉽게 이해하고 사용할 수 있는지에 영향을 주며, 이는 결과적으로 생산성과 애플리케이션 품질에 직접적인 영향을 준다

또한 사려 깊은 디자인에 들이는 시간과 노력은 장기적인 안정성과 사용자 만족을 가져다준다. 개발 초기부터 API 품질에 투자함으로써 이후의 수많은 이슈들을 방지할 수 있다
이는 명확하고 일관성 있는 명명 규칙, 충분한 문서, 사려 깊은 에러 핸들링 같은 측면의 고려를 포함한다

이번에는 사용자 중심 API(직관적이고, 사용하기 쉽고, 개발자 경험을 염두에 두고 설계된 API)를 만드는 몇 가지 전략에 관해 살펴보자
사용자 중심 API 디자인에 초점을 둠으로써 기능적일 뿐만 아니라 즐겁게 사용할 수 있는 API를 만들 수 있다.
이는 차례로 긍정적인 개발자 경험을 늘리고, 도입을 촉진하며, 우리의 API 소프트웨어 프로젝트에 장기적인 성공을 보장한다

    - 일관성
        : 일관성은 매끄럽고 직관적인 개발자 경험을 만드는데 매우 중요하다. API가 다양한 컴포넌트에서 일관성을 유지하면
          개발자의 인지 부하를 줄이므로, 개발자들은 API를 보다 쉽게 이해하고 사용할 수 있다
        : 일관성이 반드시 필요한 세 가지 영역은 다음과 같다
            - 명명 규칙
                : 명확하고 일관성 있는 명명 규칙을 사용하면 개발자들은 API를 보다 효과적으로 이해하고 사용할 수 있다
                : 일관성 있고 직관적인 이름은 API가 스스로 설명하게 함으로써 개발자의 학습 곡선을 줄이고
                  오해나 에러의 가능성을 최소화한다 API의 명명 규칙을 만들 때는 다음 원칙을 고려하자
                
                : 명확한 설명적 이름을 사용하라
                    - 리소스 혹은 액션을 정확하게 설명하는 이름을 선택하라. 사용자에게 혼란을 줄 수 있는 약어, 암호 같은 줄임말은 피하라
                        : 나쁨 
                            - /u, /p
                        : 좋음
                            - /user, /products

                : 소문자와 하이픈만 사용하라
                    - 여러 단어로 구성된 리소스 이름에서는 소문자와 하이픈을 사용하라. 이는 가독성을 높이며 일반적인 URL 규칙을 준수한다
                        : 나쁨 
                            - /orderItems, /ShippingAddresses
                        : 좋은
                            - /order-items, /shipping-addresses

                : 리소스 이름에는 명사를 사용하라
                    - 리소스는 전형적으로 시스템의 엔티티들을 나타내므로 이들의 이름에는 명사를 사용하라
                    - 리소스는 액션이 아닌 사물임을 명확하게 해준다
                        : 나쁨
                            - /getCustomers, /createOrder
                        : 좋음
                            - /customers, /orders

                : CRUD 조작에 맞지 않은 액션에 대해서는 동사를 사용하라                       
                    - HTTP 메소드(GET, POST, PUT, DELETE 등)에 자연스럽게 매핑되지 않는 조작에 대해서는
                      동사를 사용해 해당 액션을 기술하라. 이는 이 액션들이 표준 CRUD(생성, 읽기, 수정, 삭제) 조작과는 다른
                      특별한 액션임을 구분하는 데 도움을 준다
                        : 나쁨
                            - /order-cancellation, /password-reset
                        : 좋음
                            - /orders/{orderId}/cancel, /users/{userId}/reset-password

                : 복수를 일관성 있게 표현하라
                    - 리소스 이름을 표현할 때 단수 혹은 복수를 선택하고 API 전체에서 일관성을 유지하라
                    - 이를 통해 개발자들에게 서로 다른 리소스들과 상호작용하는 방법을 예상하는 데 도움을 줄 수 있다
                        : 나쁨(혼합)
                            - /customer, /orders, /product
                        : 좋음(모두 복수)
                            - /customers, /orders, /products
                        : 좋음(모두 단수)
                            - /coustomer, /order, /product

                * 다음은 위 명명 규칙을 실제 API에 적용한 예시이다
                    customer, order, product 도메인을 갖는 API 예시
                        GET /customers
                        POST /customers
                        GET /customers/{customerId}
                        PUT /customers/{customerId}
                        DELETE /customers/{customerId}
                        GET /customers/{customerId}/orders                            
                        POST /customers/{customerId}/orders                            
                        GET /orders/{orderId}                            
                        PUT /orders/{orderId}                            
                        DELETE /orders/{orderId}                            
                        POST /orders/{orderId}/cancel
                        GET /products                            
                        GET /products/{productId}                            
                        GET /products/{productId}/reviews                            
                        POST /products/{productId}/reviews                            

            - 리소스 구조
                : API 리소스 구조는 일관성을 통해 사용성을 크게 향상시킬 수 있는 또 하나의 영역이다
                : 잘 구조화된 API는 리소스를 논리적이고 직관적인 방법으로 조직하며, 이는 개발자들이 서로 다른 엔티티
                  사이의 관계와 API를 탐색하는 방법을 쉽게 이해하도록 돕는다
                : API 리소스 구조를 디자인할 때는 다음을 고려하자 
                    
                    - 계층을 사용해 괸계를 나타내라
                        : 중첩된 리소스는 소속 혹은 조합을 나타낸다
                            * 중첩된 리소스
                                /customers/{customerId}/addresses
                                /orders/{orderId}/items
                            > address가 customers에, items가 order에 속해 있다는 것을 명확하게 보여준다

                    - URL을 가능한 한 짧게 유지함으로써 명확함을 유지하라
                        : 중첩은 유용할 수 있지만 너무 긴 URL을 사용하는 것은 피하라
                            * 중첩된 URL의 좋은 예와 나쁜 예
                                [좋음]
                                /orders/{orderId}/items
                                [나쁨]
                                /customers/{customerId}/orders/{orderId}/items/{itemId}/variants

                    - 필터링, 정렬, 페이징을 위해 매개변수를 사용하라
                        : 이를 통해 베이스 URL을 명확하게 유지할 수 있고, 유연한 질의를 가능하게 할 수 있다
                            * 쿼리 매개변수 사용하기
                                GET /products?category=electronics&sort-price&page=2&limit-20

                    - 유사한 리소스에 대해 일관성 있는 패턴을 사용하라
                        : 두 리소스가 유사한 구조를 갖는다면, 이들을 표현하는 방식에도 일관성을 유지하라
                            * 유사한 구조를 갖는 두 리소스
                                GET /users/{userId}/profile
                                GET /companies/{companyId}/profile
                        
                        : 다음은 이 원칙들을 적용해 e-커머스 API를 구조화한 예시이다
                            * 일관성 있는 리소스 구조를 갖는 e-커머스 API 예시
                                /users
                                /users/{userId}
                                /users/{userId}/orders
                                /users/{userId}/addresses

                                /products
                                /products/{productId}
                                /products/{productId}/reviews

                                /orders
                                /orders/{orderId}
                                /orders/{orderId}/items
                                /orders/{orderId}/shipments

                                /categories
                                /categories/{categoryId}
                                /categories/{categoryId}/products

            - 응답 형식
                : 일관성 있는 응답 형식을 제공함으로써 개발자들이 API에 무엇을 기대할 수 있는지 보장할 수 있다
                : 응답이 일관성 있는 구조를 따르면 개발자들은 훨씬 쉽게 API가 반환하는 데이터를 파싱하고 다룰 수 있다
                : 다음은 응답 형식에서 일관성을 유지하기 위한 몇 가지 고려 사항이다
                    - 모든 응답에 대해 일관성 있는 구조를 사용하라
                        : 성공과 에러 응답에 대해 유사한 형식을 유지하라
                            * 성공과 에러 응답 예시
                                [성공 응답]
                                {
                                    "status": "success",
                                    "data": {
                                        "id": 123,
                                        "name": "John Doe",
                                        "email": "john@example.com"
                                    }
                                }                                
                                [에러 응답]
                                {
                                    "status": "error",
                                    "data": {
                                        "message": "User not found",
                                        "code": "NOT_FOUND"
                                    }
                                }

                    - 리소스에 대해 일관성 있는 필드명을 사용하라
                        : 여러 리소스가 유사한 속성을 갖는다면, 같은 속성 이름을 사용하라
                            * 서로 다른 리소스에서 createdAt과 updatedAt 사용하기
                                [User]
                                {
                                    "id": 123,
                                    "createdAt": "2023-07-01T12:00:00Z",
                                    "updatedAt": "2023-07-02T14:30:00Z",
                                    "name": "John Doe",    
                                }                                    
                                [Product]
                                {
                                    "id": 456,
                                    "createdAt": "2023-06-15T01:00:00Z",
                                    "updatedAt": "2023-06-16T11:45:00Z",
                                    "name": "Smartphone X",    
                                }        

                    - 일관성 있는 날짜와 시간 형식을 사용하라
                        : 모든 날짜와 시간 필드에 대해 ISO 8601 같은 표준 형식을 준수하라
                            * 서로 다른 데이터 필드에 대한 ISO 8601 형식 유지하기
                                {
                                    "createdAt": "2023-07-01T12:00:00Z",
                                    "updatedAt": "2023-07-02T14:30:00Z",
                                    "scheduledFor": "2023-07-10T09:00:00+02:00",
                                }            

                    - 일관성 있는 메타데이터를 제공하라
                        : 페이지네이션 정보 혹은 요청 식별자 같은 메타데이터를 모든 목록 응답에 일관성 있게 포함하라
                            * 페이지네이션 정보를 포함한 메타데이터
                                {
                                    "status": "success",
                                    "data": [
                                        // 아이템 배열
                                    ],
                                    "metadata": {
                                        "page": 2,
                                        "perPage": 20,
                                        "totalItems": 157,
                                        "totalPages": 8
                                    },
                                    "requestId": "req_abc123"
                                }                                

                    > 명명 규칙, 리소스 구조, 응답 형식에 대한 일관성 원칙을 준수함으로써 쉽게 이해하고, 사용하고,
                      유지보수 가능한 API를 만들 수 있다. 이 일관성은 개발자 경험을 개선함을 물론 API의 전반적인 신뢰성과 사용성을 향상한다

    - 에러 핸들링
        : 에러 핸들링은 개발자 경험과 API의 사용성에 직접적인 영향을 미치는 매우 중요한 요소이다
        : 잘 디자인 된 에러 응답은 개발자로 하여금 빠르게 이슈를 식별하고 해결하도록 도와주며, 전체적인 개발자 경험을 개선한다
        : API에서의 에러 핸들링 디자인에 관한 몇 가지 모법 사례를 살펴보자. 여기에는 일관성 있는 에러 구조
          의미 있는 에러 메시지, 적절한 HTTP 상태 코드의 사용 등이 포함된다                  

            - 적절한 HTTP 상태 코드를 사용하라
                : HTTP 상태 코드는 요청 결과에 대한 표준화된 방법을 제공한다. 이들은 일관성 있고 적절하게 사용되어야 한다
                : 2xx는 요청 성공을 의미한다 - e.g. 200 OK, 201 Created 등
                : 4xx는 클라이언트 에러를 의미한다 - e.g. 400 Bad Request, 404 Not Found 등
                : 5xx는 서버 에러를 의미한다 - e.g. 500 Internal Server Error 등

            - 상세한 에러 메시지를 제공하라
                : 에러 메시지는 간결하고 필요한 정보를 담고 있어야 한다. 개발자들이 무엇이 잘못되었는지, 
                  어떻게 수정해야 하는지 이해할 수 있도록 충분한 컨텍스트를 제공해야 한다
                : 에러 메시지에 민감한 정보들이 노출되지 않도록 주의하라
                    * 상세한 정보를 담은 명확한 에러 페이로드
                        {
                            "status": "error",
                            "message": "Invalid email format",
                            "code": "INVALID_EMAIL",
                            "details": "Provided email 'johndoe@example' is missing a domain"
                        }               

            - 일관성 있는 에러 메시지 구조를 사용하라
                : 모든 에러 응답이 일관성 있는 형태를 준수함을 보장하라. 이를 통해 개발자들은 프로그래밍적으로 에러를 쉽게 파싱하고 다룰 수 있다
                    * 에러 응답 구조
                         {
                            "status": "error",
                            "message": "string",
                            "code": "string",
                            "details": "string",
                            "requestId": "string"
                        }        

            - 고유한 에러 코드를 포함하라
                : 가능하다면 다른 타입의 에러에 대해 고유한 에러 코드를 할당하라. 이를 통해 개발자들은 특정한 에러 시나리오를 쉽게 식별하고 처리할 수 있다
                    * 잔액 부족에 대한 고유한 에러 코드
                        {
                            "status": "error",
                            "message": "Insufficient founds",
                            "code": "INSUFFICIENT_FOUNDS",
                            "details": "Your account balance is $50, but the transaction requires $100"
                        }       

            - 검증 에러를 처리하라
                : 여러 필드를 포함한 요청에 대해서는 각 필드마다 개별적으로 전달하지 말고 모든 검증 에러를 한번에 전달하라
                : 이는 개발자들의 시간을 아껴주고 불필요한 API 호출을 줄이는데 도움이 된다
                    * 2개의 다른 폴 필드에 대한 검증 에러
                        {
                            "status": "error",
                            "message": "Validation failed",
                            "code": "VALIDATION_ERROR",
                            "errors": [
                                {
                                    "field": "email",
                                    "message": "Invalid email format"
                                },
                                {
                                    "field": "password",
                                    "message": "Password must be at least 8 characters long"
                                },
                            ]
                        }       


            - 디버깅을 위해 에러를 기록하라
                : API 소비자에게 명확한 에러 메시지를 제공하는 것은 중요하다.
                  그리고 디버깅을 위해 서버 사이드에 상세한 에러 정보를 기록함을 보장하는 것도 중요하다
                : 이를 통해 API 사용자에게 민감한 정보를 노출하지 않고 보다 효과적으로 이슈를 조사하고 해결할 수 있다
                : 내부 로그에 스택 추적, 요청 매개변수, 시스템 상태 등을 포함할 수 있지만
                  비밀번호나 API 키 같은 민감한 데이터는 기록하지 않도록 유의해야 한다
                  (Shopify의 READ Admin API - 상태 및 에러 코드 참고)

    - 문서화
        : 종합적이고 잘 구조화된 문서는 사용자 중심 API를 만드는 데 필수적이다. 이런 문서는 개발자들이
          API를 효과적으로 사용하는 방법을 이해하기 위한 기본 리소스의 역할을 한다
        : 좋은 문서는 학습 곡선을 상당히 줄이고, 지원 요청을 최소화하고, 도입 비율을 높여준다
        : API를 위한 문서를 작성할 때 고려해야 할 핵심적인 측면들은 다음과 같다
            - 명확한 개요를 만들라
                : API에 대한 고수준의 개요에서 시작하라. 고수준 개요는 API의 목적과 주요 기능, 인증 메소드,
                  기존 URL, 버전 관리 정보, 일반적인 유스 케이스 혹은 예시 시나리오를 포함한다
                : 이 개요를 통해 개발자들은 API가 무엇을 제공하는지, 프로젝트에 API를 어떻게 통합할 수 있는 지 빠르게 이해할 수 있다
                    * 예를 들어 다음과 같이 문서 작성을 시작할 수 있다
                        `Example E-commerce API를 사용하면 개발자들은 우리 제품 카탈로그, 주문 관리, 고객 데이터를
                        그들의 애플리케이션에 통합할 수 있다. 모든 API 요청의 기본 URL은 https://api.example.com/v1이며 
                        인증을 위해서는 OAuth2.0을 사용한다`

            - 상세한 엔드포인트 문서
                : 각 엔드포인트에 관해 총체적인 정보를 제공하라. 이 정보에는 HTTP 메소드와 전체 URL,
                  엔드포인트의 목적 설명, 요청 매개변수(경로, 쿼리, 헤더, 바디), 응답 형식 및 가능한 상태 코드를 포함해야 한다
                : 예시 요청과 응답을 포함해 해당 엔드포인트가 실제로 작동하는 방식을 포함하라
                : 예를 들면, 'Get Product Detail' 엔드포인트를 문서화하면서 HTTP 메소드(GET), URL(/products/{productId}),
                  엔드포인트가 하는 일에 대한 설명, 엔드포인트가 받는 매개변수, 응답 형태 등을 포함하는 식이다
                  (Stripe API reference/overview 절 참고)

            - 코드 샘플을 포함하라
                : 잘 알려진 프로그래밍 언어를 사용한 코드 샘플을 제공해 API를 사용하는 방법을 보여주라
                : 이를 통해 개발자들은 API를 그들이 선호하는 언어 혹은 프레임워크에 통합하는 방법을 신속하게 이해할 수 있다
                : 예를 들면, Node.js를 사용해 API에 요청을 남기는 방법을 보여주는 자바스크립트 스니핏 혹은 리액트 같은
                  자바스크립트 클라이언트 라이브러리를 보여줄 수 있다

            - 인증에 관해 설명하라
                : API에 대한 인증 방법을 명확하게 설명하라. 여기에는 API 키 또는 토큰을 얻는 단계,
                  요청에 인증을 포함하는 방법, 보안 모범 사례 등을 포함한다
                : 적절한 인증 문서를 통해 개발자들은 처음부터 API를 안전하게 사용할 수 있다
                  (깃허브에서 제공하는 커밋 REST API 엔드포인트 참고)

    - 버저닝
        : 버저닝은 API에서 매우 중요하다. 버저닝은 기존의 사용자에게 혼란을 주지 않으면서 API의 변경과 업데이트를 관리할 수 있게 해준다
        : API가 비즈니스의 핵심 전략 제품 혹은 서비스 역할을 하는 경우 이는 특히 중요하다
        : 고객의 유지보수 안정성과 신뢰성이 기업의 성공과 평판에 필수적이기 때문이다

        : 잘 고안된 버저닝 전략을 사용하면 새로운 기능과 개선 사항을 도입하면서도 하위 호환성을 유지할 수 있다
        : API를 위한 몇 가지 모범 사례(다양한 버저닝 전략, 버저닝 전략 구현 방법, 변경 사항을 개발자들과 소통하는 방법)에 관해 살펴보자
            - 버저닝 전략 
                : API 버저닝 전략은 다양하며 각 전략은 장단점을 갖는다. 가장 일반적인 전략에는 URL 버저닝,
                  쿼리 매개변수 버저닝, 헤더 버저닝이 있다
                    - URL 버저닝   
                        : URL 버저닝은 API의 기본 URL에 버전 번호를 포함한다. 가장 직관적이고 널리 사용되는 버저닝 전략이다
                            * URL 버저닝 예시
                                - GET /v1/users/123  
                                - GET /v2/users/123
                                [장점]
                                    - 쉽게 이해하고 구현할 수 있다
                                    - 상이한 버전들을 명확하게 분리할 수 있다
                                    - 상이한 버전들을 상당히 다르게 변경할 수 있다
                                [단점]
                                    - URL의 숫자가 많아질 수 있다 
                                    - 사소한 변경에 덜 유연하다

                    - 쿼리 매개변수 버저닝
                        : 쿼리 매개변수 버저닝은 요청 URL에 API 버전을 매개변수로 지정한다
                            * 쿼리 매개변수 버저닝 예시
                                - GET /users/123?version=1
                                - GET /users/123?version=2
                                [장점]
                                    - 기본 URL을 깔끔하게 유지할 수 있다
                                    - 쉽게 구현하고 사용할 수 있다
                                    - 세세한 버전 관리를 할 수 있다
                                [단점]
                                    - 개발자들이 쉽게 놓칠 수 있다
                                    - 캐싱 전략을 복잡하게 만들 수 있다
                                    - 주요 버전을 명확하게 구별하기 어렵다

                    - 헤더 버저닝
                        : 헤더 버저닝은 커스텀 HTTP 헤더에 API 버전을 지정한다
                         * 헤더 버저닝 예시 
                            - GET /users/123
                                Header: API-Versoin: 1
                            [장점]
                                - URL을 명확하고 깔끔하게 유지할 수 있다
                                - 버전 관리와 리소스 식별자를 분리할 수 있다 
                            [단점]
                                - 쉽게 간과할 수 있다
                                - 브라우저에서 테스트하기 어려울 수 있다
                                - 서버에서 커스템 헤더를 처리해야 한다 

            >>> 개발하는 API의 니즈와 특성에 따라 적절한 버저닝 전략을 선택해야 한다
                URL 버저닝은 단순함과 명확함 때문에 가장 많이 선호된다
                한편, 쿼리 매개변수 버저닝과 헤더 버저닝은 특정한 시나리오에서 훨씬 더 많은 유연함을 제공한다       
                (API 버전에 관한 깃허브 REST API 문서 참고)

            >>> URL 버저닝 간단한 예시
                * GET /v1/products
                    {
                        "data": [
                            { "id": 1, "name": "Product A" },
                            { "id": 2, "name": "Product B" }
                        ]
                    }
                
                * GET /v2/products
                     {
                        "data": [
                            { "productId": 1, "productName": "Product A" },
                            { "productId": 2, "productName": "Product B" }
                        ]
                    }

    - 구식화와 종료
        : 새로운 버전을 도입할 때는 이전 버전의 구식화 및 궁극적인 종료에 관한 명확한 정책을 마련해야 한다. 이 정책에는 다음 항목들을 포함한다
            - 구식화 고지하기
                : 해당 버전이 구식화될 것이며, 궁극적으로 제거될 것임을 명확하게 소통한다
            - 타임라인 제공하기 
                : 사용자에게 새로운 버전으로 마이그레이션할 수 있는 유예 기간을 제공한다
            - 구식화 관련 경고 보내기
                : 가능하다면 API 응답에 오래된 버전에 대한 구식화 경고를 포함한다
            - 마이그레이션 지원 제공하기
                : 사용자가 새로운 버전으로 마이그레이션할 때 참고할 수 있는 문서, 도구, 지원을 제공한다

        >>> 사려 깊은 버저닝 전략을 구현함으로써 시간에 따라 API를 변경할 수 있고, 기존 사용자들에게
            지속적으로 긍정적인 개발자 경험을 제공할 수 있다. 이 접근법을 활용하면 기존 통합을 깨뜨릴 걱정 없이 API를 혁신하고 개선할 수 있다

    - 보안
        : API 디자인에서 보안은 중요한 측면이다. 잘 디자인된 API는 충분한 기능을 제공하고, 사용자 친화적일 뿐만 아니라 안전하다
        : 강건한 보안 정책을 구현함으로써 API 제공자와 그 사용자를 잠재적인 위협과 취약점으로부터 보호할 수 있다
        : API 보안과 관련된 주제는 매우 다양하며, 몇 가지 핵심 포인트는 다음과 같다

        : 인증과 허가
            - 인증과 허가는 API 보안의 기본 요소이다
            - 인증은 사용자 혹은 서비스의 신원을 검증하는 것이다. 접근을 요청하는 엔티티가 그들이 신고한 것과 일치하는지 확인한다
            - 이 프로세스는 합법적인 사용자들만 제공하는 데이터나 기능에 접근할 수 있기 때문에 API 보안을 유지하는 데 매우 중요하다
            - 인증은 애플리케이션의 복잡성이나 요구사항에 따라 다양한 방법으로 구현할 수 있다
            
            - API 키
                : 간단한 애플리케이션에 사용한다
            
            - OAuth2.0
                : 위임된 접근을 요구하는 보다 복잡한 시나리오에 사용한다

            - JSON 웹 토큰
                : 상태를 갖지 않는 인증에 사용한다

            > Node.js에서 JWT를 사용한 간단한 인증 엔드포인트 예시는 auth-with-jwt.js에서 참고할 수 있다
              해당 예시는 엔드포인트는 사용자 로그인 요청을 처리하며, 사용자 크리덴셜을 검증하고, 해당 크리덴셜이 유효하면 JWT를 생성한다
              요청이 인증된 뒤에는 허가를 구현해 사용자 혹은 서비스가 액션을 수행하거나 데이터에 접근할 수 있는 올바른 권한을 가지고 있음을 보장할 수 있다


        : 보안 헤더
            - 보안 헤더를 구현하면 클릭 재킹, 사이트 간 스크립팅 및 사이트 간 삽입 같은 특정한 유형의 공격으로부터 API를 보호하는 데 도움이 된다
            - 이런 헤더들은 Content-Security-Policy, Content-Type, Strict-Transport-Security 같은 항목들을 포함한다
              (secure-header.js 참고)              

        : 입력 검증과 안전성 검사
            - 보안 헤더 구현과 함께 사용자 입력을 검증하고 안전성 검사를 함으로써 삽입 공격이나 다른 악의적 활동으로부터 API를 보호하는 것이 중요하다
            - 효과적인 검증을 통해 입력되는 데이터가 기대하는 타입, 형식, 값의 범위를 갖는지 보장할 수 있다
            - 안전성 검사는 특수문자들을 제거하거나 변환해 이들이 애플리케이션에서 위험한 동작을 촉발하지 않도록 막는 것을 포함한다
            - 사용자 등록 엔드포인트에 대한 입력 검증을 수행하는 간단한 예시는 다음과 같다 (sanitizatoin.js 참고)

        : 교차 출처 리소스 공유(CORS)
            - 교차 출처 리소스 공유는 웹페이지의 리소스를 자신의 출처가 아닌 다른 출처에서 요청되는 것을 허용 또는 제한하는 보안 기능이다
            - 이는 상이한 도메인에서 호스팅되는 API와 상호작용하는 모던 웹 애플리케이션에서 매우 중요하다 

        : 레이트 제한
            - 레이트 제한을 구현하면 API를 오용이나 잠재적인 서비스 거부 공격에서 보호할 수 있다
            - 지정한 시간 이내에 클라이언트가 요청할 수 있는 요청 숫자를 제한하는 형태로 구현한다
              (rate-limit.js 참고)
            
        >>> 보안은 API 디자인에서 매우 중요하며 간과해서는 안 된다. 기본적인 보안 프랙티스와 함께 항상 HTTPS를 사용함으로써
            전송 중인 데이터를 보호하는 동시에 이 보안 수단들을 활용해 API와 사용자를 잠재적인 위협과 취약점으로부터 보호해야 한다

        >>> API 보안은 폭넓은 주제이며 다양한 사항들을 고려해야 한다
            해당 주제에 관해 더 많이 알고 싶다면 OWASP Cheat Sheet Series를 참조하자
            특히 REST Security Cheat Sheet, GraphQL Cheat Sheet는 REST API와 GraphQL API를 보호하는 데 도움이 되는 좋은 모범 사례들을 제공한다

    - 이해관계자 참여
        : 사용자 중심 API를 개발할 때는 기술적인 사항에 관해 고려하는 것은 물론, 이해관계자의 니즈를 이해하고 만족시켜야 한다
        : 효과적인 이해관계자 참여는 목적하는 바를 정확하게 제공하고 사용자를 만족시키는 API를 만드는 데 필수적이다
            - 먼저 모든 관련된 이해관계자를 식별하라
                : 여기에는 전형적으로 내부 팀(제품 관리자, 개발자, 고객 지원 등), API를 사용할 외부 개발자, API를 자신들의 애플리케이션에
                  통합할 잠재적인 최종 사용자가 포함된다. 각 그룹은 모두 상이한 관점과 요구사항을 갖고 있다
            
            - 일찍, 빈번하게 피드백을 수집하라
                : API 디자인을 완료하기 전에 API 명세 초안을 핵심 이해관계자들에게 공유하라
                : 모의 엔드포인트를 만들거나 대화형 API 문서를 작성해 이해관계자들이 제안된 API 구조를 살펴보고
                  테스트할 수 있게 하는 과정을 포함할 수 있다. Swagger, Postman 같은 도구들을 활용할 수 있다

            - 외부 개발자의 니즈를 예의 주시하라
                : 개발자 릴레이션 프로그램을 만들어 API 사용자와 지속적인 소통을 하는 것을 고려하라
                : 개발자 포럼, 정기적인 피드백 세션, 혹은 새로운 API 기능을 출시하기 전 테스트를 위한 베타 프로그램들을 포함할 수 있다

            - 내부에서의 정렬도 중요하다
                : API 디자인이 속한 기업의 전반적인 제품 전략 및 기술 로드맵과 정렬되어 있게 하라. 
                : 제품 관리자 및 다른 내부 팀과 정기적인 확인을 통해 API가 보다 넓은 비즈니스 목표를 지원하는 방향으로
                  진화하고 있는지 보장하는 데 도움을 얻을 수 있다

            - 이해관계자 참여는 현재 진행형 프로세스임을 기억하라
                : API가 진화하는 동안 계속해서 피드백을 찾고 실세계의 사용 형태와 변경되는 요구사항에 기반해 조정할 준비를 하라
                : 이 반복적 접근법은 API가 시간이 지나도 가치 있고 관련성이 높은 상태를 유지하는 데 도움이 된다

    - 최종 고려 사항
        : API를 만들고 다루는 과정에서 염두에 두어야 할 다른 중요한 사항들도 많은데 여기에는 성능 최적화, 분석 및 모니터링 설정 등도 포함된다
        : 사용자 중심 API를 만든는 것은 현재 진행형 프로세스임을 기억하자. 새롭게 나타나는 트렌드,
          사용자 피드백, 진화하는 비즈니스 니즈에 지속적으로 반응하고 적응해야 한다
        : 이러한 변화에 예의주시하고 능동적으로 대응함으로써 API가 관련성 있고, 효과적이며, 개발자들이 즐겁게 사용할 수 있는 것임을 보장할 수 있다 

        > 더 읽을 거리
            - API design
            - Designing for humans: better practices for creating user-centric API experiences
            - Designing Good API Experiences
            - RESTful 웹 API 디자인
            - Best Practices in API Design

     

