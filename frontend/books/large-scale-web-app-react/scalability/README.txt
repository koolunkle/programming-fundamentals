[확장 가능한 웹 아키텍처]
확장성은 필요할 때 리소스를 추가하거나 제거함으로써 다양한 워크 로드를 처리하는 시스템의 능력을 말한다
확장성이란 한마디로 (시스템의) 성장을 우아하게 다룰 수 있는 웹 아키텍처의 능력이라 요약할 수 있다

사용자, 트랜잭션, 요청 혹은 데이터가 늘어남에 따라 시스템에 그 성능을 유지하거나 개선할 수 있고, 
중단 없는 서비스를 제공하고 지속적으로 비용-대비-효과를 거둘 수 있음을 의미한다

확장성은 선형적으로 확장될 수 있는 인프라스트럭처를 구축하는 것을 의미한다
즉, 리소스를 추가하면 선형적으로 추가된 리소스에 따라 성능이 개선되는 것이다

확장 가능한 웹 아키텍처는 다양한 컴포넌트로 구성된다.
이 컴포넌트들은 함께 작동해 애플리케이션이 증가된 워크로드를 처리할 수 있음을 보장한다.

     - 로드 밸런서
        : 로드 밸런서는 확장 가능한 웹 애플리케이션의 핵심적인 컴포넌트이다
        : 로드 밸런서는 유입되는 트래픽을 여러 서버에 분산시켜 부하의 균형을 맞추고 개별 서버가 과도한 부하에 의해 오작동하는 것을 방지한다
        : 해당 분산을 통해 높은 트래픽이 몰리더라도 최적의 성능을 유지할 수 있다
        : 로드 밸런서는 클라이언트와 서버 클러스터 사이에 위치하며 웹사이트 혹은 애플리케이션으로 유입되는 모든 트래픽의 진입점 및 관리 역할을 한다
            클라인언트 A, B, C > 인터넷 > 로드 밸런서 > 서버 1, 서버 2, 서버 N
        : 로드 밸런서 구성은 복잡해질 수 있으며 트래픽을 효과적으로 분산시키기 위한 다양한 핵심 고려 사항들을 포함한다
            - 알고리즘 선택 > 로드 밸런싱 알고리즘(라운드 로빈, 최소 커넥션, IP 해시 등)을 구현해 로드 밸런서가 여러 서버에 트래픽을 분산시키는 방법을 지정해야 한다
            - 헬스 체크 > 정기적인 헬스 체크를 수행해 서버들이 작동하고 있음을 보장해야 한다. 어떤 서버가 헬스 체크에 실패하면 헬스 체크에 성공할 때까지 해당 서버는 풀에서 제거되어야 한다
            - 자동 스케일링 > 로드 밸런서는 이상적으로 자동 스케일링 시스템을 사용해 매끄럽게 작동해야하며 현재 요청에 기반해 리소스를 추가하거나 제거함으로써
                             아키텍처가 효율적으로 확장/축소됨을 보장해야 한다 

            >>> 개발 목적으로 AWS, 구글 클라우드, 애저 같은 클라우드 서비스를 사용하면 로드 밸런서 구현 및
                그와 관련한 기능들에 관한 개념과 프랙틱스들은 이 플랫폼들이 제공하는 도구와 서비스를 통해 단순화되고 개선된다
                이런 클라우드 서비스들은 기본 기능을 관리형 헬스 체크, 통합 스케일링, 보안, 자동화 배포 등을 지원한다

    - 캐싱
        : 캐싱은 빈번하게 접근되는 데이터를 항상 접근할 수 있는 스토리지 위치(캐시라 알려짐)에 일시적으로 저장해 데이터 가져오기 속도를 높이는 프로세스이다
        : 이 캐시는 주간 저장소로써의 역할을 하며 사용자 혹은 애플리케이션이 원래 저장소(주로 데이터베이스 또는 백엔드 서버) 위치에 접근할 때보다 빠르게 데이터에 접근할 수 있게 한다
        : 캐싱은 몇 가지 영역에서 구현될 수 있다
            - 브라우저 캐싱 > 사용자가 방문했을 때 웹사이트 리소스를 사용자의 로컬 컴퓨터에 저장함으로써 이후 방문했을 때의 로딩 타임을 줄인다
            - CDN 캐싱 > 지역적으로 분산되어 있는 서버를 활용해 콘텐츠의 빠른 전달을 제공한다
            - 애플리케이션/데이터 캐싱 > 일반적으로 질의되는 데이터를 Redis, Memcached 같은 인메모리 캐시에 저장한다. 
                                       이를 사용하면 빈번하게 접근되는 특정 애플리케이션 데이터에 빠르게 접근할 수 있으며 데이터베이스와 백엔드 시스템의 부하를 덜 수 있다
            
            > 캐싱은 확장 가능한 아키텍처의 핵심적인 부분일 수 있다. 캐싱은 훨씬 빠르게 접근할 수 있는 특정한 캐싱된 콘텐츠를 제공함으로써
              백엔드 시스템과 데이터베이스에 걸리는 부하를 상당히 줄이기 때문이다
            
            > 이는 결과적으로 최종 사용자에 대한 보다 빠른 응답 시간으로 이어지고 각 요청을 처리하기 위해 필요한 프로세싱 파워를 줄인다 (이는 트래픽이 몰릴 때 대단히 중요하다)

            > 언제 어떻게 콘텐츠가 캐싱되는지에 관한 전략은 목표에 따라 다양하게 사용할 수 있다.
              예를 들면 이미지, CSS 자바스크립트 같이 자주 변경되지 않는 정적 콘텐츠는 오랜 시간동안 캐시될 수 있지만, 
              동적 콘텐츠는 그 콘텐츠가 변경되는 빈도와 캐시가 업데이트되기 이전까지 견딜 수 있는 지연에 따라 보다 복잡한 전략이 필요할 것이다

            > 클라우드 서비스 관점에서 다양한 공급자들이 관리형 캐싱 서비스를 제공한다(Amazon ElasticCache, Azure Cache, 구글 클라우드 Memorystore 등)
              이 서비스들은 Redis 혹은 Memcached를 사용해 설정된 캐시의 분산, 확장, 관리를 담당한다

    - 콘텐츠 전달 네트워크
        : 콘텐츠 전달 네트워크(CDN)는 전 세계의 여러 위치에 전략적으로 배치된 서버의 네트워크이며 사용자에게 가장 가까운 서버에서
          정적 콘텐츠(HTML 페이지, 이미지, 자바스크립트, CSS 파일 등)를 제공하는 목적으로 설계되었다                 

        : CDN은 확장 가능한 웹 아키텍처에서 매우 중요한 역할을 한다. CDN은 지리적으로 사용자에게 가까운 위치로 콘텐츠를 가져다주기 때문에
          지연을 줄이고 콘텐츠 전달 속도를 높인다          

        : 클라우드 공급자들은 대개 통합된 CDN 서비스를 제공하므로 그들의 웹 아키텍처의 일부로 CDN을 쉽게 배포할 수 있다
          예를 들면 AWS는 Amazon CloudFront, 마이크로소프트 애저는 Azure CDN, 구글 클라우드는 Cloud CDN을 제공한다
          이 서비스들은 사용자가 위치한 곳에 가까운 '에지 로케이션'에 콘텐츠를 캐싱하는 방식으로 작동한다

    - 수평적 확장
        : 정확한 사용자 수를 예측하고 확장을 위해 필요한 인프라스트럭처를 결정하는 것은 상당히 어렵다. 이를 위해 조직들은 대개 수평적 확장과 수직적 확장을 조합한다
        : 수평적 확장은 스케일 아웃이라고도 부르며, 애플리케이션 클라우드 아키텍처에 보다 많은 장비를 추가하는 것, 예를 들면 클러스터 서버를 추가하거나
          클라우드 환경에 새로운 인스턴스를 추가하는 것을 포함한다
        : 해당 방법은 유연성과 탄력성을 제공하기 때문에 웹 기반 아키텍처에서 선호한다. 요청이 늘어나면 새로운 서버를 풀에 추가함으로써 워크로드를 분산한다
          서버가 실패하면 다른 서버가 워크로드를 받으며 높은 가용성을 제공한다
        
        : 수평적 스케일링은 주로 다음 상황에 적합하다
            - 단일 실패 포인트로 인한 다운 타임을 피하고 싶다
            - 애플리케이션을 빈번하게 업그레이드 해야 한다
            - 벤더 락인을 피하고 여러 서비스를 탐색하고 싶다
            - 여러 서비스를 사용함으로써 시스템 탄력성을 개선하고 싶다

    - 수직적 확장
        : 수직적 확장은 스케일 업이라고도 부르며 한 단위의 리소스를 최대화해서 증가하는 부하를 처리하는 것, 예를 들면 서버를 실행하는 물리 머신에
          프로세싱 파워나 메모리를 추가하거나 소프트웨어 관점에서 알고리즘이나 애플리케이션 코드를 최적화하는 것을 포함한다

        : 수직적 확장은 새로운 서버를 설정하기 위한 복잡성이 요구되지 않기 때문에 일반적으로 수평적 확장보다 쉽고 빠르다
        : 하지만 한 대의 서버를 물리적으로 업그레이드하는 데는 한계가 있으며, 업그레이드한 서버에서도 다운타임은 발생할 수 있다

        : 수직적 확장은 주로 다음 상황에 적합하다
            - 운용 비용을 줄인 단순한 아키텍처가 필요하다
            - 낮은 전력을 소비하면서 확장할 수 있는 시스템이 필요하다
            - 낮은 라이선싱 비용으로 쉽게 설치 및 확장할 수 있는 시스템이 필요하다
            - 애플리케이션 호환성을 유지하고 싶다

        > 모던 클라우드 서비스들은 수평적 확장과 수직적 확장 전략을 단순화할 수 있는 해결책들을 제공한다
          해당 서비스들은 자동 스케일링을 지원하는데, 서버 부하에 따라 컴퓨팅 리소스의 수를 자동으로 조정함으로써 동적으로 수평적 확장을 하게 해준다
          마찬가지로 크기 조정이 가능한 인스턴스를 제공함으로 수직적 확장을 용이하게 한다

    - 마이크로서비스
        : 마이크로서비스는 애플리케이션을 작고, 독립적으로 배포할 수 있는 서비스로 분배하는 아키텍처적 접근법이다
          분해된 서비스는 독립적으로 확장 및 관리할 수 있다
        : 각 서비스들은 고유의 프로세스를 실행하며 경량 메커니즘(주로 HTTP 리소스 API 또는 RPC 호출 등)을 사용해 서로 소통한다

        : 마이크로서비스 아키텍처는 모놀리식 아키텍처와 대비된다. 모놀리식 아키텍처에서는 애플리케이션의 모든 컴포넌트가
          강하게 통합되어 있기 때문에 함께 확장되어야 하는데 이는 번거롭고 비효율적이다 
        : 마이크로서비스는 각 서비스를 독립적으로 확장할 수 있게 함으로써 확장성을 가능하게 한다.
          애플리케이션의 어떤 부분에 많은 요청이 걸리면 관련된 서비스만 스케일 업하면 된다
          (이는 애플리케이션 전체를 확장하는 것보다 비용 대비 효과가 뛰어나고 덜 복잡하다)

        : 마이크로서비스는 그 장점과 함께 서비스 통합과 관리라는 관점에서는 복잡성을 가져다 준다
          또한 서비스 디스커버리, 로드 밸런싱, 실패 시 복구를 위한 강건한 인프라스트럭처를 요구할 수 있다
        : 쿠버네티스, 도커 같은 도구 및 클라우드 기반 서비스들은 오케스트레이션, 컨테이너화, 서비스 디스커버리 같은 기능을 제공함으로써 이 복잡성을 관리한다


    - 확장 가능한 애플리케이션의 특성
        : 실제 확장 가능한 시스템은 확장 가능한 웹 아키텍처를 촉진하는 여러 컴포넌트(및 다른 요소)들을 응집적이고 효율적으로 통합해
          성능 저하나 비용 초과 없이 증가하는 요청에 반응할 수 있음을 보장한다. 정리하면, 확장 가능한 애플리케이션은 다음 영역에서 뛰어나야 한다
            - 성능 
                : 애플리케이션은 부하 상황에서도 낮은 지연으로 작동해야 한다. 웹사이트의 속도는 사용성, 사용자 만족, 검색 엔진 순위,
                  그리고 무엇보다 궁극적으로 수익과 사용자 유지에 영향을 준다
            
            - 가용성과 신뢰성
                : 확장 가능한 애플리케이션은 부하 상화엥 빠져서는 안 되며 요청에 대해 신뢰할 수 있도록 생산하고 저장해야 한다

            - 관리 가능성
                : 확장 가능한 클라우드 아키텍처는 쉽게 문제를 진단하고 이해할 수 있고, 업데이트와 수정을 할 수 있고,
                  실패나 예외를 발생시키지 않고 시스템을 운영할 수 있어야 한다

            - 비용
                : 확장 가능한 애플리케이션의 구축, 유지 및 확장 비용이 너무 높아서는 안 된다. 개발을 진행하는 동안 확장성에 관한 계획을 세움으로써
                  애플리케이션이 과도한 비용을 야기하지 않으면서 요청 증대에 맞춰 확장되게 할 수 있다  

        : 전형적인 확장 가능한 웹 애플리케이션 아키텍처는 4개의 기본 계층(웹서버, 데이터베이스 서버, 로드 밸런서, 공유 파일 서버)으로 구성된다
        : 각 계층은 독립적으로 확장될 수 있으며 데이터베이스 계층은 확장하기 가장 어려운 계층이다

        : 효율적인 데이터베이스 확장을 위한 접근법은 마스터-슬레이브 복제를 사용하는 것이다. 마스터 노드는 데이터를 읽고 쓸 수 있으며,
          슬레이브 노드는 데이터를 읽을 수만 있다. 로드 밸런서는 마스터 노드들에 부하를 분산하여 최적의 성능을 보장한다

        : 또 다른 모법 사례들에는 데이터베이스 최적화와 비동기 처리를 포함한다. 인덱싱, 쿼리 최적화, 데이터베이스 샤딩 또는 파티셔닝 도입을 통한
          데이터베이스 성능 최적화는 여러 서버 사이에 데이터를 분산해 성능과 확장을 개선한다
        : 비동기와 메시지 쿼리를 사용해 백그라운드에서 시간이 소요되는 태스크를 처리해 병목을 예방하고 애플리케이션 성능을 개선할 수 있다

    - 쿠버네티스와 도커는 어디에 적합한가?
        : 해당 플랫폼들은 주로 컨테이너화와 오케스트레이션을 촉진함으로써 확장 가능한 웹 아키텍처를 만들고 관리하는 데 핵심적인 역할을 한다
            - 도커
                : 도커는 오픈소스 플랫폼으로 컨테이너 안에서 애플리케이션의 생성, 배포, 실행 프로세스를 단순화한다
                    * 도커를 사용해 컨테이너화한 애플리케이션의 다이어그램
                           App A ~ F
                             도커
                        호스트 운영체제
                         인프라스트럭처                                                                             

                : 컨테이너는 애플리케이션과 그 의존성을 함께 패키징하며, 이를 통해 모든 환경에서 이들이 일관성 있게 실행됨을 보장한다
                : 해당 접근법은 애플리케이션의 이식성, 효율성, 관리 가용성을 개선하며 쉽게 복잡한 웹 애플리케이션을 구축하고 확장하도록 돕는다
                : 도커가 제공하는 이점은 다음과 같은 이점을 제공한다
                    - 이식성
                        : 도커 컨테이너는 다양한 환경에서 일관성 있게 실행할 수 있으므로 "제 머신에서는 작동하는데요?" 문제를 줄인다
                    - 격리
                        : 컨테이너는 애플리케이션과 그 의존성을 캡슐화하고 충돌을 최소화하고 보안을 개선한다
                    - 리소스 효율
                        : 컨테이너는 호스트 운영체제의 커널을 공유하고 가상 머신보다 더 적은 리소스를 소비함으로써 보다 나은 리소스 활용을 가능하게 한다
                    - 버전 관리 및 컴포넌트 재사용
                        : 도커 이미지는 버전 관리와 공유를 쉽게 할 수 있으므로 코드 재사용과 단순한 애플리케이션 관리를 가능하게 한다
                    - 생태계와 커뮤니티
                        : 도커는 수많은 도구와 통합을 제공하는 생태계와 함께 대규모의 활동적인 커뮤니티를 갖고 있다

                : 도커 사용과 관련된 몇 가지 어려움도 있다
                    - 학습 곡선
                        : 도커를 사용하기 위해서는 새로운 개념과 명령어를 학습해야 하며 일부 개발자들은 다소 어려움을 느낄 수도 있다
                    - 제한된 윈도우 지원
                        : 도커는 윈도우 컨테이너를 지원하기는 하지만 리눅스 컨테이너에 비해 그 기능 셋이 충실하지 않다 
                    - 보안 우려
                        : 루트 권한으로 컨테이너를 실행하거나 오래된 이미지를 사용하면 애플리케이션이 보안 리스크에 노출될 수 있다         

            - 쿠버네티스
                : 쿠버네티스는 오픈소스 컨테이너 오케스트레이션 플랫폼이며 컨테이너화한 애플리케이션의 배포, 확장, 관리를 자동화한다.
                : 쿠버네티스는 도커 및 다른 컨테이너화 기술들과 함께 작동하도록 설계되었다
                : 쿠버네티스는 다음을 촉진함으로써 확장 가능한 웹 아키텍처를 향상할 수 있다
                    - 확장성
                        : 쿠버네티스는 컨테이너화한 애플리케이션 관리와 확장을 단순화함으로써 증가된 요청을 쉽게 처리할 수 있다
                    - 높은 가용성
                        : 쿠버네티스는 실패한 컨테이너를 자동으로 찾아내고 대체할 수 있으며 높은 가동 시간과 탄력성을 보장한다
                    - 로드 밸런싱과 서비스 디스커버리
                        : 쿠버네티스는 컨테이너화한 애플리케이션에 대한 내장 로드 밸런싱 및 서비스 디스커버리 기능을 제공한다
                    - 롤링 업데이트와 롤백
                        : 쿠버네티스는 최소한의 다운타임으로 매끄러운 애플리케이션 업데이트와 롤백을 지원한다
                    - 확장성
                        : 쿠버네티스는 커스텀 리소스와 서드파티 플러그인을 사용해 특정한 니즈에 적합하게 확장할 수 있다

                : 쿠버네티스는 다음과 같은 잠재적인 단점을 갖고 있다
                    - 복잡성
                        : 쿠버네티스는 학습 곡선이 가파르다. 특히 컨테이너화의 개념에 익숙하지 않은 이들에게는 설정과 구성이 매우 복잡할 수 있다
                    - 리소스 오버헤드
                        : 쿠버네티스 클러스터는 컨트롤 플레인 컴포넌트를 위한 추가 리소스를 요구한다. 이는 인프라스트럭처 비용 증가로 이어질 수 있다
                    - 상태를 갖는 애플리케이션에 대한 지원 제한 
                        : 쿠버네티스도 StatefulSets를 통해 상태를 갖는 애플리케이션에 대한 지원을 개선했지만, 상태를 갖지 않는 애플리케이션에 비해 여전히 관리하기 어렵다
                
                >>> 요약하면 도커와 쿠버네티스는 확장성 있는 웹 아키텍처 구현과 관련해 많은 이점을 제공한다
                    그러나 동시에 몇 가지 복잡성과 잠재적인 단점도 갖고 있다. 개발자와 팀은 그들이 가진 구체적인 니즈와 요구사항을 세심하게 고려한 뒤 이 기술들의 도입 여부를 결정해야 한다

    - Vercel과 Netlify 같은 기술은 어디에 적합한가?
        : Vercel과 Netlify는 AWS와 GCP 위에 구축된 플랫폼으로, 프론트엔드 웹 애플리케이션을 위한 호스팅 및 배포 솔루션 제공에 특화되어 있으며 확장 가능한 웹 아키텍처에 적합하다                                 
        : 이들을 사용하면 특히 정적 사이트와 서버리스 기능에 대한 배포 및 확장 프로세스를 상당히 단순화할 수 있다
        : Vercel, Netlify 같은 도구들은 다양한 방법을 통해 확장 가능한 웹 아키텍처를 구축하고 유지하는 데 기여한다
            - 단순화된 배포
                : Vercel과 Netlify는 배포 프로세스를 단순화함으로써 개발자들은 쉽게 코드를 깃 저장소에 푸시해 애플리케이션을 자동으로 구현하고 배포할 수 있다
            - 서버리스 기능
                : 두 플랫폼 모두 서버리스 기능을 지원하므로 개발자들은 내부 인프라스트럭처를 관리하지 않고도 백엔드 코드를 작성할 수 있다
                  서버리스 기능은 요청 수에 따라 자동으로 확장되며, 백엔드 태스크 처리를 위한 확장 가능한 해결책을 제공한다
            - 글로벌 CDN
                : Vercel과 Netlify는 애플리케이션을 글로벌 CDN에 걸쳐 분산시키기 때문에 전 세계 사용자에게 빠른 로딩 시간과 더 나은 성능을 보장한다
                  또한 부하를 분산함으로써 호스팅하는 애플리케이션의 확장성을 개선한다 
            - 자동 스케일링
                : 두 플랫폼 모두 요청에 따라 자동으로 애플리케이션을 확장하므로 애플리케이션은 수동 조작을 하지 않아도 증가된 트래픽을 처리할 수 있다
            - 지속적 통합 및 지속적 배포
                : Vercel과 Netlify는 내장된 지속적 통합과 지속적 배포(CI/CD) 파이프라인을 제공하며, 개발자들은 이를 활용해 손쉽게 애플리케이션에 업데이트를 푸시할 수 있다
            - 커스텀 도메인과 HTTPS
                : 두 플랫폼 모두 커스텀 도메인 구성과 자동 HTTP 인증 관리를 제공하므로 애플리케이션 보안 설정 프로세스를 단순화할 수 있다

        : Vercel과 Netlify는 위와 같은 기능을 제공하므로 개발자들은 애플리케이션을 보다 효율적으로 실행하고 확장할 수 있다
          기반이 되는 AWS 또는 GCP 인프라스트럭처는 매우 강건하고 신뢰할 수 있고, Vercel과 Netlify는 이들 클라우드 서비스와의 상호작용을 쉽게 만들어주는 개발자 친화적인 계층을 제공한다                                              
          따라서 프론트엔드 애플리케이션, 정적 사이트, 서버리스 기능에 매우 적합하다

        : Vercel과 Netlify가 제공하는 여러 장점에도 불구하고 때로는 애플리케이션이 매우 복잡해 기반 인프라스트럭처를 더 많이 제어해야 할 때도 있다 
        : 이런 경우에는 도커와 쿠버네티스 같은 컨테이너화 및 오케스트레이션 플랫폼을 AWS, 구글 클라우드, 마이크로소프트 애저 같은 클라우드 공급자와 함께 사용하는 것이 더욱 적합할 수 있다

        >>> 확장성은 사용자 기반이 늘어나고 트래픽이 증가하더라도 웹 애플리케이션이 계속해서 중단 없이 효율적으로 작동함을 보장한다
            한편, 자동화 테스팅, 지속적 통합, 지속적 배포 같은 다른 중요한 측면들도 애플리케이션이 확장할 때 건강과 성능을 유지하게 하기 위해 고려해야 한다
            해당 주제에 관해 보다 자세히 알고 싶으면 아래 아티클을 참고해보자
                - 구글 클라우드의 '확장 가능하고 복원력이 우수한 앱 패턴'
                - 심폼(Simform)의 'How to Build a Scalable Application up to 1 Million Users on AWS'  