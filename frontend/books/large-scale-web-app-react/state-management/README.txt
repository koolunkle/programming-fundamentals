[상태 관리]
리액트 및 다른 모던 자바스크립트 애플리케이션에서 컴포넌트는 레고 블록에 해당한다
이들은 재사용 가능한 코드 단위이며 구조를 캡슐화한 UI(HTML), 동작(자바스크립트) 및 때로는 스타일(CSS)의 렌더링을 담당한다

컴포넌트는 자신들의 상태를 관리하기 위한 내부 매커니즘을 갖고 있다
상태는 컴포넌트의 라이프사이클에 걸쳐 변하는 모든 데이터를 나타내며, 컴포넌트의 렌더링 혹은 행동에 영향을 미친다
이러한 '로컬 상태'라는 개념으로 인해 컴포넌트는 반응적일 수 있다 (상태 변화에 대한 응답으로 그 표현과 행동을 조정한다)

리액트에서는 useState 훅을 사용해 이를 구현한다. useState 훅은 함수형 컴포넌트가 로컬 상태를 유지 및 업데이트할 수 있게 한다
컴포넌트의 로컬 상태가 변경되면 리액트는 이 상태를 모니터하고, 이 변경에 의한 영향을 받는 컴포넌트의 부분들은 재렌더링되어 해당 변경을 반영한다

[컴포넌트 간 데이터 관리하기]
컴포넌트는 고립되어 존재하지 않는다. 컴포넌트들은 관련되어 있으며, 이는 데이터가 흐르는 방법을 지정한다
전형적으로 데이터는 부모 컴포넌트에서 자식 컴포넌트로 전달되는데, 이는 하향식 또는 일방통행 흐름이라 부르며 props를 사용해 만들 수 있다

props는 부모에서 그 자식 컴포넌트로 데이터를 전달하기 위해 사용하는 특수한 매개변수이다
props는 컴포넌트들이 소통할 수 있는 방법을 제공하며, 이는 자식이 그 부모로부터 데이터를 받아 표시될 수 있음을 보장한다

props를 사용하면 부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달할 수 있는 한편, 반대로 자식 컴포넌트에서 부모 쪽으로 소통을 해야 하는 상황도 존재한다
일반적으로 자식 컴포넌트 안에서 발생한 동작이나 이벤트가 발생했다는 신호를 부모 컴포넌트가 알아야 하는 경우이다

리액트에서는 이런 상향 소통을 일반적으로 콜백 함수를 사용해 달성한다
부모는 props를 경유해 자식에게 하나의 함수를 내려보낸다. 자식은 이 함수를 호출해 부모에게 거꾸로 소통한다

자식 컴포넌트가 자신 안에서 어떤 액션이 발생했다는 신호를 부모에게 보낼 수 있으므로, 
자식 컴포넌트와 부모 컴포넌트 사이에 명확하고 효과적인 소통을 할 수 있다
    - 부모 컴포넌트 > 자식 컴포넌트: props 전달
    - 부모 컴포넌트 < 자식 컴포넌트: 이벤트(콜백함수) 트리거

[prop 내려보내기]
컴포넌트 트리에 수많은 컴포넌트를 갖는 대규모 애플리케이션에서 작업할 때, props는 종종 유지하기 어려울 수 있다
컴포넌트 트리의 모든 각각의 컴포넌트에 props를 선언해야 하기 때문이다 (심지어 중간 컴포넌트는 그 데이터를 사용조차 하지 않는다)

최상위 부모 컴포넌트가 어떤 상태를 갖고 있고, 깊이 중첩되어 있는 한 자식 컴포넌트가 그 상태를 사용하려 한다고 가정하면,
해당 자식에게 상태를 직접 전달하는 대신, 그 원하는 자식 컴포넌트에게 전달될 때까지 그 상태를 한 단계씩 '내려보내야(drill down)' 한다


prop 내려보내기는 기능적이지만 대규모 리액트 애플리케이션에서는 다양한 문제를 야기할 수 있다
해당 접근법은 코드베이스의 유지보수성을 저하시키는데, 데이터 구조에 무언가 수정이 있다면 모든 중간 컴포넌트를 그에 맞춰 변경해야 하기 때문이다
이는 컴포넌트들에게 불필요한 props를 전달하게 만들며, 가독성을 줄이고 개발자들이 데이터 흐름을 추적하기 어렵게 만든다

리액트의 컨텍스트 API는 이 이슈의 해결책을 제안한다. 컨텍스트 API는 컴포넌트 트리의 모든 레벨에 명시적으로
prop을 전달할 필요 없이 컴포넌트 사이에서 값을 공유하는 방법을 제공한다

컨텍스트 객체를 만들고 컨텍스트 공급자를 사용해서 중첩된 모든 컴포넌트 사이에서 해당 데이터를 사용 가능하게 만들 수 있다
중첩된 컴포넌트들은 useContext 훅을 사용해서 해당 데이터에 직접 접근할 수 있다

* 리액트 버전 19에서 새롭게 도입된 'use'가 이제 컨텍스트 데이터 접근을 위한 권장 접근법이 되었으며 useContext 훅을 대체하게 되었다

해당 패턴은 수많은 컴포넌트 애플리케이션 수준의 클라이언트 데이터에 가장 적합하다
해당 데이터로는 테마 정보, 로케일/언어 설정, 사용자 인증 세부 사항 등을 들 수 있다
이런 유형의 데이터들은 Context를 사용해서 가장 잘 관리할 수 있는데, 애플리케이션 안의 모든 컴포넌트들은 언제든 이 데이터들에 접근을 요청할 수 있기 때문이다

[단순한 상태 관리]
리액트에서 컨텍스트 API는 특정한 시나리오에서 뛰어나지만, 대규모 애플리케이션을 가로지르는 모든 글로벌 혹은 공유된 상태에 최적인 것은 아니다
컨텍스트 메커니즘을 사용하면 prop 내려보내기를 피할 수 있고, 깊은 컴포넌트 트리 안에서 값을 공유할 수 있지만
글로벌 상태 관리의 경우 상태 변경이 예측할 수 있는 방식으로 발생한다면 종종 보다 세련된 해결책이 필요할 수 있다

    - useReducer 훅
        : useReducer 훅을 사용해서 컴포넌트의 보다 복잡한 상태 로직을 관리할 수 있다
        : useReducer의 동작은 리덕스에서 리듀서가 작동하는 방법과 유사하지만, 리듀서와 달리 컴포넌트 안에 포함되거나 Context를 사용해 공유될 수 있다는 점이 차이
        : 상태 업데이트는 설명적인 액션 유형을 갖게 되고, 이를 활용하면 어디에서 어떻게 상태 변경이 발생하는지 쉽게 추적할 수 있다
        > UI 컴포넌트로부터 상태가 업데이트되는 로직을 분리하는데 유용하며, 데이터 흐름의 관리를 명확하고 보다 예측 가능하게 만든다
        > 리액트 상태 관리 모범 사례를 촉진, 현재 상태를 직접 수정하는 것보다 새로운 상태 객체를 반환함으로써 상태 불변성을 보장할 수 있다
        > 복잡한 컴포넌트 혹은 애플리케이션에서의 테스트, 디버그, 상태 변경에 관한 이해 등을 촉진한다

[상태 관리 전용 라이브러리]
애플리케이션의 복잡도가 증가하면 개발자들은 단순한 상태 관리 해결책(useReducer 등)이 충분하지 않을 수 있다고 판단하게 될 수 있다
대규모 애플리케이션에서의 필요는 종종 보다 강력하고 다재 다능한 상태 관리 도구가 필요한 상황을 만든다
이런 상황에서 바로 전용 상태 관리 라이브러리들을 사용할 수 있다

    - 리덕스
        : 리덕스는 보다 복잡한 상태 관리를 해야 할 때 일반적으로 사용하는 라이브러리이다
        : 리덕스를 사용하면 dispatched 액션을 통해 전역적으로 상태 접근 및 변경을 할 수 있다
        : 리덕스에는 두 가지 중요한 개념이 존재하는데 다음과 같다
            - 센트럴 스토어
                : 리덕스는 전체 애플리케이션의 상태를 하나의 자바스크립트 객체에 유지하며, 이를 스토어라 부른다
                : 이 중앙 집중화된 스토어는 애플리케이션 상태에 관한 하나의 진실을 갖는 소스임을 보장한다
            - 불변 상태
                : 리덕스에서는 절대로 상태가 직접 수정되지 않는다. 모든 변경은 액션으로 기술되며, 리듀서라 불리는 순수 함수가 상태 업데이트를 처리한다
        
        : 리덕스 설정은 보통 '리덕스 툴킷'을 사용한다. 이는 공통된 리덕스 태스크를 위한 유틸리티 함수를 제공해 개발을 단순화한다
        : 리덕스 툴킷을 사용하려면 먼저 패키지를 설치하고 리액트, 리덕스를 바인딩해 리액트에서 리덕스를 사용할 수 있게 해야 한다
            설치: yarn add @reduxjs/toolkit react-redux                 
        
        : 리덕스 툴킷을 사용하면 '슬라이스'들을 활성화해 센트럴 스토어가 간단한 방식으로 액션과 리듀서를 다룰 수 있게 해야 한다
        : store.js 파일에서 리덕스 툴킷이 제공하는 createSlice 함수를 사용해 스토어 안의 메시지 데이터 속성이 리듀서 안에서(changeMessage) 업데이트될 수 있는 방법을 처리한다
        : 또한 같은 파일에서 리덕스 툴킷이 제공하는 configureStore 함수를 임포트 및 사용해 리덕스 스토어를 생성한다             
        : 리액트 애플리케이션 안의 모든 컴포넌트들이 리덕스 스토어를 사용할 수 있게 하려면 리액트/리덕스 애플리케이션의 Provider 컴포넌트로
          애플리케이션의 root 컴포넌트를 감싸고, 리덕스 스토어 안에서 Provider에 관한 prop으로 이를 전달해야 한다
        : Provider 컴포넌트로 인해 리액트 컴포넌트는 리덕스 스토어를 활용해 공유된 상태를 관리할 수 있으며
          리덕스 툴킷 패키지에서 useSelector 훅을 사용해 상태 값에 접근하고 useDispatch 훅을 사용해 동작을 가져올 수 있다  

        : 모든 데이터는 리덕스에서 관리하며, 이는 상태 변화를 예측할 수 있고 쉽게 관리할 수 있음을 보장한다
        : 리덕스 애플리케이션의 전형적인 흐름은 다음과 같다
            - 액션을 가져온다. 이는 주로 버튼 클릭하기 같은 사용자 상호작용의 결과이다
            - 리덕스 스토어의 리듀서가 이 액션을 처리하고 새로운 상태를 생성한다
            - 리덕스 스토어에 연결된 컴포넌트들(App.js 등)은 새로운 상태를 사용해 재렌더링된다
            - 리덕스 아키텍처: View > Dispatcher > Action > Reducer > State > ... 

        : 리덕스는 애플리케이션 상태를 관리하는 방법에 관한 많은 보일러플레이트를 추가한다
        : 하지만 이는 복잡한 상태 상호작용을 처리하기 위한 보다 구조적이고 예측 가능한 접근법을 제공하기 위해서이다
        : 애플리케이션 규모에서 이를 보장하므로 개발자들은 상태 변경에 관한 명확함과 통제를 유지할 수 있다
        
        : 리덕스는 플러그인, 미들웨어, 유틸리티와 같은 광범위한 생태계에 더해 강력한 Devtools 확장도 제공한다
        : 이를 활용하면 시간을 오가는 디버깅, 액션 조사, 디버깅 지원을 위한 상태 트리 가시화를 할 수 있다
        : Devtools는 단독 애플리케이션으로 사용되거나 클라이언트 애플리케이션에 통합된 하나의 리액트 컴포넌트로 사용될 수 있다
        : 일반적으로는 브라우저 확장 기능으로 가장 많이 설치 및 사용되는 편이다 (크롬 등)

        : 개발자들이 사용할 수 있는 상태 관리 라이브러리는 리덕스 외에도 MobX와 Zustand 등 다양하다
        : 각 라이브러리는 고유한 기능과 접근법을 갖는다. 차이가 존재하기는 하지만 이 라이브러리들은 애플리케이션 상태를 중앙 집중화하고
          해당 상태의 업데이트 및 접근을 위한 구조적인 메커니즘을 적용한다는 주요한 목표에 대해서는 많은 유사성을 공유한다

[마지막 고려 사항] 
리덕스는 비동기 서버 사이드 로직을 지원하기 위해 필요한 미들웨어로 인한 레거시 코드를 유지하기 위해 골머리를 썩게 하기도 한다
최근에는 Next.js 같은 강력한 서버 사이드 렌더링 프레임워크 덕분에 서버 사이드 상태 관리가 단순해졌기 때문에
복잡한 클라이언트 사이드 상태 관리는 거의 필요하지 않다.

클라이언트 사이드와 서버 사이드 상태 사이의 명확한 선을 그음으로써 리덕스 대신 리액트의 내장 리듀서와 컨텍스트 공급자를 사용하는 사례도 있다
어떤 것이 최고의 접근법이라고 결정할 수는 없다. 보편적인 해답은 없지만 다음 체크리스트를 활용하면 무엇이 최고(최선)인지 찾아내는데 도움이 될 수 있다

 - 데이터 가져오기부터 고려하라
    : 상태 관리에 뛰어들기 전에 여러분의 클라이언트 애플리케이션이 활용할 데이터 가져오기 방법을 결정하자
    : SWR, 리액트 쿼리, Apollo 같은 모던 데이터 가져오기 라이브러리들은 내장 캐싱 메커니즘을 제공한다
    : 애플리케이션의 주요 고려 사항이 데이터 가져오기이며 라이브러리가 캐싱을 잘 관리한다면, 전용 상태 관리 라이브러리를 통합할 필요가 없을 수도 있다
    : 모던 데이터 가져오기 라이브러리들은 충분한 상태 관리 기능을 제공하는 경우가 많다.
      이 기능들은 서버 응답을 효율적으로 관리하고 캐싱해 서버 상태를 처리하고 추가적인 상태 관리 계층의 필요를 줄인다

- 보다 견고한 커스텀 상태 관리 해결책을 위한 필요성을 측정하라
    : 캐싱 메커니즘이 작동한다 하더라도 애플리케이션이 데이터 가져오기를 넘어 전역 상태를 필요로 하는 지를 고민할 수 있다
    : 복잡한 워크 플로우, 중간 레벨 계산, 혹은 세션 사이에서 지속되어야 하는 애플리케이션 상태를 필요로 할 수 있다 (이때 리덕스 같은 해결책이 도움이 될 수 있다)

- 단순한 상태 관리 도구의 장점을 평가하라
    : 애플리케이션에 보다 강건한 상태 관리 라이브러리 보일러플레이트가 필요하지 않다면 경량의 해결책을 고려할 수 있다
    : 리액트의 컨텍스트 API의 useReducer를 함께 사용하면 직관적이고 효과적인 상태 관리 메커니즘을 제공할 수 있다

- 컴포넌트의 상태는 컴포넌트 수준에서 유지하라
    : 모든 상태를 전역으로 관리해야 하는 것은 아니다. 컴포넌트에 국한된 상태(입력값, 토글 상태, 혹은 로컬 UI 애니메이션 등)는
      개별 컴포넌트 안에서 관리할 수 있고, props를 사용해서 밀접하게 관련된 컴포넌트들 사이에서 공유할 수 있다

>>> 올바른 상태 관리 해결책이 무엇인지는 애플리케이션에 존재하는 고유한 요구사항, 팀이 가진 전문성, 미래를 위한 확장성과 성능 고려 사항에 달려 있다               


