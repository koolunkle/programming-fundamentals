[새로운 훅과 API]
리액트의 훅과 API는 강건한 프레임워크를 제공하며, 이를 활용하면 함수형 컴포넌트 안에서 상태와 이펙트를 관리할 수 있다
오늘날 리액트는 새로운 기능들을 도입했으며, 이는 우리가 리액트 컴포넌트를 구현하는 방법을 변경하고 개선한다
어떤 기능들이 전통적으로 구현되었고, 새로운 훅과 API들이 우리가 구현하는 방법(더 효율적이고, 가독성이 높고, 유지보수 가능한 코드를 구현하는 방법)을
바꾸는지에 관해 살펴보자

    - 비동기 폼 제출
        : 오늘날 우리가 웹 애플리케이션을 사용하는 방식의 많은 부분은 사용자 인증, 데이터 제출, e-커머스 트랜잭션, 피드백 수집
        그리고 검색 쿼리 등 다양한 목적으로 폼을 사용하는 것을 포함한다
        : 그 결과 리액트 컴포넌트 개발은 매우 일반적으로 일종의 제출 폼을 만들고, 폼이 제출되었을 때 수행할 비동기 업데이트를 처리하는 과정을 포함한다
        : 이를 위해서는 로컬 상태 변경을 관리하고, 사용자 입력을 검증하고, 제출과 관련된 다양한 상태(로딩, 성공, 에러 상태 포함)을 처리하는 로직을 구현해야 한다

        : 간단한 컴포넌트의 전통적인 예시를 따라가보자. 이 컴포넌트는 하나의 폼을 전송하고 폼이 제출되었을 때 비동기 업데이트를 처리한다
        : submitForm() 함수는 폼 정보를 서버에 전송하고 응답을 반환한다고 가정한다. 이 컴포넌트는 formState, isPending이라는 두 상태 속성을 관리하며
          이를 통해 사용자들에게 폼 제출과 관련된 현재 상태를 전달하고, 해당 데이터가 처리되었는지, 제출이 성공적으로 완료되었는지
          혹은 에러가 발생했는지에 관한 피드백을 제공한다

        : 리액트는 최근 변경에 따라 전환에서 비동기 함수를 사용할 수 있으며, 여기에서 useTransition 훅을 활용해
          비동기로 데이터를 가져오는 동안 로딩 인디케이터나 플레이스홀더의 렌더링을 관리할 수 있다
        
        : useTransition 훅을 활용할 때는 시간이 걸릴 수 있는 상태 업데이트에 표시를 할 수 있다
          이 설정을 사용하면 직접 대기/로딩 상태 속성을 직접 만들고 관리하지 않아도 된다
          useTransition 훅이 전환 진행 여부를 나타내는 대기 플래그를 제공하기 때문이다

        : 리액트의 최근 개선과 함께 전환의 개념이 일어났다. 비동기 전환을 사용하는 함수는 이제 '액션'이라 불린다
          몇 가지 최적화된 훅을 사용해서 액션을 관리할 수 있는데, 먼저 useActionState 훅에 관해 살펴보자

    - useActionState 훅
        : useActionState 훅은 리액트에서 새롭게 선보이는 훅이며, 이를 사용하면 폼 액션의 결과에 기반해 상태를 업데이트할 수 있다
          이 훅은 3개의 매개변수를 받는데 내용은 다음과 같다
            - 하나의 액션 함수
                : 이 함수는 폼 액션이 트리거 되면 실행된다
            
            - 하나의 초기 상태 객체
                : 이 객체는 사용자 상호작용이 일어나기 이전의 시작 상태를 설정한다
            
            - (옵션) 하나의 영구 링크
                : 이 링크는 이 폼이 수정할 고유한 페이지 URL을 가리킨다

            - 그리고 3개의 값을 하나의 튜플로 반환한다
                : 1. 폼의 현재 상태
                : 2. 폼 액션을 트리거하는 하나의 함수
                : 3. 액션의 대기 여부를 나타내는 하나의 불리언 값

            - useActionState 훅에 첫 번째 인자로 제공되는 action 함수는 폼 제출 시 활성화 된다
              이 함수는 기대하는 폼 상태 전환 및 폼 제출 성공 혹은 에러로 인한 실패 여부를 결정한다
              이 함수는 2개의 매개변수(폼의 현재 상태, 액션이 시작될 때의 폼 데이터)를 받는다

            - 앞서 논의했던 폼 예시를 살펴보면, 여기에서는 대신 submitForm() 함수를 트리거하는 액션을 만들 수 있다
              submitForm() 함수는 이어서 API 호출을 트리거 해서 폼 데이터를 서버로 전송한다
              액션이 성공하면 하나의 폼 상태 객체를 반환한다. 이 상태 객체는 폼의 다음 상태를 나타낸다

            - 액션이 실패하면 에러 상태를 나타내는 폼 상태 객체를 반환한다.
              에러 상태는 에러 메시지 혹은 해당 이슈를 수정할 수 있는 사용자의 가이드를 나타낼 수 있다
            
            - useActionState 훅 설정을 사용하면 이후 폼 state, dispatch, isPending 값을 템플릿에서 사용할 수 있다

            - <form> 액션
                : <form> 태그는 이제 action prop을 가지며 폼이 제출되었을 때 트리거되는 액션 함수를 받을 수 있다
                : 'use-action-state-with-dispatch.jsx'는 dispatch 함수를 useActionState 훅에 전달하는 예시이다
                : 폼 템플릿의 임의 위치에서 state를 표시할 수 있고, 비동기 액션이 수행되고 있는 동안 사용자에게 전달한 isPending 값을 사용할 수 있다
            
                > 리액트의 이런 새로운 변경으로 인해 이제는 더 이상 폼 안에서의 비동기 전환을 다룰 때
                  상태, 에러, 순차적인 요청 대기를 수동으로 처리하지 않아도 된다. useActionState 훅을 사용해 이 값들에 직접 접근하기만 하면 된다
                
    - useFormStatus 훅
        : 우리는 전통적으로 컨텍스트 API를 사용해 부모 컴포넌트로부터 상태 또는 데이터를 깊게 중첩된 자식 컴포넌트로 전파했다
          이 방법은 여러 컴포넌트들이 props를 여러 수준에 수동으로 전달하지 않고 공유된 데이터에 접근해야 하는 상황에서 특히 유용하다

        : 하지만 리액트는 폼을 위해 새로운 useFormStatus 훅을 제공하기 시작했다. 이 훅은 중첩된 컴포넌트 안에서의 폼 제출로부터
          상태 정보에 접근할 수 있도록 특별히 디자인되었다. 이 훅은 컨텍스트 공급자와 비슷한 기능을 한다
        : 폼 안의 자식 컴포넌트가 제출 상태 데이터에 직접 접근할 수 있게 해준다

        : useFormStatus는 반드시 컴포넌트 안에서 호출되어야 한다.
          이 컴포넌트는 <form> 안에서 렌더링되고 그 부모 <form>으로부터의 상태 정보만 반환한다
        : 컨텍스트 API를 사용해 여전히 폼 상태 및 다른 데이터를 자식에게 아래로 전달할 수 있지만, useFormStatus를 사용하면
          직접 컨텍스트를 설정하지 않아도 되고 폼과 관련된 상태 관리를 직접적으로 간소화할 수 있다

    - 낙관적 업데이트
        : 낙관적 업데이트는 사용자 경험 향상 기법의 하나로, 비동기 조작과 UI 업데이트가 해당 조작의
          실제 성공을 확인하기 전에 이미 성공한 것으로 가정한다
        : 리액트의 새로운 훅인 useOptimistic 훅은 이 패턴을 촉진하며, 이를 사용하면 쉽게 낙관적 업데이트를 구현할 수 있다
        
        : 한 컴포넌트가 있다고 가정하자. 이 컴포넌트는 폼이 제출되면 비동기 호출을 한 뒤 상태 메시지를 업데이트한다
          (optimistic-update.jsx 참고)
        : 앞의 폼 예시에서, 제출을 누르는 순간 서버가 응답할 때까지 기다리지 않고 메시지 업데이트가 수락되었음을
          사용자에게 시각적으로 확인하고 싶다고 가정해보자. 이런 상황에서 바로 useOptimistic 훅을 사용할 수 있다
          이를 통해 미리 가정하고 있는 성공 시의 결과를 UI에 즉시 반영할 수 있다 (use-optimistic.jsx 참고)
        : 앞의 예시에서 사용자가 버튼을 클릭해 폼을 제출하면 submit() 함수가 트리거된다. API 요청을 시작해서 메시지를 업데이트하기 전에
          폼 데이터에서 얻은 새로운 message 값을 전달해 setOptimisticMessage() 함수를 호출한다
        : 이는 낙관적 변경을 반영해 UI를 즉시 업데이트해 사용자에게 즉각적인 피드백을 제공한다

        : 업데이트가 종료되거나 에러가 발생하면 리액트는 자동으로 템플릿에서 사용된 optimisticMessage를 message prop의 값으로 바꾼다

    - use API
        : 새로운 리액트 API인 use는 컨텍스트, 프로미스 같은 리소스로부터 값을 읽을 수 있는 다양한 방법을 제공한다
        : 리액트는 컨텍스트를 사용해 명시적으로 prop을 트리의 모든 계층에 전달하지 않고도 컨텍스트 사이에 값을 공유한다
        : 컨텍스트 API를 사용하는 많은 경우 컨텍스트 객체를 만들고 컨텍스트 공급자를 사용해 컴포넌트를 감싸서 중첩된
          모든 컴포넌트에서 이 데이터를 사용할 수 있게 하곤 했다
        
        : 리액트의 최근 변경을 통해 이제 <Context.Provider>를 사용하지 않고 <Context>를 직접 렌더링할 수 있게 됐다
        : 컨텍스트 값을 읽기 위해 더 이상 useContext 훅을 사용할 필요가 없으며, 단순히 해당 컨텍스트를 use()에 전달하기만 하면 된다
        
        : use() 함수는 컴포넌트 트리를 따라 올라가면서 가장 가까운 컨텍스트 공급자를 찾는다
          컨텍스트를 읽는 useContext 훅과 달리 use() 함수는 컴포넌트 안의 조건문이나 루프에서도 사용할 수 있다
        : use() 함수는 Suspense 및 에러 경계와 매끄럽게 통합되어 프로미스를 읽을 수 있다 

    - 리액트 컴파일러
        : 리액트 컴파일러는 리액트 팀이 만든 실험적인 컴파일러로, '최적화 프로세스를 자동화함으로써' 리액트 애플리케이션의 
          성능을 크게 개선하는 것을 목적으로 한다. 리액트 컴파일러의 도입은 패러다임의 이동을 의미한다
        : 성능 튜닝의 책임을 오롯이 개발자가 지는 게 아니라 프레임워크도 어느 정도는 진다는 것이다

        - 메모이제이션
            : 선언적 모델을 중심으로 사용자 인터페이스를 구축하는 리액트의 디자인은 UI 개발을 크게 변화시켰다
            : 컴포넌트 기반 아키텍처를 위한 DOM의 직접적인 조작을 추상화함으로써 개발자들은 UI를 일련의 명령적 업데이트가 아니라
              상태의 반영으로 생각할 수 있게 되었다. 이 모델은 개발자들의 멘탈 모델, 특히 애플리케이션의
              복잡성이 증가할 때의 멘탈 모델을 크게 단순화시켰다
            
            : 리액트 함수 컴포넌트인 TodoList 컴포넌트는 API로부터 todo 아이템의 리스트를 가져와서 표시하게 디자인되었다
            : 이 컴포넌트는 useState 훅을 활용해 todos의 상태를 관리하고, useEffect 훅을 사용해 컴포넌트가 처음 마운트되었을 때 가져오기 동작을 수행한다
            : 리액트의 재렌더링 기능은 컴포넌트의 UI가 항상 현재 상태를 반영하는 것을 보장한다

            : 리액트 애플리케이션이 확장되고 많은 데이터셋을 다루거나 무거운 계싼을 수행하게 됨에 따라, 컴포넌트의 기본 렌더링 동작은 때로 성능 병목이 되기도 한다
            : 리액트의 렌더링 모델은 상태가 변경될 때마다 컴포넌트 하위 트리 전체를 재렌더링한다. 이는 소규모 컴포넌트와 데이터셋에서는 효율적이지만
              보다 큰 데이터셋이나 복잡한 UI에서는 많은 비용을 초래할 수 있다

            : 최적화에 관해 더 깊이 살펴보기 전에 메모이제이션에 관해 이해해야 한다. 메모이제이션은 최적화 기법의 하나이다. 값비싼 함수 호출의 결과를 저장한 뒤
              동일한 입력이 발생했을 때 캐시해 둔 결과를 반환함으로써 컴퓨터 프로그램의 속도를 높인다
            : 리액트의 컨텍스트에서 메모이제이션을 사용하면 복잡한 함수나 컴포넌트의 입력이 변경되지 않았을 때 캐싱함으로써 불필요한 계산과 재렌더링을 줄일 수 있다
            : TodoList 컴포넌트 예시의 경우, 메모이제이션을 통해 여러 부분에서 이득을 얻을 수 있다

            : 예를 들면 useEffect의 데이터 가져오기 함수는 todo를 처음 가져온 뒤, 데이터를 다시 가져와야 할 특별한 이유(데이터 새로고침 등)가 없는 한
              재실행할 필요가 없다. 이 효과는 useEffect()의 빈 의존성 배열에 의해 본질적으로 '메모화'되어 컴포넌트가 마운트된 뒤 한 번만 실행되는 것이 보장된다

            : 아이템의 todo 리스트가 커짐에 따란 각 todo 아이템을 렌더링하는 것은 성능에 영향을 줄 수 있다.
              이는 리스트 아이템들이 보다 복잡한 렌더링 로직을 포함하는 경우에는 더욱 그렇다
            
            : 이런 상황에서는 memo() 함수를 사용해서 부모 TodoList 컴포넌트가 재렌더링될 때가 아닌 각 TodoItem 컴포넌트의 속성이 변경되었을 때만 재렌더링되도록 보장할 수 있다
            : 리액트의 memo 함수는 컴포넌트의 불필요한 재렌더링을 막기 위해 사용하는 한편, useMemo 훅을 사용하면 컴포넌트는 안의 모든 계산된 값을 메모화할 수 있다
            : useMemo는 메모화된 값을 반환하며 그 값의 의존성에 변경이 있을 때만 값을 재계산한다. 예를 들면 TodoList 컴포넌트에서 완료한 todo의 숫자를 표시하고 싶다고 가정해보자
            : 리스트가 늘어남에 따라 완료한 todo의 수를 계산하는 비용이 많이 든다면, useMemo 훅을 사용해서 todo에 실질적인 변화가 있을 때만 완료한 todo의 수를 재계산하도록 보장할 수 있다
            : 마지막으로 useMemo 훅이 컴포넌트 안의 계산된 값을 메모화하는 것과 마찬가지로, useCallback 혹은 컴포넌트 안의 함수 참조를 메모화한다

        - 리액트 컴파일러를 사용한 자동 메모이제이션
            : 리액트 개발자들은 React.memo, useMemo, useCallback을 사용해서 불필요한 재렌더링, 컴포넌트 안의 컴포넌트 및 값과 함수의 불필요한 계산을 방지했다
            : 이 기법들은 효과적이지만 무엇을 언제 메모화할지는 개발자가 직접 결정해야만 한다. 이 수동 프로세스는 시간이 들 뿐만 아니라 실수를 발생시킬 수 있고
              이는 모두 애플리케이션의 성능을 저하시킬 수 있다
            : 이런 이유에서 리액트 컴파일러가 등장했다. 리액트 컴파일러는 리액트의 규칙을 이해하며, 고급 정적 분석을 활용해 컴포넌트와 리액트 애플리케이션의
              훅 사이에 메모이제이션을 지능적으로 적용한다

            : 리액트 컴파일러의 가장 뛰어난 부분은 무엇을 메모화해야 하는지에 관한 의사 결정을 '자동화한다'는 점이다. 이는 우리의 짐을 덜어주고, 수작업에 의한
              최적화와 관련된 휴먼 에러 발생 리스크와 오버헤드를 최소화한다. 최소한의 노력으로 최적화된 성능을 낼 수 있으며, 가장 큰 영향을 미치는 부분에 
              메모이제이션이 정밀하고 효율적으로 적용되는 것을 보장할 수 있다

            : TodoList 컴포넌트 예시에서 이는 리액트 컴파일러가 메모이제이션 함수를 명시적으로 사용하지 않고도 TodoItem 자식 컴포넌트 혹은 completedCount 같은
              계산된 값을 언제 업데이트해야 하는 지 자동으로 결정할 수 있다는 의미이다

            : 리액트 컴파일러는 컴포넌트가 상태 및 props를 사용하는 것을 분석함으로써 효과적으로 재렌더링을 최적화할 수 있다
            : 리액트 컴파일러는 todos에 대한 변화가 DOM의 특정한 부분에만 영향을 주는 것을 식별하고, 실제로 변경되는 todos의 부분에 
              의존하는 컴포넌트들만 재렌더링하도록 지능적으로 결정할 수 있다. 리액트 문서에서는 이를 종종 '세분화된 반응'이라 부른다

        - 외부 함수 메모이제이션
          : 리액트 컴파일러는 컴포넌트 트리의 불필요한 재렌더링을 건너뜀으로써 리액트 컴포넌트 메모이제이션을 자동화할 뿐만 아니라,
            컴포넌트 안에서 사용되는 값비싼 외부 함수의 메모이제이션도 해결한다. 예를 들면 앞의 TodoList 컴포넌트가 getPriorityTodos()라는
            외부 함수에 의존한다고 가정, getPriorityTodos 함수는 몇 가지 기준에 따라 todos의 우선순위 리스트를 계산하고 반환하는, 계산적으로 값비싼 태스크를 수행한다

          : 리액트 컴파일러는 TodoList 컴포넌트 안에서의 getPriorityTodos() 호출을 메모화함으로써 (입력 변경에 따라) 필요한 때만 재렌더링한다
          : 이 최적화는 컴포넌트 안에서의 함수 사용과 특히 관련 있다는 것을 염두에 두자. 리액트 컴파일러는 getPriorityTodos() 호출은 메모화하지만
            함수 그 자체는 메모화하지 않는다. 리액트 문서에서는 여러 다른 컴포넌트들에서 하나의 값비싼 함수를 사용할 것으로 예상한다면,
            해당 함수 자체에 대한 메모이제이션을 구현함으로써 특정한 사용 컨텍스트와 관계없이 전방위적 효율성을 보장하는 방법을 고려할 것을 안내하고 있다 

            - useEffect에서 사용되는 의존성 메모이제이션
              : 전통적으로 useEffect 훅에서 사용되는 의존성들을 메모화하는 것은 해당 이펙트가 정말 필요할 때만 재실행되는 것으로 보장하는 데 도움이 되었다
              : 하지만 리액트 컴파일러는 useEffect 안에서의 의존성 자동 메모이제이션을 처리하지 않으므로 이 영역의 연구 및 개발을 현재 진행형이다

        - 컴파일러의 핵심 가정
          : 리액트 컴파일러는 리액트 애플리케이션을 자동으로 최적화하는 한편, 처리 대상 코드에 대한 몇가지 핵심적인 가정에 의존한다
          : 컴파일러의 능력을 최대한 활용하고 최적의 성능을 보장하기 위해서는 이 가정들을 이해하고 준수해야 한다

          : 유효한 시맨틱 자바스크립트
            - 리액트 컴파일러는 컴파일러가 처리하는 코드가 유효하며, 시맨틱 자바스크립트 원칙을 따른다고 가정한다
          : 널러블 값의 안전한 처리
            - 안정성을 보장하기 위해, 컴파일러는 자신들이 코드를 처리하기 전에 해당 코드가 널러블 값과 옵셔널 값에 대한 안전 확인을 포함한다고 가정한다
              예를 들어 널러블/옵셔널에 대한 안전 확인은 다음 조건 확인을 통해 수행할 수 있다
                * 속성 존재 여부를 조건으로 확인하기
                  // nullableProperty가 null 혹은 undefined가 아니면 foo 속성에 접근한다
                  if (object.nullableProperty) {
                    return object.nullableProperty.foo
                  } 

                * 옵셔널 체이닝을 사용해 속성에 안전하게 접근하기
                  // 옵셔널 체이닝을 사용해 foo 속성에 안전하게 접근한다
                  return object.nullableProperty?.foo

          >>> 리액트/타입스크립트 설정에서는 strictNullChecks 컴파일러 옵션을 활성화해 널러블 및 옵셔널 값을 안전하게 처리함을 보장할 수 있다

        - 리액트의 규칙을 따른다
          : 리액트 컴파일러는 처리 대상 코드가 유효하고, 의미론적으로 올바른 자바스크립트인 동시에 '리액트의 규칙'을 준수한다고 가정한다
          : 이 규칙들은 컴포넌트와 훅들이 예측대로, 유지보수 가능하게 작동하는 것을 보장하는 데 매우 중요하며 컴파일러가 효과적으로 최적화를 수행하는 데 필수적이다
              
          : 컴파일러는 이 규칙을 위반한 코드를 만나면 코드가 컴파일되도록 강제하는 시도를 하지 않는다.
            대신 안전하게 해당 컴포넌트나 훅의 처리를 건너뛰고 나머지 코드를 계속 컴파일한다

          : 이 규칙에는 컴포넌트와 훅이 리액트 안에서 의도된 디자인 패턴과 일관되게 사용되었음을 보장하는 것들이 포함되어 있다
            - 컴포넌트와 훅은 순수해야 한다
            - 컴포넌트는 멱등성을 가져야 한다
            - props와 상태는 불변하게 다뤄져야 한다
            - 훅은 최상위 레벨 및 리액트 함수에서만 호출되어야 한다

          >>> 이 원칙들을 구현하는 방법과 전체 규칙 리스트에 관해 더 자세히 알고 싶다면 '리액트의 규칙' 문서를 확인하자

        - 사용해보기
          : 리액트 컴파일러는 현재 메타(Meta)의 프로덕션에서 사용하고 있기는 하지만, 컴파일러 자체는
            아직 실험 단계에 있으며 폭넓게 도입될 만큼 안정적이지는 않다는 점을 인식해야 한다

          : 리액트 컴파일러를 공식 릴리스 이전에 경험해보고 싶은 개발자를 위해 리액트 팀에서는 초기 설정에 도움을 줄 종합적인 가이드를 제공한다
            - React Compiler Getting Started
            - Successfully rolling out the compiler to your codebase

          : 리액트 컴파일러를 프로덕션 리액트 애플리케이션에 통합하는 데 관심이 있는 팀들은 리액트 컴파일러 워킹 그룹에 합류함으로써 리액트 팀과 직접 협업할 수 있다
          : 마지막으로 컴파일러 사용에 관한 더 많은 정보를 알고 싶다면 핵심 리액트 팀 멤버들의 이야기를 확인해보자
            - Forget About Memo
            - React Compiler Deep Dive

    - 리액트 서버 컴포넌트
      : 리액트 서버 컴포넌트는 리액트 생태곙서 가장 중요한 진보 중 하나로, 이로 인해 어떤 개발자들은 리액트 웹 애플리케이션을 구현하는 방법 자체를 바꿨다
      : 브라우저에서만 독립적으로 실행되는 전통적인 리액트 컴포넌트와 달리, 리액트 서버 컴포넌트를 사용하면 서버 사이드 렌더링을 리액트 아키텍처에 매끄럽게 통합할 수 있다
      : 리액트 서버 컴포넌트에 관해 구체적으로 살펴보기 전에, 웹 애플리케이션의 전통적인 패러다임 중 하나인 서버 사이드 렌더링을 기본적으로 이해하자

      : 서버 사이드 렌더링
        - 전통적으로 리액트 애플리케이션은 주로 클라이언트 렌더링을 활용했다. 로직과 컴포넌트 렌더링 처리가 사용자의 브라우저에서 이뤄졌다
        - 이 접근법은 강건한 상호작용성과 사용자 경험을 제공했지만 초기 로딩 시간과 성능을 희생하곤 했다

        - 한편, 서버 사이드 렌더링은 애플리케이션의 컴포넌트를 서버에서 처리하고, 완전히 형성한 HTML을 브라우저로 전송함으로써
          초기 로딩 시간과 SEO 가시성을 개선하지만 때때로 상호작용성과 응답성을 희생해야 했다

        - 서버 사이드 렌더링이 작동하는 방식은 예시를 통해 가장 잘 설명할 수 있다. 여기에서는 한 블로그 애플리케이션, 즉 서버에서 렌더링되는
          리액트 애플리케이션을 구축하는 간단한 예시를 통해 살펴보자. 이번 예시에서는 구체적으로 /blog/:id 페이지에 초점을 둘 것이다
          이 페이지는 한 블로그 포스트의 세부 정보와 본문 내용을 표시한다
        
        - 사용자가 이 가상 블로그의 /blog/:id 페이지를 방문하면, 이 URL에 다음 패턴을 따라 요청이 발생한다
          1. 클라이언트(예: 브라우저)는 특정 페이지를 서버에 요청한다
            : 이는 서버에 초기 콘텐츠를 꺼내도록 지시한다
          
          2. 서버는 초기 요청을 처리한다
            : 페이지의 구조적 레이아웃을 꺼내고, 구조화된 HTML을 클라이언트에 전송한다. 서버는 페이지의 구조화된 레이아웃(콘텐츠를 제공하는 HTML, 프레임워크 등)을
              꺼내고, 아직 세부적인 블로그 포스트 데이터는 가져오지 않는다

          3. 클라이언트는 HTML을 받고, 페이지를 흡수하고, API 요청을 보내 데이터를 수집한다
            : 초기 HTML을 처리한 뒤, 리액트는 해당 컴포넌트를 클라이언트 사이드에 흡수한다. 흡수란 브라우저가 서버에서 렌더링된 HTML을 받고
              이벤트 핸들러와 다른 브라우저 전용 상호작용을 붙이는 처리이다. 그 뒤 클라이언트는 서버에 API 요청을 해서 URL의 ID를 사용해
              블로그 포스트에 관한 실제 정보를 가져온다
            : 서버는 클라이언트에 요청된 데이터를 JSON 페이로드 형태로 보낸다. 이 데이터는 페이지를 완전히 표시하기 위해 필요한 정보를 모두 포함한다

          4. 클라이언트는 콘텐츠를 동적으로 렌더링한다
            : API 요청으로부터 받은 데이터를 사용해 클라이언트는 동적으로 블로그 포스트 세부 사항을 담은 페이지의 콘텐츠 영역을 형성한다
              이 단계에서 리액트는 클라이언트 사이드 스크립팅과 렌더링을 사용한다

              * 서버 사이드 렌더링 흐름 다이어그램
                1. /blog/:id로의 첫 번째 요청
                2. 서버는 HTML 스켈레톤을 클라이언트에 전송한다
                3. Client 페이지는 대화형이며 블로그 포스트 데이터를 가져오기 위한 API 요청을 만든다
                4. API로부터 데이터를 받아 클라이언트는 동적으로 페이지를 형성한다

      >>> 몇 가지 세부 사항들은 생략했지만 앞서 설명한 요청 흐름 요약은 서버 사이드 렌더링 리액트 애플리케이션 안에서 
          클라이언트와 서버 사이의 상호작용의 중요한 단계들을 포함하고 있다

          서버는 HTML을 반환하지만, '그 뒤' 클라이언트가 API 요청을 '다시' 서버로 보내 데이터를 가져온다
          '서버의 첫 응답'에 이 데이터를 가져올 수 있다면 보다 효율적이고, 프로세스를 간소화하고, 여러 요청을 보낼 필요가 줄어들 것이다

          Next.js는 전통적으로 이 중복된 라운드 트립을 getServerSideProps()라는 함수를 사용해 피했다
          getServerSideProps()는 서버 사이드에서 필요한 정보를 가져온 뒤 페이지를 렌더링함으로써 필요한 모든 정보들이 
          첫 번째 서버 응답에 포함되어 있는 것을 보장했다. 이는 렌더링 프로세스를 간소화하고 애플리케이션의 전반적인 성능을 향상하는 데 도움을 주었다

          Next.js 같은 서드파티 프레임워크가 제공하는 이런 뛰어난 기능이 아니었다면, 리액트 클라이언트는 데이터 가져오기와 렌더링을 별도로 처리해야 했을 것이다
          서버 사이드 데이터 가져오기를 직접적으로 컴포넌트 렌더링과 통합한 리액트 표준 방법은 '리액트 서버 컴포넌트'이다

    - 리액트 서버 컴포넌트
      : 리액트 서버 컴포넌트는 리액트의 새로운 기능으로, 이를 활용하면 상태를 갖지 않는 리액트 컴포넌트를 만들 수 있다. 
      : 이 컴포넌트는 '서버에서 실행' 된다. 이 컴포넌트는 리액트 아키텍처에 서버 사이드 프로세싱 능력을 가져다준다. 
      : 이를 활용하면 특정한 계산과 데이터 가져오기의 부담을 클라이언트에서 서버로 옮길 수 있다. 이는 클라이언트에 전달되는 
        코드양을 줄이고, 로딩 시간을 줄이며, 심지어 전체적인 애플리케이션 성능을 개선한다

      : 앞서 봤던 렌더링 사이클에서 서버는 구조화된 HTML을 보낼 뿐만 아니라, 블로그 포스트의 실제 콘텐츠를 서버 사이드에서 처리하고 렌더링한다
      : 결과적으로 데이터 가져오기와 컴포넌트 렌더링을 관리하는 방법이 조금 달라진다
      : 리액트 서버 컴포넌트를 활용한 서버 렌더링 리액트 애플리케이션인 경우, /blog/:id URL에 대한 요청은 다음과 같은 패턴을 따라 진행된다
          1. 클라이언트(예: 브라우저)는 특정 페이지를 서버에 요청한다
            : 이는 서버에 초기 콘텐츠를 꺼내도록 지시한다(기존과 동일)
          
          2. 서버는 리액트 서버 컴포넌트를 준비하고 제공한다
            : 서버는 구조화된 HTML만을 보내는 대신, 리액트 서버 컴포넌트를 사용해 보다 복잡한 요소(데이터 가져오기 컴포넌트를 직접 포함)를 렌더링한다
              즉, 서버는 컴포넌트 수준의 로직을 실행하고, 필요한 데이터를 가져오고, 이를 직접 렌더링된 출력에 통합할 수 있다
          
          3. 클라이언트는 서버로부터 HTML과 관련된 데이터를 받는다
            : 서버는 HTML 구조와 완전히 형성한 블로그 포스트 콘텐츠를 포함한 응답을 전송한다. 이 접근법 덕분에 클라이언트는 구조화된
              HTML을 로딩한 뒤 블로그 콘텐츠를 가져오기 위해 별도의 API를 호출할 필요가 없다. 클라이언트는 서버의 응답을 받은 뒤 리액트 컴포넌트를 흡수한다

          4. 클라이언트는 최종 콘텐츠를 렌더링한다
            : 클라이언트 사이드 리액트 애플리케이션은 초기 렌더링 이후 발생하는 사용자 상호작용과 모든 동적 변경을 처리한다
            : 예를 들면 사용자가 댓글을 게시하거나 페이지를 조작하면, 이 동작들은 클라이언트 사이드 업데이트를 트리거한다(기존과 동일)

          >>> 리액트 서버 컴포넌트 예시 코드는 BlogPost.jsx 참고           
              * 리액트 서버 컴포넌트를 사용한 서버 사이드 렌더링 흐름의 다이어그램
                1. /blog/:id에 대한 초기 요청
                2. 서버는 리액트 서버 컴포넌트를 렌더링하고 데이터를 가져온다
                3. 서버는 완전한 HTML와 데이터를 함께 클라이언트에 전송한다
                4. 클라이언트는 클라이언트 컴포넌트를 흡수하고 상호작용성을 추가한다

          >>> 리액트 서버 컴포넌트를 사용하며 API 엔드포인트를 노출하거나 컴포넌트에 직접 데이터를 로딩하기 위한 로직을
              클라이언트 사이드에 추가하지 않아도 된다. 모든 데이터 처리를 서버가 수행해준다

          >>> 리액트 서버 컴포넌트는 서버에서 배타적으로 실행되기 때문에 전통적인 클라이언트 컴포넌트와 비교해 그 동작에 다소 차이가 있다    


    - 클라이언트 사이드 리액트 API에 접근할 수 없다
      : 서버 컴포넌트는 브라우저가 아니라 서버에서 실행되므로 useState 같은 전통적인 리액트 컴포넌트 API를 사용할 수 없다
      : 리액트 서버 컴포넌트 설정에서 상호작용을 도입하려면 상호작용성을 다루는 클라이언트 컴포넌트를 활용해서 서버 컴포넌트를 보완해야 한다
      : 앞의 블로그 포스트 예시에 이어서 설명하자면 Comment 클라이언트 컴포넌트를 갖도록 할 수 있다. 이 컴포넌트는 몇 가지 상태와 상호작용성을 포함해 렌더링된다
      : 댓글 기능을 포함하도록 BlogPost 서버 컴포넌트를 업데이트했으니 이제 사용자는 각 포스트에 관련된 상호작용을 볼 수 있다
        새로운 Comment 클라이언트 컴포넌트는 몇 가지 클라이언트 상태와 상호작용성을 포함할 수 있다

      : 앞의 코드는 BlogPost를 서버 컴포넌트로 렌더링하면서 시작한다. 이어서 번들러를 구성해서 Comment 클라이언트 컴포넌트를 위한 번들을 조립한다
      : 브라우저 안에서 Comment 컴포넌트는 BlogPost 서버 컴포넌트의 출력을 props로 받는다

      : Comment 컴포넌트 파일 맨 첫 부분에서 "use client" 선언을 한 점에 주목하자. 리액트 서버 컴포넌트를 "use client"는 
        이 컴포넌트가 클라이언트 컴포넌트라는 것을 나타낸다. 즉, 이 컴포넌트는 상태를 관리할 수 있고, 사용자 상호작용을 처리할 수 있고
        브라우저에 특화된 API를 사용할 수 있음을 의미한다. 이 지시자는 명시적으로 리액트 프레임워크와 번들러에게 이 컴포넌트를
        서버 컴포넌트(즉, 상태를 갖지 않고 서버에서 실행되는 컴포넌트)와 다르게 처리하라고 지시한다

      : 하지만 서버 컴포넌트는 기본이므로 "use server"라는 지시자를 서버 컴포넌트 파일의 맨 윗부분에 기술하지 않는다
      : 대신 "use server" 지시자는 클라이언트 컴포넌트에서 호출될 수 있는 서버 사이드 함수를 표시할 때만 사용해야 한다
        (이는 서버 액션이라 불린다)

    - 비동기 서버 컴포넌트
      : 서버 컴포넌트는 '비동기'로 작동할 수 있으며, 이를 활용해 데이터 가져오기, 계산 및 다른 태스크들을
        서버 실행 중에 직접 수행할 수 있다. 이 접근법은 클라이언트에 콘텐츠가 보내지기 전에 복잡한 조작을 처리할 수 있어,
        렌더링 프로세스를 최적화하고 웹 애플리케이션의 전체적인 성능을 최적화한다

      : 비동기 서버 컴포넌트는 데이터 가져오기, 처리 및 다른 비동기 태스크를 처리하는 비동기 함수를 정의함으로써 작동한다
        (BlogPost.jsx 참조)
      : 해당 예시는 await 키워드를 사용해 메인 post 콘텐츠를 가져온다. 즉 서버 컴포넌트는 데이터베이스에서 데이터를 꺼낼 때까지
        대기함으로써 블로그 포스트의 필수 요소(title, summary, author, content 등)를 완전히 로딩한 뒤 컴포넌트를 렌더링한다
      : 이 접근법은 초기 렌더링 이후 즉시 접근해야 하는 중요한 콘텐츠를 처리하는 데 핵심적이며, 지체 없이 완전하고 정보가 풍부한
        포스트를 표시함으로써 사용자 경험을 개선한다

      : 한편 댓글 영역은 다르게 처리된다. await를 사용하지 않고 댓글 가져오기를 시작하기 때문에, 이 요청은 블로킹되지 않는다
      : 즉, 서버 컴포넌트는 댓글이 로딩되는 것을 기다리지 않고 렌더링 프로세스를 진행한다. 대신, 이 댓글들은 리액트 Suspense 컴포넌트에 의해
        비동기로 가져오고 관리되며, 댓글이 표시되기 전까지는 대체 로딩 메시지가 표시된다

      : comments의 콘텐츠는 서버에서 처리가 시작되지만, 기다려지지는 않으므로, 클라이언트에 비동기로 전달될 수 있다
        여기에서 리액트의 use() 함수가 등장하는데, Comment 클라이언트 컴포넌트 안에서 use() 함수는 댓글의 비동기 로딩 관리의 중요한 역할을 한다.
        use(Comment)를 사용하면 컴포넌트는 서버 컴포넌트에서 전달된 프로미스를 구독한다. 
        
      : 결과적으로 클라이언트 컴포넌트는 댓글을 사용할 수 있게 되는 순간 곧바로 댓글을 렌더링하며, 
        페이지의 나머지 부분에 대한 초기 렌더링은 블로킹되지 않는다

      : 위와 같이 설정하면 포스트 콘텐츠는 즉시 로딩되고 보여진다. 서버에서 포스트 콘텐츠를 대기하므로 첫 번째 렌더링 시
        주요 정보를 사용할 수 있음을 보장한다. 한편 댓글은 비동기로 로딩되고 사용 가능하게 되었을 때 표시된다
        따라서 포스트 콘텐츠의 렌더링을 지연시키지 않는다. 이 패턴은 점진적 향상 원칙을 내포한다. 점진적 향상 원칙에서는
        기본 콘텐츠 기능은 한 번에 제공하고, 추가적인 기능들은 점진적으로 제공한다

    - 서버 액션
      : 서버 액션을 사용하면 클라이언트 컴포넌트가 서버 사이드 함수를 직접 호출하게 할 수 있다
      : 이를 활용하면 때때로 서버 사이드 처리와 클라이언트 사이드의 동적 응답성의 장점을 조합할 수 있다

      : 서버 액션은 서버 컴포넌트 안에서 "use server" 지시자를 사용해 정의할 수 있다
      : 앞의 블로그 포스트 예시에 서버 액션을 추가해 좋아요 기능을 처리해보자

      : 우리가 정의한 서버 액션은 props로서 아래로 전달되며 클라이언트 컴포넌트에서 사용할 수 있다
      : Comments 컴포넌트가 이 액션을 활용할 수 있도록 업데이트하자

      : Comments 클라이언트 컴포넌트에서 직접 upvoteAction()을 각 댓글의 좋아요 버튼에 대한
        onClick 핸들러로 사용했다. commentId는 버튼을 클릭했을 때 액션에 전달된다

      : "Upvote" 버튼을 클릭하면 upvoteAction() 서버 액션이 호출되고, 서버 사이드 동작을 트리거 해서 특정 댓글의
        좋아요 횟수를 증가시킨다. 이 프로세스는 전체 페이지 재로딩을 요구하지 않으며, 클라이언트 사이드 상호작용의
        실시간 응답성과 데이터 무결성 및 서버 사이드 동작의 처리 능력을 결합한 매끄러운 사용자 경험을 제공한다

      : 서버 액션을 서버 컴포넌트에서 클라이언트 컴포넌트로 전달하는 것에 더해, 클라이언트 컴포넌트 또한
        "user server" 지시자를 선언한 파일에서 직접 서버 액션을 임포트할 수 있다

    - 리액트 서버 컴포넌트는 리액트를 사용한 구축의 미래인가?
      : 리액트 서버 컴포넌트는 리액트 개발의 지평을 바꾸었다. 리액트 서버 컴포넌트를 사용하면 서버 사이드 렌더링과
        클라이언트 사이드 렌더링을 조합해 성능과 사용자 경험을 최적화할 수 있다. 리액트 서버 컴포넌트는 리액트 개발에
        다음과 같이 여러가지 이익을 가져다준다
          - 성능 개선
            : RSC는 복잡한 계산과 데이터 가져오기를 서버에 넘김으로써, 클라이언트에 전달할 자바스크립트의 양을 줄인다
            : 이는 빠른 초기 로딩 시간과 성능 개선을 가져오며, 특히 느린 연결이나 디바이스를 사용하는 사용자에게 효과가 있다
          
          - SEO 향상
            : 서버 사이드 렌더링은 콘텐츠가 이미 검색 엔진에서 읽을 수 있는 상태임을 보장하므로
              SEO를 향상하고 애플리케이션을 보다 잘 발견되게 만든다

          - 데이터 가져오기 단순화
            : RSC는 데이터 가져오기를 컴포넌트 렌더링 프로세스에 직접 통합하므로, 클라이언트는 별도의 API 호출을 할 필요가 없다
              이 간소화된 접근법은 클라이언트 사이드의 상태와 데이터 동기화를 관리하는 복잡성을 줄인다

          >>> 리액트 서버 컴포넌트는 컴포넌트 안에서 서버 코드를 실행하는 비교적 새로운 접근법임을 언급해야 하겠다
              이 패러다임 전환은 기회와 어려움을 함께 가져다준다. 클라이언트 사이드 리액트 개발에 익숙한 개발자라면
              RSC를 충분히 활용하기 위해서는 멘탈 모델과 프랙티스를 바꿔야 할 것이다
              
          >>> 라이브러리의 도구들을 포함한 리액트 생태계는 RSC 기반 개발을 지원하고, RSC 기반 개발을 위해 최적화되어야 할 것이다
              RSC 보다 널리 도입됨에 따라 새로운 모범 사례와 패턴이 나타날 것이고, 우리가 리액트 애플리케이션을 구조화하고
              구축하는 방법을 바꿀 것이다. 또한 현재 RSC를 사용하기 위해서는 호환되는 서버 및 클라이언트 환경이 필요하다

          >>> 즉, 특정 프레임워크에 의존해야 함을 의미한다. 상당한 시간 동안 Next.js만이 유일하게 RSC를 지원했으며
              그 도입을 도와왔다. 하지만 리액트 19가 안정화에 들어가면서 다른 프레임워크들(RedwoodJS, Waku, Gatsby 등)도 RSC를 지원하기 시작했다
              앞으로 더 많은 프레임워크들이 RSC를 지원할 것이며, 개발자들의 선택지를 넓혀줄 것이라 기대한다
              (RSC가 리액트를 사용한 구축의 미래인가? 늘 그렇듯, 상황에 따라 다르다)
        
          >>> 리액트 서버 컴포넌트는 분명 리액트 개발에서 흥미로운 진화이지만 반드시 이것만 사용해야 하는 것은 아니다
              리액트는 여전히 클라이언트 애플리케이션에서도 강력한 유틸리티이며 독립적인 클라이언트 라이브러리로써 사용될 수 있다
              개발자들은 여전히 RSC를 도입할 필요 없이 리액트를 사용해 단일 페이지 애플리케이션을 만들거나 서버 사이드 렌더링
              애플리케이션을 만들 수 있다

          >>> 리액트의 강점은 다양한 개발 접근법을 수용할 수 있는 다재다능함과 능력에 있다. 리액트는 라이브러리로서
              애플리케이션 구축의 다양한 방법을 활성화하는 환상저인 일을 했다. 이 유연성을 보여주는 기본적인 예가
              클래스 기반 컴포넌트에 대한 지원을 계속한다는 것이다. 2018년 함수형 컴포넌트와 훅의 확산에 따라
              클래스 기반 컴포넌트는 대부분 구식이 되었지만 여전히 리액트는 지원하고 있다

          * 결론적으로 리액트 서버 컴포넌트는 강력한 이익을 제공하며 점점 확산될 것이지만 이들은 리액트 생태계에 추가된 또 하나의 도구일 뿐,
            기존 패턴들을 반드시 대체해야 하는 것은 아니다. 리액트를 사용한 구축의 미래는 더 확산될 것이다. 
            개발자들은 그들의 프로젝트 요구사항에 맞는 최적의 접근 방법 (RSC를 사용하든, 전통적인 클라이언트 사이드 렌더링을 사용하든,
            하이브리드 접근법을 사용하든)을 찾을 것이다

          * 더 읽을 거리
           - React Server Components
           - Server Actions
           - Understanding React Server Components
           - When to use Server and Client Components
           - Making Sense of React Server Components
           - React Server Components: A comprehensive guide



          
