[데이터 가져오기]
클라이언트와 서버 사이에 발생하는 데이터 교환의 형태(RESTful API, GraphQL, WebSocket 등)에 관계없이
리액트 및 자바스크립트 애플리케이션에서는 다양한 접근법을 사용해서 서버로부터 데이터를 가져올 수 있다

내장 브라우저 API(Fetch API 등), 단순한 프로미스 기반 HTTP 클라이언트(Axios 등), 
혹은 보다 세련된 쿼리 라이브러리(리액트 쿼리), 혹은 SWR을 사용하는 것을 포함한다

[브라우저 API와 간단한 HTTP 클라이언트]
Fetch API는 자바스크립트 인터페이스를 제공하며 이를 사용하면 요청 및 응답과 같은 HTTP 파이프라인의 일부에 접근하거나 일부를 조작할 수 있다
Fetch API는 글로벌 fetch() 메소드를 제공하며 이를 사용하면 웹 요청을 쉽게 만들 수 있다 
    - useEffect 훅을 사용해 Fetch API를 사용하는 예시 확인 (fetch-api-with-useEffect)

보다 나은 에러 핸들링, 요청 가로채기 추가, 혹은 내장된 교차 사이트 위조(cross site forgery, XSRF) 보호 같은
몇몇 추가 기능이 필요하면 표준 Fetch API보다 많은 기능을 제공하는 Axios 같은 최소한의 HTTP 라이브러리를 활용할 수 있다

Fetch와 Axios API는 다소 유연하지만 상당히 저수준이다. 애플리케이션의 규모가 커지고 요구사항이 복잡해지면서
개발자들은 에러 핸들링, 에러 잡기, 재시도에 관한 반복적인 코드를 작성해야 한다는 것을 발견할 수 있는데 이때 보다 세련된 데이터 가져오기 라이브러리가 등장한다

[보다 세련된 데이터 가져오기 라이브러리]
리액트 쿼리(탠스택 쿼리, TanStack Query) 및 SWR 같은 특화된 라이브러리들은 모든 웹 애플리케이션에서 데이터 가져오기에 개발자들이 접근하는 방식을 진일보시켰다
해당 라이브러리들은 데이터 가져오기, 캐싱, 동기화를 위해 일련의 도구를 제공하며 이 태스크들과 관련된 많은 복잡성을 추상화하는 것을 돕는다

리액트 쿼리의 useQuery 훅은 데이터 가져오기의 핵심이다. useQuery는 하나의 명확한 식별자 비동기 함수를 받아 API로부터 데이터를 가져온다
useQuery 훅을 사용하려면 먼저 리액트 애플리케이션에서 리액트 쿼리를 초기화해야 한다
이를 통해 리액트 컴포넌트에게 필요한 컨텍스트를 전달함으로써 리액트 쿼리가 제공하는 데이터 가져오기 기능에 접근할 수 있게 한다

리액트 쿼리를 초기화할 때는 리액트 쿼리에서 QueryClient와 QueryClientProvider를 임포트한다
다음으로 QueryClient를 만들고 QueryClientProvider를 사용해 리액트 애플리케이션을 감싼다
애플리케이션에서 리액트 쿼리를 초기화했으면 useQuery 훅을 효과적으로 사용해 데이터를 가져온 뒤, 애플리케이션에서 그 상태를 관리할 수 있다

[캐싱]
리액트 쿼리 같은 라이브러리의 두드러진 기능 중 하나는 '캐싱'이다.
데이터 가져오기라는 컨텍스트에서 캐싱은 가져온 데이터를 저장해두는 것을 의미한다
미래에 요청이 왔을 때 다른 네트워크 요청을 만드는 대신 캐시에서 데이터를 꺼내 보다 빠르게 제공한다

리액트 쿼리는 독특하게 캐싱 프로세스를 서버 혹은 브라우저의 로컬 저장소가 아닌 메모리(자바스크립트 객체/스토어)를 사용해서 직접 관리한다
리액트 쿼리는 데이터를 캐싱하는 동시에 자동으로 특정한 트리거 또는 설정된 기간에 기반해 자동으로 데이터를 무효화하고 다시 가져온다
이로 인해 사용자는 항상 최신 데이터를 볼 수 있고 동시에 캐싱이 주는 성능의 이익을 누릴 수 있다
(리액트 쿼리를 사용하면 데이터를 서버에서 가져왔을 때 캐시에 자동으로 저장된다)

컴포넌트가 이 데이터를 다음에 필요로 하면 해당 데이터는 캐시에서 가져온다
이는 빠르고 즉각적인 접근을 보장하고 백그라운드에서 서버로 새로운 요청이 만들어진다
서버의 데이터가 변경되었다면 캐시를 업데이트하고 컴포넌트는 재렌더링을 수행하고 최신 변경 내용을 보여준다
    1. 컴포넌트가 데이터를 질의한다
    2. 캐시에서 데이터가 제공된다
    3. 백그라운드에서 서버에 새로운 요청을 만든다
    4. 서버와 데이터가 변경되었다면 캐시를 업데이트한다
    5. 캐시가 업데이트되면 컴포넌트는 캐시에서 최신 데이터를 가져온다

[staleTime]
리액트 쿼리를 사용해서 만든 각각의 쿼리에 대해 staleTime 옵션을 사용해서 가져온 데이터가
'최신의 것'이라 간주할 수 있는 시간의 양(밀리초)을 지정할 수 있는데 기본적으로 리액트 쿼리는 이 값을 0으로 설정한다

만약 staleTime을 1분으로 설정하면, 초기 쿼리 요청 이후 1분이 지나지 않았을 때 다른 쿼리가 만들어지면
리액트 쿼리는 현재 (캐싱된) 데이터를 최신의 것으로 간주하고 새로운 데이터를 가져오기 위한 백그라운드 요청을 만들지 않는다
대신 두 번째 요청에 대해 캐시에서 데이터를 꺼내 제공한다

1분이라는 시간이 경과한 뒤 쿼리 요청이 만들어지면 리액트 쿼리는 데이터가 오래되었다는 것을 인식한다
해당 데이터를 요청한 모든 컴포넌트에 즉시 캐싱된 데이터를 제공하고 동시에 백그라운드 요청을 만들어 서버로부터 데이터의 가장 최신 버전을 가져온다

[캐시 업데이트하기]
리액트 쿼리는 캐시와 직접 상호작용하고 캐시를 업데이트할 수 있는 일련의 유틸리티들을 제공한다
변경 요청(예를 드련 서버의 데이터를 변경하는 요청)이 성공 혹은 실패했을 때 캐시를 업데이트하고 싶을 수 있다
이 경우 캐시와 직접 상호작용하는 방법을 안다면 유용할 수 있다 (리액트 쿼리는 변경을 처리하기 위해 useMutation 훅을 제공한다) 

useMutation 훅도 useQuery 훅과 마찬가지로 isLoading, isError 속성을 반환해 변경 요청의 상태를 관리하고
변경 프로세스를 진행하는 동안 사용자에게 피드백을 제공하는데, mutate() 함수를 반환하여 변경 요청을 트리거한다

변경에 성공했다면 캐시를 즉시 업데이트함으로써 관련된 쿼리 데이터에 의존하는 모든 컴포넌트들을 최신 정보에 접근할 수 있도록 할 수 있다
이는 클라이언트의 setQueryDate() 함수를 사용하면 쿼리 키를 기반으로 특정 쿼리의 캐시를 업데이트할 수 있다
useMutation 훅의 onSuccess() 콜백 안에서 이 함수를 트리거해서 변경을 성공적으로 완료한 직후 실행되도록 하면 된다 

해당 메소드를 사용하면 캐시에 낙관적인 업데이트를 제공하며 추가적인 가져오기 요청이 없어도 UI가 최신 데이터로 업데이트되는 것을 보장할 수 있다
캐시를 직접 업데이트할 수 있는 해당 기능을 활용하면 '상태'를 업데이트하고 관리할 수 있으며, 이는 데이터 가져오기 라이브러리에 의해 추적 및 유지보수된다
변경에 의해 어떤 컴포넌트의 데이터가 변경되었을 때, 이 중앙화된 캐시(글로벌 스토어) 덕분에 동일한 데이터에 의존하는 다른 컴포넌트들도 그 변경을 즉시 반영할 수 있다
또한 캐시를 직접 업데이트할 수 있으므로 개발자들은 애플리케이션 상태오 사용자 경험을 한층 세세하게 통제할 수 있다

리액트 쿼리는 '공격적이지만 온건한 기본값'을 제공하는데 보다 자세한 내용은 Important Defaults 및 Caching에 관한 문서(https://tanstack.com)를 참고

[데이터 미리 가져오기]
미리 가져오기(prefetching)는 데이터가 실제 필요하기 전에 적극적으로 가져오는 프랙티스를 가리킨다
이는 사용자가 UI 요소와 상호작용하거나 새로운 스크린으로 이동했을 때 최신 데이터를 사용할 수 있도록 준비하는 것을 목적으로 한다
데이터를 미리 가져오면 인지된 로딩 시간을 줄임으로써 종종 보다 매끄러운 사용자 경험을 제공할 수 있다

리액트 쿼리는 prefetchQuery() 메소드를 제공한다. 해당 메소드를 사용하면 지정한 쿼리 키에 관한 데이터를 미리 가져올 수 있다
미리 가져온 데이터는 캐시에 저장되고 이어서 같은 쿼리 키를 사용해 useQuery()를 호출하면 다시 가져오기를 하지 않고도 캐싱된 데이터에 즉시 접근할 수 있다

[플레이스홀더 데이터]
쿼리의 데이터가 아직 요청 중인 경우 플레이스홀더 데이터가 존재한다면 해당 데이터를 사용자에게 보여주고 싶을 때가 있다
플레이스홀더 데이터는 다음과 같은 시나리오에서 유용하다
    - 느린 네트워크 요청을 다룰 때
        : 특정한 쿼리를 실행하는 데 상당한 시간이 요구된다면 빈 페이지나 로더보다 스켈레톤이나 플레이스홀더를 표시함으로써 사용자의 참여를 유지할 수 있다
    - 낙관적인 업데이트를 제공할 때
        : 변경을 수행하는 동안 실제 요청이 백그라운드에서 진행되고 있음에도 불구하고 플레이스홀더 데이터를 사용하면 해당 데이터가 즉시 업데이트될 것이라는 착각을 줄 수 있다
    - 일관성 있는 레이아웃을 보장할 때
        : 플레이스홀더 데이터는 레이아웃을 일관성 있게 유지되도록 보장함으로써 데이터를 가져왔을 때 레이아웃이 변하는 것(사용자 경험 방해)을 방지할 수 있다
                        
리액트 쿼리에서 placeholderData 옵션을 사용하면 특정 쿼리에 관한 플레이스홀더 데이터를 표시할 수 있다                        
placeholderData를 사용하면 캐시에 초기 데이터를 저장하지 않고도 초기 플레이스홀더 데이터를 사용자에게 표시할 수 있다
플레이스홀더 데이터를 표시하고 동시에 캐시에 저장하고 싶다면 initialData 쿼리 구성 옵션을 사용하면 된다

[재시도 메커니즘]
기본적으로 리액트 쿼리는 쿼리 요청이 실패하면 자동으로 해당 쿼리를 3번 재시도한 뒤 에러를 표시한다
이 기본값은 글로벌 혹은 개별 쿼리 수준에서 설정할 수 있다. retry 옵션을 false로 설정하면 재시도 메커니즘을 비활성화할 수 있다
애플리케이션이 간헐적으로 네트워크 이슈를 가질 수 있는 경우, 예를 들면 유지보수나 예기치 않은 장애로 서버가 종종 다운되거나
특정 요청이 다른 쿼리 요청보다 자주 실패할 것으로 예상될 때는 재시도 메커니즘을 설정하는 것이 유용할 수 있다

[Devtools]
리액트 쿼리는 강력한 Devtools를 제공하는데, 이를 활용하면 디버깅과 개발 경험을 상당히 크게 향상할 수 있다
Devtools는 쿼리, 변경, 캐시 상태에 관한 실시간 통찰을 제공하며 애플리케이션의 동작을 쉽게 이해하고 디버깅할 수 있다
Devtools를 사용하기 위해서는 먼저 별도 제공되는 패키지를 설치한다
    - yarn add @tanstack/react-query-devtools

다음으로 Devtools를 애플리케이션에 통합하기 위해 ReactQueryDevtools를 임포트하고 컴포넌트 트리에서 가능한 한 위쪽에 위치하게 한다    
Devtools를 통합했다면 리액트 쿼리 Devtools가 제공하는 다양한 기능을 사용할 수 있는데 기능의 핵심은 실시간 쿼리 및 변경 추적이다
실행 중인 모든 쿼리와 변경 및 최근 실행된 모든 쿼리와 변경을 지속적으로 업데이트한 동적 리스트를 제공하며 이를 통해 각 쿼리 혹은 변경의 상태를 확인할 수 있다

Devtools는 수동 다시 가져오기 및 캐시 조작 기능을 제공하는데 이는 개발 프로세스를 진행하는 동안 매우 유용하다
해당 기능을 사용하면 수동으로 쿼리를 다시 가져오거나 캐시 리셋을 트리거할 수 있어 보다 효율적으로 데이터 변경에 따른
애플리케이션의 응답 테스트 및 디버그를 수행할 수 있다
    e.g. Devtools를 통한 수동 트리거
            Actions
                [Refetch] [Invalidate] [Reset] [Remove] [Trigger] [Loading] [Trigger Error]

[더 많은 기능들]
리액트 쿼리는 앞서 언급한 기능들 외에도 많은 기능을 제공하는데 관련 내용은 다음과 같다
    - 의존 쿼리
        : 한 쿼리의 완료 상태에 따라 다른 쿼리를 실행할 수 있다. 올바른 순서로 데이터를 가져오는 것을 보장한다
    - 병렬 쿼리          
        : 리액트 쿼리는 여러 쿼리를 동시에 가져올 수 있다. 빠른 데이터 취득을 보장한다
    - 페이지네이션 및 무한 쿼리
        : 리액트 쿼리는 페이지네이션 쿼리와 무한 쿼리를 기본 제공한다. 이를 사용하면 대규모 데이터셋을 쉽게 다룰 수 있다
    - 서버 렌더링 및 흡수 지원
        : 서버 사이드 렌더링 프레임워크(Remix 또는 Next.js)와 통합하면 서버에서 데이터를 미리 가져와 클라이언트에 전달할 수 있다
        : 미리 가져온 데이터를 사용해 클라이언트 사이드의 리액트 쿼리 캐시를 흡수할 수 있다
    
    > 리액트 쿼리를 사용하면 복잡한 데이터 가져오기, 캐시, 상태 동기화를 쉽게 다룰 수 있다
    > 이를 통해 복잡한 데이터 가져오기 및 관리의 수렁에 빠지지 않고 사용자 인터페이스 구축과 전반적인 사용자 경험 향상에 집중할 수 있다

[효율적인 데이터 가져오기를 위한 팁]
최적의 리소스 활용 보장과 보다 나은 사용자 경험을 제공하기 위해 데이터 가져오기에 효율적으로 접근하기 위한 몇 가지 전략이 있다
    - 데이터 모델을 세심하게 설계하라
        : 애플리케이션의 데이터 니즈를 고려하고 그 니즈에 최적화된 데이터 모델을 설계해야 한다
        : 데이터 모델을 설계할 때 유념해야 할 몇 가지 핵심 원칙이 있다
            - 데이터 소스의 수 최소화
            - 데이터 저장과 회수를 최적화
            - 확장성을 염두에 두고 설계
        > 위와 관련된 작업은 클라이언트가 아니라 데이터베이스 측에서 이뤄지기 때문에 모든 클라이언트 사이트의 데이터 가져오기 전략에서 중요한 전제가 된다
        > 최적화된 서버 사이드 구조는 필연적으로 클라이언트 사이드의 데이터 가져오기 프로세스를 단순하게 만든다

    - 엔드포인트를 최적화하라
        : 클라이언트 관점에서 데이터 가져오기는 데이터를 가져오는 방법인 동시에 서버가 데이터를 제공하는 방법이기도 하다
        : 서버 엔드포인트를 최적화함으로써 효율적으로 데이터를 제공하는 것은 중요하며 최적화는 다음을 포함할 수 있다
            - 데이터베이스 인덱스를 효과적으로 활용하기
            - 데이터베이스 호출 횟수 줄이기
            - 서버 응답 압축하기
            - 서버 사이드에서의 응답 데이터 필터링 및 제한하기

    - 가능하다면 요청을 배치로 만들라
        : 여러 작은 요청을 하나의 배치 요청으로 합치면 종종 개별 요청에 의해 발생하는 오버헤드를 줄일 수 있다
        : 특정한 데이터셋이 짧은 간격으로 계속해서 요청되는 것을 알고 있다면 해당 방법이 특히 유용하다
        : 예를 들어, 사용자 세부 정보와 사용자 주문을 서로 다른 2개의 요청으로 가져오는 대신
          2개의 정보 셋을 항상 함께 가져와야 한다는 것을 알고 있다면, 이들을 하나의 요청으로 만들어 전체적인 지연과 처리 시간을 줄일 수 있다

    - 우선순위를 지정하고 (요청을) 연기하라
        : 가져올 데이터와 가져올 시기를 신중하게 결정하는 것은 애플리케이션의 응답성을 유지하는 데 매우 중요하다
        : 페이지를 로딩할 때 모든 데이터를 즉시 가져올 필요는 없다
        : 초기 사용자 경험에 중요한 데이터가 무엇인지 식별하고 그 데이터를 먼저 가져오는 것은 때때로 대단히 유용하다
        : 사용자는 필수적이지 않은 데이터를 불필요하게 기다리지 않고도 애플리케이션과 상호작용할 수 있다
        : 즉시 필요하지 않은 데이터라면 지연 로딩 사용을 고려할 수 있다

    - 지연 로딩을 사용하라
        : 지연 로딩은 데이터가 실제 필요할 때(예를 들면 사용자가 페이지의 특정한 영역까지 스크롤하거나 특정한 기능을 클릭하는 등)까지 데이터 가져오기를 지연시키는 기법이다
        : 즉시 필요하지 않은 데이터라면 지연 로딩을 고려할 수 있다. 많은 양의 데이터를 다루는 경우 지연 로딩을 사용하면 페이지의 초기 로딩 시간을 상당히 개선할 수 있다
        : 브라우저는 최초에 꼭 필요한 최소한의 콘텐츠만 가져와서 렌더링하면 되기 때문이다

    - 캐싱을 사용해 데이터 가져오기를 최소화하라
        : 캐싱은 자주 접근되는 데이터를 메모리에 저장해서 데이터 소스로부터 매번 가져오는 것보다 훨씬 빠르게 가져올 수 있도록 하는 기법이다
        : 캐싱의 개념은 클라이언트에만 국한될 필요가 없다. Redis 같은 도구들을 서버에서 활용해 전체적인 캐싱 전략을 만들 수 있다
        : 캐싱을 사용할 때 유념해야 할 몇 가지 핵심 원칙에는 다음이 포함된다  
            - 적절한 캐시 만료 시간 사용
            - 자주 접근되는 데이터만 캐싱 사용
            - 캐시 무효 전략을 구현해서 캐싱된 데이터가 최신을 유지하도록 한다

    - GraphQL 사용을 고려하라
        : GraphQL은 API를 위한 쿼리 언어 및 런타임으로 전통적인 REST 접근법에 비해 보다 효율적이고, 유연하고, 강력한 대안을 제공한다
        : 고정된 데이터 구조를 갖는 여러 엔드포인트를 사용하는 대신 GraphQL을 사용하면 클라이언트는 그들이 필요한 데이터만, 필요한 형태로, 단일 엔드포인트에 요청할 수 있다
        : 예를 들어 서버에 todo 리스트를 가지고 있고, 각 todo 아이템에서 title과 completionStatus만 추출하고 싶다고 가정
            - REST를 사용한다면 하나의 엔드포인트에 요청해야 한다
                : REST를 사용해 todos 리스트 얻기(GET)
                    fetch('/todos')    
            - REST의 경우 엔드포인트에서 각 todo의 title과 completionStatus를 반환하지만 동시에 description, creationDate, dueData 및 다른 수많은 불필요한 정보도 함께 반환한다
                : REST 엔드포인트로부터의 모의 응답
                    [
                        {
                            "id": 1,
                            "title": "Buy groceries",
                            "description": "Milk, Bread, and Eggs",
                            "creationDate": "2024-01-01",
                            "dueDate": "2024-01-11",
                            "completionStatus": false 
                        },
                        {
                            "id": 2,
                            "title": "Schedule dentist appointment",
                            "description": "Remember to call Dr. Smith",
                            "creationDate": "2024-01-03",
                            "dueDate": "2024-01-03",
                            "completionStatus": false 
                        },
                        ...
                    ]                                            

            - GraphQL을 사용하면 구체적인 데이터를 가져올 수 있다
                : GraphQL을 사용한 todo의 쿼리 리스트
                    {
                        todos {
                            title
                            completionStatus
                        }
                    }                       
                > GraphQL 쿼리는 각 todo의 title과 completionStatus만 반환한다. 각 todo가 가졌을지 모르는 다른 잠재적인 필드는 반환하지 않는다
            
            - GraphQL 엔드포인트로부터의 모의 응답
                {
                    "data": {
                        "todos": [
                            {
                                "title": "Buy groceries",
                                "completionStatus": false
                            },
                            {
                                "title": "Schedule dentist appointment",
                                "completionStatus": false
                            },
                            ...
                        ]
                    }
                }                                             
                > GraphQL을 사용하면 클라이언트는 그들이 요청한 것만을 얻을 수 있다
                > GraphQL은 전통적인 REST 엔드포인트에 비해 작고, 보다 효율적이고, 빠른 응답으로 이어진다

            - 항상 GraphQL을 사용해야 하는가?
                : GraphQL은 클라이언트 관점에서는 많은 이익을 제공하지만 만능 해결책은 아니다
                : GraphQL은 완전히 처음부터 만드는 상황이라면 복잡성을 추가할 수 있다. 데이터 가져오기 니즈가 직관적이라면 REST API를 사용해도 충분하다
                : GraphQL은 정확히 필요한 데이터만 가져올 수 있지만 올바르게 관리되지 않으면 비효율적인 쿼리를 야기할 수 있다
                : GraphQL 서버를 설정하는 것은 때때로 REST 엔드포인트를 사용할 때는 잘 보이지 않는 성능 오버헤드를 야기하기도 한다    

    - 성능을 모니터링 및 분석하라
        : 정기적으로 데이터 가져오기 작업의 성능을 모니터링함으로써 비효율이나 병목에 관한 통찰을 얻을 수 있다
        : 구글의 크롬에서 제공하는 네트워크 탭 또는 Lighthouse 도구를 사용하면 데이터 가져오기 프로세스의 속도와 신뢰성을 향상할 수 있는
          실시간 지표 및 최적화 제안 등을 얻을 수 있다
        : 보다 오랜 기간에 걸쳐 성능을 모니터링해야 할 경우 New Relic과 Datadog 같은 서비스를 사용할 수 있다
        : 위 서비스를 사용하면 종합적인 분석, 경고, 대시보드 기능을 활용할 수 있다 (이들은 모두 애플리케이션 성능 모니터링에 최적화되어 있다)  