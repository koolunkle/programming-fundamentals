[기술적 마이그레이션]
대규모 웹 애플리케이션을 구축할 때, 개발 과정에서 기술적 마이그레이션은 피할 수 없다
애플리케이션이 성장하고 기술이 진화하면서 우리는 종종 기존 코드보다 새롭고 효율적인 기술 및 방법론에 맞는 코드로 마이그레이션해야 한다

기술적 마이크레이션은 기존 시스템, 애플리케이션, 혹은 데이터셋의 스택, 플랫폼, 버전을 이동하는 프로세스를 가리킨다
성능, 유지보수성, 보안을 개선하거나 진화하는 업계 표준과 발맞추기 위해 기술적 마이그레이션을 수행한다

마이그레이션은 다음과 같이 다양한 변경과 업그레이드를 포함할 수 있다
    - 의존성, 라이브러리, 프레임워크 업그레이드 혹은 대체 
    - 새로운 프로그래밍 언어 또는 플랫폼으로 이동
    - 새로운 버전의 데이터베이스 혹은 데이터 스토리지 시스템으로 마이그레이션
    - 테스팅, 모니터링, 디버깅을 위한 새로운 도구 혹은 방법론 도입
    - 성능, 유지보수성, 확장성 개선을 위한 기존 코드 리팩토링
    - 클라우드 기반 시스템 같은 새로운 배포 인프라스트럭처로 마이그레이션
    - 새로운 기능 혹은 비즈니스 요구사항을 지원하기 위한 애플리케이션 아키텍처 업데이트
    - 위협 혹은 취약성으로부터 보호하기 위한 새로운 보안 지표 구현
    - 기타

기술적 마이그레이션은 때로 복잡하고 많은 시간이 소요될 수 있다
세심한 계획, 테스팅, 실행을 통해 매끄러운 전환을 보장해야 하기 때문이다
여러 팀 혹은 이해관계자(개발자, QA 엔지니어, 프로젝트 관리자, 비즈니스 분석가 등)의 협업이 필요할 수도 있다

    - 다양한 마이그레이션 전략
        : 대규모의 레거시 자바스크립트 웹 애플리케이션들을 유지하고 업그레이드하는 태스크는 엄두가 나지 않는 일일 수 있다
        : 특히 애플리케이션들이 오래된 라이브러리나 프레임워크를 사용해 구현되었고, 코드가 이리저리 뒤엉켜 있으며 문서화가 잘 되어 있지 않을 때 더욱 그렇다
        : 이런 애플리케이션의 유지보수와 마이그레이션을 위한 여러 접근법에 관해 살펴보고 각각의 장단점을 논의해본다
            
            - 좋은 마이그레이션
                : 좋은 마이그레이션은 애플리케이션 코드를 완전히 새롭게 재작성하는 것, 모든 컴포넌트가 새로운 프레임워크 혹은 기술로 완전히 이전되는 것을 포함한다
                : 개발자들은 이 접근법을 화용하면 완전히 새롭게 시작할 수 있고, 현대적인 도구와 기법들의 장점을 취하고, 보다 효율적인 애플리케이션을 만들 수 있다

                : 하지만 코드를 완전히 새롭게 재작성하는 것은 많은 시간과 노동이 소요되며 애플리케이션의 가용성 측면의 문제를 일으킬 수 있다
                : 이 방법론은 작은 프로젝트, 덜 중요한 애플리케이션 혹은 자주 변경되지 않는 프로젝트에 적합하다

            - 빠른 마이그레이션
                : 빠른 마이그레이션은 완전히 재작성하는 접근법의 대안을 제공한다. 빠른 마이그레이션에서는 애플리케이션을
                  부분 혹은 조각으로 나누고 각 부분을 점진적으로 마이그레이션한다 
                : 개발자들은 마이그레이션 된 컴포넌트가 컴파일되면 릴리스할 수 있기 때문에 빠른 피드백을 얻을 수 있고 애플리케이션을 사용할 수 없는 시간을 줄일 수 있다

                : 이러한 장점에도 불구하고 빠른 마이그레이션 도구, 라이브러리, 의존성, 프레임워크의 충돌을 일으킬 수 있다
                : 또한 동일한 도구의 다른 버전을 지원하는 것은 문제를 일으킬 수 있다. 특히 CSS cascade logic 같은 글로벌 정책을 적용하는 경우에 그렇다

            - 교살자 애플리케이션
                : 교살자 애플리케이션 접근법이라는 이름은 '교살자 무화과 패턴'에서 유래했다
                : 이 접근법은 기존 웹 애플리케이션의 경계를 식별하고 새로운 프레임워크를 사용해 새로운 기능을 추가함으로써 구식 시스템을 교살시킨다
                : 이 접근법은 통제된, 체계적인 방식으로 구식 컴포넌트를 새로운 컴포넌트로 점진적으로 대체함으로써 마이그레이션에 의한 잠재적인 리스크를 줄인다

                : 이 접근법을 따르려면 개발자들은 반드시 애플리케이션을 관련된 서로 다른 코드 조각으로 나눈 뒤 이들을 새로운 컴포넌트(e.g. 리액트 컴포넌트)로 감싸야 한다
                : 이 방법론은 어떤 동작도 추가하지 않으며 기존 콘텐츠를 렌더링하는 컴포넌트를 생성할 수 있다

            - 하이브리드 접근법 
                : 앞서 언급한 전략들을 조합하는 것이 가장 적절한 접근법일 수 있다
                : 예를 들면 개발자들은 좋은 마이그레이션 접근법을 특정 중요 컴포넌트에 대해 사용하고, 빠른 마이그레이션 접근법을 덜 중요한 컴포넌트에 사용할 수 있다                
                : 하이브리드 접근법을 사용하면 애플리케이션의 특정한 니즈나 제약에 맞춰 보다 유연한 마이그레이션 프로세스를 수행할 수 있다

            >>> 대규모의 레거시 자바 웹 애플리케이션에서 작업할 때는 세심하게 유지보수 및 마이그레이션 프로세스를 계획해야 한다
                개발자들은 애플리케이션의 구체적인 요구사항과 제약을 평가하고 가장 적절한 전략(혹은 전략의 조합)을 선택함으로써 매끄럽고 효율적인 마이그레이션 프로세스를 보장해야 한다
                이렇게 함으로써 혼란을 최소화하고, 잠재적인 리스크를 줄이고, 장기적으로 애플리케이션 성능과 사용성을 최적화해야 한다

            >>> 오래된 자바스크립트 도구를 새로운 프레임워크로 마이그레이션 하는 방법을 자세히 소개한 예시로, 
                스매싱 매거진에 실린, 'How to Migrate From jQuery To Next.js'를 참조하면 많은 도움이 될 것이다

    - 마이그레이션 전략
        : 좋은 마이그레이션 전략은 이상적으로 포괄적이고 체계적인 접근법을 포함해야 하는데, 주로 다음과 같은 핵심 요소들을 포함한다
            - 마이그레이션 범위를 이해한다
                : 기술적인 마이그레이션에 뛰어들기 전에 마이그레이션 범위를 이해해야 한다.
                : 마이그레이션할 컴포넌트 혹은 기능, 관련된 기술, 애플리케이션 아키텍처, 성능 및 사용자 경험에 미칠 영향을 식별한다

            - 마이그레이션 계획을 세운다
                : 마이그레이션 범위를 식별했다면 마이그레이션 계획을 세울 수 있다. 여기에는 마이그레이션 수행 단계, 타임 라인, 필요한 리소스 정의 등이 포함된다
                : 실제적이고 달성할 수 있는 계획을 세우는 것이 중요하며, 마이그레이션의 복잡도와 잠재적인 리스크 및 어려움을 고려해야 한다
                : 마이그레이션 계획은 코드는 물론 데이터베이스/스키마 마이그레이션 및 이들 사이의 의존성을 모두 포함한 마이그레이션 단계를 커버해야 한다

            - 점진적인 마이그레이션을 구현한다
                : 애플리케이션 중단 등의 혼란을 최소화하고 에러나 버그의 리스크를 줄이기 위해서는 점진적인 마이그레이션을 구현해야 한다
                : 한 순간에 애플리케이션의 작은 부분만 마이그레이션하고, 각 조각을 충분히 테스팅하고 배포한 뒤 다음 단계를 진행해야 한다

            - 성능을 모니터링하고 최적화한다
                : 마이그레이션 프로세스를 진행하는 동안 애플리케이션의 성능을 모니터링하고 최적화하는 것이 중요하다
                : Chrome DevTools 같은 도구를 사용해 성능 병목을 식별 및 최적화하고, 지연 로딩과 코드 분할 같은 기법을 구현해 새롭게 마이그레이션한 코드와 컴포넌트의 성능을 개선하라

            - 충분히 테스트한다
                : 테스팅은 모든 기술적 마이그레이션에서 대단히 중요하다. 각 컴포넌트를 충분히 테스트한 뒤 다음 단계를 진행해야 한다
                : 통합 테스팅을 수행해 조합된 컴포넌트들이 함께 올바르게 기능하는 것을 보장하라

            - 이해관계자들고 소통한다
                : 마이그레이션 프로세스를 진행하는 동안 최종 사용자, 개발자, 관리자를 포함한 이해관계자와 소통해야 한다 
                : 마이그레이션 진행에 대한 정기적인 업데이트를 제공하고, 질문이나 우려사항이 발생하면 이를 해결하고, 피드백을 제공함으로써 
                  마이그레이션이 비즈니스와 사용자의 니즈를 만족시키고 있음을 보장해야 한다

            >>> 위 원칙들과 전략들을 따름으로써 혼란을 최소화하고, 리스크를 줄이고, 마이그레이션이 비즈니스와 최종 사용자의 니즈를
                만족시킴을 보장하면서, 대규모 애플리케이션의 기술적 마이그레이션에 접근할 수 있다

    - 코드 모드
        : 대규모 애플리케이션을 마이그레이션할 때, 모든 코드 조각을 수동으로 업데이트해야 한다면 많은 시간이 소요될 뿐만 아니라 에러 발생 가능성도 높아진다                
        : 코드 모드는 자바스크립트 애플리케이션의 코드 변경 프로세스를 자동화하는 스크립트를 뜻하며, 코드 수정 프로세스를 크게 간소화한다
        : 코드 모드는 코드베이스를 스캔하고 필요한 변경을 자동 수행함으로써 마이그레이션의 특정 측면을 자동화할 수 있다
        : 이를 활용하면 구문 업데이트, 변경 사항 임포트, 구성 파일 업데이트 등을 수행할 수 있다
            * 예시 - 모든 상대 임포트를 절대 임포트로 변경하기
                : 많은 상대 임포트를 사용한 파일을 많이 포함한 대규모 자바스크립트 베이스가 있다고 가정
                    [XYZ를 상대 경로로 임포트하기]
                        import XYZ from '../../../../components/XYZ'
                
                : 프로젝트 규모가 커짐에 따라 상대 경로는 번거롭고, 가독성이 떨어지는 경우가 많다
                : 마이그레이션 프로세스를 진행하면서 scr/ 디렉토리 안의 모든 상대 임포트를 절대 임포트로 변경해
                  보다 적절한 모듈 해결 구성을 갖고자 한다고 가정
                    [XYZ를 절대 경로로 임포트하기]
                        import XYZ from 'src/components/XYZ'

                : 이를 위해서는 먼저 다음을 수행하는 코드 모드 스크립트를 작성할 수 있다
                    - 발견
                        : 상대 경로 임포트 구문을 가진 모든 파일을 식별한다
                    - 경로 분석
                        : 현재 파일 경로와 상대 임포트 경고를 분석하고 절대 경로를 계산한다
                    - 대체 
                        : 상대 경로를 계산한 절대 경로로 대체한다

                    * 깃허브 사용자인 Phenax는 이를 수행하는 스크립트를 작성해 gist에 공개했다
                        absolute-import-codemod-transform.js 참고

                    - 코드 모드 스크립트가 준비되었으면, 페이스북 팀이 제공하는 jscodeshift 툴킷을 사용해 여러 자바스크립트 파일과
                      타입스크립트 파일을 대상으로 이 코드모드 스크립트를 실행한다
                        * jscodeshift CLI 명령어로 코드모드 스크립트 실행하기
                            jscodeshift -t ./absolute-import-codemod-trasnform.js src/**/*.js
                    - 올바르게 실행하면 위 명령어는 자동으로 모든 일치하는 파일을 업데이트한다. 
                      상대 경로는 절대 경로로 변환되므로 수작업으로 모든 파일을 변경할 필요가 없다

            * 예시 - ES6 클래스를 함수형 컴포넌트로 변환하기
                : 대규모 코드베이스를 다룰 때, ES6 클래스를 리액트의 함수형 컴포넌트로 변환하는 태스크는 코드모드를 활용할 수 있는 또 다른 훌륭한 유스케이스이다
                : 이 변환을 통해 코드를 간소화할 수 있고, 모던 리액트 프랙티스들을 보다 많이 활용할 수 있다
                  (클래스 기반 컴포넌트는 컴포넌트를 정의하는 방식으로 더 이상 권장되지 않기 때문이다)

                : 모든 클래스 기반 컴포넌트를 함수형 컴포넌트로 변환하는 코드모드를 작성하는 것은 클래스와 기능 함수의 구조와 동작에 따라 어려울 수 있다
                : 이를 간단히 하기 위해 render() 메소드와 안전한 속성(정적 속성 혹은 props)만 갖고 있으며, refs는 사용하지 않는 ES6 클래스만 함수형 컴포넌트로 변환하는 코드모드 스크립트를 작성한다
                    * ES6 클래스 컴포넌트 변환 예시
                        - 발견
                            : 코드베이스에서 모든 ES6 클래스 컴포넌트를 식별한다
                        - 분석
                            : 식별한 클래스 컴포넌트의 구조를 분석해 변환을 위한 조건을 만족하는지 결정한다
                            : render() 메소드 및 defaultProps/propType 같은 정적 속성을 포함하고 있는지와
                              해당 클래스가 refs, states, render() 이상의 라이프사이클 메소드 같은 복잡한 기능을 사용하지 않는지 확인한다
                        - 변환
                            : 식별된 클래스 컴포넌트를 함수형 컴포넌트로 변환한다

                        - 위 코드모드를 구현한 의사 코드는 canConvertToFunctionalComponent 참조

                > 코드모드는 프레임워크 혹은 라이브러리의 메이저 버전 사이에서 마이그레이션을 할 때 특히 유용하다
                  메이저 버전 업데이트들은 중요한 문법 변경, API 변경, 다른 큰 변경들을 포함하는 경우가 많다
                  코드모드는 이런 변경의 많은 부분을 자동화함으로써 마이그레이션 프로세스를 빠르고, 더 일관성 있고, 에러가 덜 발생하도록 돕는다

                > 코드모드는 코드 마이그레이션을 쉽게 할 수 있게 도울 뿐만 아니라 코드 리팩토링이나
                  여러 코드베이스에 모범 사례를 적용하는 태스크에도 유용하게 사용할 수 있다

    - 생성형 AI의 역할
        : 생성형 AI는 인공지능의 한 유형으로 텍스트, 이미지, 코드, 음악에 이르기까지 새로운 콘텐츠를 생성할 수 있는 능력을 가지고 있다
        : 생성형 AI는 방대한 양의 기존 예시 데이터셋을 활용해 학습하고, 학습한 정보를 사용해 새로운 오리지널 정보를 생성한다
        
        : 생성된 정보는 학습에 사용했던 입력의 스타일 혹은 콘텐츠와 유사하다. ChatGPT, 제미나이, 깃허브 코파일럿, 구글의 Project IDX
          같은 도구들은 생성형 AI 도구의 예로, 이들은 최근 몇 년 사이에 큰 인기를 얻었다
        : 생성형 AI는 코드 생성, 코드 자동 완성, 코드 번역 같은 기능을 제공하며, 코드 마이그레이션에 큰 도움을 준다

        : 코드 생성
            - 생성형 AI 도구를 사용하면 자연 언어 프롬프트를 기반으로 새로운 코드를 생성할 수 있으며
              마이그레이션 프로세스를 진행하는 동안 대상(프로그래밍) 언어로 빠르게 새로운 코드를 작성할 수 있다
            - 이는 때로 개발자들의 시간과 수고를 절약하게 해주는데, 개발자들은 수동으로 전체 코드 베이스를 재작성하지 않아도 되기 때문이다
              이런 도구의 예로는 OpenAI의 ChatGPT를 들 수 있다

        : 코드 자동 완성
            - 생성형 AI 도구들은 부분적으로 작성된 코드를 자동 완성할 수 있다
            - 개발자들이 코드 마이그레이션 과정에서 간극을 채우거나 기존 코드를 새로운 언어나 프레임워크에 맞게 조정해야 할 때 유용하게 사용할 수 있다
            - 깃허브 코파일럿 같은 도구들은 OpenAI의 Codex model을 사용해 개발자의 에디터에서 즉시 코드 제안을 제공한다

        : 코드 번역 
            - 생성형 AI 모델은 한 프로그래밍 언어의 코드를 다른 프로그래밍 언어의 코드를 번역할 수도 있으며, 
              이는 언어를 변경하는 코드 마이그레이션 상황에서 매우 유리하다
            - 이 모델들은 소스 코드의 컨텍스트를 이해하고 언어적으로 동등한 코드를 대상 언어로 구성한다
              깃허브 코파일럿 등을 활용해 자바스크립트 코드를 파이썬으로 변경하는 등의 행위가 가능하다

        >>> 생성형 AI는 새로운 기술이지만 코드 마이그레이션에 드는 수작업 노력과 시간을 줄이는 기능들을 제공한다
            하지만 이 기술을 사용하는 데는 몇 가지 어려움과 제한도 있다
                - 생성된 코드가 항상 최적이거나 정확한 것은 아니므로, 사람이 직접 리뷰와 수정을 해야할 수 있다
                - 생성형 AI 모델에게 복잡한 알고리즘을 학습, 정제하도록 하려면 많은 양의 고품질 데이터가 필요하다
                - 이 기술은 새롭고 여전히 진화하고 있으므로, 다양한 마이그레이션 시나리오마다 그 효과는 크게 다를 수 있다

                >>> 생성형 AI는 코드 마이그레이션에서 사용할 수 있는 강력한 도구이지만, 사람의 전문성을 대신하는 것이 아니라 보조하는 목적으로 사용해야 한다.
                    이 도구들은 마이그레이션 프로세스의 일부를 상당히 가속화할 수 있지만, 한편으로 생성된 코드와 코드 변경 사항은 사람이 철저하게 리뷰하고 검증한 뒤에 적용해야만 한다
                                   