[타입스크립트]
타입스크립트는 자바스크립트 코드를 보다 안전하게 만드는 데 도움을 주는 정적 타입 언어로, 마이크로소프트가 발표했다
타입스크립트의 주요한 기능은 코드의 변수, 매개변수, 함수에 타입을 지정할 수 있다는 것이다
런타임(코드가 실행되는 시점)이 아닌 컴파일 타임(코드가 컴파일 되는 시점)에 타입을 체크하는 자바스크립트의 슈퍼셋이다

    - 타입 안정성
        : 타입스크립트의 가장 눈에 띄는 기능은 정적 타입 체킹으로, 이는 런타임이 아닌 컴파일타임 동안 타입 관련 에러를 잡아내는 데 도움을 준다
          (이를 이해하기 위해서는 자바스크립트가 동적 타입 언어라는 점부터 이해해야 한다)
        : 자바스크립트에서는 특정 데이터 타입을 변수에 할당한 뒤 다른 데이터를 같은 변수에 할당할 수 있다
        : 예를 들어 number라는 변수를 생성한 뒤 5라는 숫자로 해당 변수를 초기화할 수 있다  

        : 자바스크립트는 변수에 대해 고정된 데이터 타입을 강제하지 않는다. 변수의 타입이 선언되면 변경되지 않는 강타입 언어와 달리,
          자바스크립트는 변수의 타입 변경을 허용하는데 이 유연함은 장점인 동시에 단점이기도 하다
        
        : 장점으로는 개발자들이 코드를 보다 빠르고 쉽게 작성할 수 있다는 점이다. 변수를 선언할 때 변수의 타입을 명시적으로 지정하지 않아도 되며,
          타입을 뒤섞은 동작(문자열을 숫자에 더하는 등)은 즉각 에러를 유발하지 않는데 이러한 동적 타이핑은 초기 개발 프로세스의 속도를 높인다

        : 반면에 단점은 의도치 않은 버그를 야기한다는 것이다. 변수가 예상치 못하게 타입을 변경하거나 특정한 타입을 기대하는 함수가 다른 타입을 받으면
          그 결과는 예측하기 어려워진다. 에러는 런타임이 되어서야 나타날 수 있으며, 이런 에러는 개발 프로세스를 진행하는 동안에는 잡아내기 어렵다
          이는 기능이 기대와는 다르게 작동하는 시나리오로 이어질 수 있고, 디버깅은 보다 어려워진다

        : 자바스크립트는 타입스크립트의 등장으로 정적 타이핑을 도입, 양쪽의 장점을 모두 활용할 수 있으며,
          개발자들은 선택적으로 타입 어노테이션을 사용해 자바스크립트 코드를 작성할 수 있다

        : 타입스크립트는 명시적으로 그 정적 타입을 지정하지 않아도 타입을 인식한다
        : 타입스크립트는 코드를 자바스크립트로 컴파일할 때(즉, 컴파일타임에) 작성한 코드에 이슈가 있음을 인식한다
        : 이는 안전성과 예측성이라는 이점을 주며, 잠재적인 타입 관련 에러를 런타임이 아닌 개발 중 컴파일타임에 잡아낼 수 있다

        : 타입스크립트는 타입 안정성과 함께 다음의 이점도 제공한다
            - 더 나은 개발자 경험  
                : VSCode 같은 에디터들은 타입스크립트 코드에서 사용할 수 있는 개선된 IntelliSense, 자동 완성 기능, 리팩토링 기능을 제공한다
            - 쉬운 유지보수
                : 프로젝트 규모가 커지면 의도하지 않게 뭔가를 망가뜨리지 않으면서 변경하기 어렵다
                : 타입스크립트의 정적 타이핑은 퇴행적인 버그와 이슈를 유입시키지 않으면서 쉽게 코드베이스를 탐색하고 리팩토링할 수 있게 한다
            - 보다 나은 협업
                : 타입과 타입 정의의 자기 설명적인 특성으로, 타입스크립트를 사용하면 다른 사람들이 작성한 코드를 쉽게 이해할 수 있다

    - 빌드 도구와 타입스크립트
        : 타입스크립트가 단지 개발 도구는 아니라는 점을 주목해야 한다
        : 타입스크립트 자체는 브라우저가 이해하지 못하기 때문에 반드시 유효한 자바스크립트를 컴파일해야 한다.
        : 대규모 리액트 애플리케이션에서는 Vite나 Webpack 같은 빌드 도구를 사용해 이 컴파일 과정을 수행한다
        : 해당 빌드 도구들은 esbuild나 ts-loader 같은 도구를 활용해 타입스크립트 코드를 평이한 자바스크립트 코드로 트랜스파일한다

        : 새로운 리액트 타입스크립트 애플리케이션을 시작한다면 Vite나 Next.js 같은 프레임워크 사용을 권장한다
        : 이들은 기본적으로 타입스크립트를 지원하며, 이 도구를 사용하면 타입스크립트 컴파일러나 Webpack을 직접 설정할 필요가 없다
        : 타입스크립트 구성 파일(tsconfig.json)만 만들면 프레임워크가 나머지 작업은 알아서 해준다

    - 구성과 린팅
        : tsconfig.json
            - tsconfig.json 파일은 타입스크립트 애플리케이션의 루트에 만들고 유지하는 JSON 파일이며, 타입스크립트 프로젝트의 상위 디렉토리임을 나타낸다
            - 이 파일을 사용해 타입스크립트 구성을 커스터마이즈하고 타입스크립트 컴파일러가 프로젝트를 컴파일하는데 사용하는 옵션을 안내한다
                * 리액트 애플리케이션을 위한 tsconfig.json 예시
                    {
                        "compileOption": {
                            "target": "ES6",
                            "module": "CommonJS",
                            "jsx": "react",
                            "outDir": "./dist",
                            "rootDir": "./src",
                            "strict": true,
                            "esModuleInterop": true,
                            "skipLibCheck": true,
                            "forceConsistentCasingInFileNames": true
                        },
                        "include": ["src/**/*.ts", "src/**/*.tsx"],
                        "exclude": ["node_modules"]
                    }
                
            - 위 구성 예시에서 사용한 옵션들은 다음과 같다 
                : target > 대상 ECMA 스크립트의 버전 (e.g. ES6 등)
                : module > 모듈 시스템, CommonJS 등 
                : jsx > JSX 파일 처리 메소드
                : outDir > 컴파일된 자바스크립트 파일을 저장할 디렉토리
                : rootDir > 입력 파일의 루트 디렉토리
                : strict > 모든 엄격한 타입 옵션을 활성화하는 플래그 
                : esModuleInterop > 생성된 코드에서 ES6 스타일 임포트/익스포트를 허요하는 설정
                : skipLibCheck > 선언 파일에 대한 타입 체킹을 건너뛰는 플래그
                : forceConsistentCasingInFileNames > 파일 이름의 대소문자 일관성을 보장하는 체크 옵션
                : include > 프로그램에 포함할 파일명 혹은 패턴의 배열
                : exclude > include 해결할 때 배제할 파일명 혹은 패턴의 배열

                > 앞에서 true로 설정한 strict 옵션은 다양한 타입 체킹 동작을 활성화함으로써 타입 시스템을 보다 견고하게 만든다
                > 엄격한 체크의 일부 항목 활성화하고 싶다면 strict 옵션을 비활성화한 뒤 수동으로 원하는 개별 옵션을 설정하면 된다
                    * 개별 타입 체킹 옵션 수동 활성화하기
                        {
                            "compilerOptions": {
                                // ...
                                "strict": false,
                                "noImplicitAny": true,
                                "strictNullChecks": true,
                                // ...
                            },
                            // ...
                        }

                : noImplicitAny와 strictNullChecks 옵션은 이런 개별 타입 체킹 옵션으로, 이들은 개별적으로 활성화해 타입 시스템의 특정 측면을 강제할 수 있다
                : noImplicitAny는 타입을 갖지 않는 모든 변수 혹은 매개변수(타입스크립트가 타입을 추론할 수 없는)에 명시적으로 타입을 선언하지 않으면 에러로 강제한다
                  런타임 에러를 발생시킬 수 있는 타입이 정의되지 않은 변수를 잡아내는 데 도움을 준다
                : strictNullChecks는 엄격한 null 혹은 undefined 체크를 강제한다. 다시 말해 null이나 undefined 타입을 명시적으로 선언하지 않고는 변수에 할당할 수 없다
                  이는 일반적인 null 참조 에러를 방지하는 데 도움이 된다

                > 그 외 사용할 수 있는 모든 옵션과 그 역할을 확인하고 싶다면 타입스크립트 문서의 TSConfig Reference를 참조

    - ESLint
        : 린팅은 코딩 표준을 강제함으로써 개발을 진행하는 동안 에러/불일치를 식별하는 프로세스로 코드 품질을 유지하는 데 매우 중요하다
        : 타입스크립트(및 자바스크립트) 코드 린팅에서는 ESLint 라이브러리를 널리 사용한다.
          ESLint는 자유롭게 구성할 수 있고, 구현이 간단하며, 다양한 기본 규칙 집합을 포함한다
        : 타입스크립트 프로젝트에 ESLint를 설정하고 구성하려면 몇 가지 의존성을 설치해야 한다
            - eslint: 핵심 ESLint 라이브러리다
            - @typescript-eslint/parser: ESLint를 활성화해 타입스크립트 코드를 분석하는 파서
            - @typescript-eslint/eslint-plugin: @typescript-eslint/parser와 함께 사용할 수 있는 플러그인. 타입스크립트를 위한 다양한 ESLint 규칙을 통합한다
                * ESLint 의존성 설치하기     
                    : yarn add -D eslint \ @typescript-eslint/parser \ @typescript-eslint/eslint-plugin

        : 필요한 패키지를 설치했다면 .eslintrc 파일을 리액트 타입스크립트 프로젝트 루트에 만들고 애플리케이션을 위한 린팅 규칙을 생성한다
        : .eslintrc 내 구성 옵션의 역할은 다음과 같다
            - parser: ESLint에서 @typescript-eslint/parser를 사용하고 지정한다
            - parserOptions: ESLint가 지원할 언어 옵션을 지정한다
            - extends: @typescript-eslint/recommended 플러그인에 지정된 린팅 규칙을 확장한다
            - rules: 애플리케이션에서 사용할 특정 ESLint 규칙을 지정한다

    - 리액트 + 타입스크립트
        : 리액트와 타입스크립트를 조합하면 대규모 애플리케이션 개발을 위한 강건한 환경을 구성할 수 있다
        : 이 조합을 통해 보다 효율적이고, 가독성이 높고, 유지보수 가능한 리액트 코드를 작성하는 다양한 패턴을 구성할 수 있다

            - 함수형 컴포넌트에서 props 타입 정의하기   
                : 리액트에서 함수형 컴포넌트를 정의할 때는 타입스크립트 인터페이스 혹은 타입을 사용해서 컴포넌트가 받는 props를 정의하는 것이 좋다            

    - children 타이핑하기
        : children은 특별한 prop으로 상위 컴포넌트에서 하위 컴포넌트로 JSX 요소를 전달할 때 사용한다. 기본적으로 children prop은 모든 타입이 될 수 있다
        : 하지만 때로 children prop이 특정 타입의 요소만 받도록 하는 것이 유용하다

        : React.ReactNode는 children prop에 사용할 수 있는 매우 일반적인 타입으로 모든 유효한 리액트 하위 요소를 수용한다
        : 문자 및 숫자와 같은 기본값, 리액트 요소, 이 타입을 포함하는 배열이나 프래그먼트를 포함한다           

        : React.ReactElement는 children prop으로 사용할 수 있는 보다 구체적인 타입이며, 전형적으로 JSX를 통해 생성된 리액트 요소 객체를 나타낸다
        : children이 텍스트나 배열이 아니라 단일 리액트 요소가 되도록 제한하고 싶을 때 유용하다     

        > 각 자식에게 다른 타입을 제공함으로써 컴포넌트가 사용할 수 있는 children의 구체적인 형태를 지정할 수 있다
            interface Props {
                children: [
                    React.ReactNode,
                    number,
                    React.ReactElement
                ]
            }

    - 리액트 훅
        : 리액트 훅을 사용하면 함수형 컴포넌트의 상태와 다른 리액트 기능들을 활용할 수 있다
        : 리액트 라이브러리가 제공하는 핵심 훅을 사용한다면 몇 가지 패턴과 프랙티스를 따르는 것도 좋다
        : 이를 통해 타입 안전한 리액트 코드를 작성하는 방법을 익힐 수 있다

            - useState
                : useState 훅은 가장 기본적인 훅이며 이를 사용하면 함수형 컴포넌트의 로컬 상태를 관리할 수 있다
                : 타입스크립트는 useState에 전달되는 초깃값을 사용해 상태의 타입을 추론할 수 있다 
                  (그러나 직접 상태의 타입을 명확하게 정의할 수도 있다)
                
                : 타입이 맞지 않은 값으로 설정하려고 하면 타입스크립트는 이를 에러로 표시한다
                : 이러한 타입 체킹을 통해 해당 상태가 기대한 데이터 타입과 일관성을 유지함을 보장할 수 있다
                : 이는 버그를 방지하는 동시에 코드 품질을 향상한다

            - useReducer
                : useReducer 훅을 사용하면 함수형 컴포넌트의 보다 복잡한 상태 로직을 관리할 수 있다
                : useState 훅과 비슷하지만 복잡한 상태 전환을 처리하거나, 최적화를 구현하거나, 보다 구조화된 접근법을 요구하는 
                  상태 관리를 수행하는 경우에는 useReducer 훅을 사용하는 것이 좋다

                : 타입스크립트를 사용하면 reducer 함수의 상태와 동작에 대한 유형을 정의한 다음 useReducer 훅에서 사용할 수 있다 
                : 타입스크립트 환경에서 dispatch 함수를 useReducer와 함께 올바르지 않게 사용하면, 타입스크립트는 에러를 발생시킨다
                : 이는 가져온 액션과 정의된 액션의 타입의 일관성을 보장하고자 할 때 유용하다 
                  (타입과 일치하지 않는 액션을 가져오려고 하면 타입스크립트는 에러를 발생시킨다)
                > reducer() 함수는 처리 가능하도록 설계된 액션만 받아서 처리할 수 있음을 보장한다
                  따라서 상태 관리 면에서 무결성과 예측성을 유지할 수 있다

            - useContext
                : useContext 훅을 사용하면 애플리케이션의 모든 위치에서 접근할 수 있는 전역 상태를 만들 수 있다
                : 타입스크립트를 사용하면 컨텍스트 상태 타입을 정의할 수 있다         

            > 타입스크립트는 위 훅과 유사한 형태로 useEffect, useMemo, useCallback 같은 다른 핵심 리액트 훅을 적용할 수 있고,
              이를 통해 그들의 입력과 출력의 올바른 타입을 보장할 수 있다. 핵심 훅뿐만 아니라 타입스크립트는 커스텀 훅의 타입을 지정하는데 효과적이며,
              다양한 컴포넌트와 컨텍스트에 걸쳐 커스텀 훅을 올바르게 사용하도록 할 수 있다

            - 커스텀 훅
              : 커스텀 훅은 사용자가 직접 만들 수 있는 함수이며 이를 활용하면 여러 컴포넌트 사이에서 상태를 갖는 로직을 추출하고 재사용할 수 있다
                * useToggle 참조                         

            - 이늄
              : 타입스크립에서는 이늄을 사용하면 관련된 값의 집합을 조직화할 수 있으며, 대규모 리액트 애플리케이션의 가독성과 유지보수성을 개선할 수 있다
              : 이늄을 사용하면 유사한 분류에 속하는 값들을 그룹핑할 수 있어 코드를 보다 직관적으로 만들 수 있기 때문에 이질적이고,
                구조화되어 있지 않은 값을 사용하면서 발생할 수 있는 에러를 줄일 수 있다
              : 결과적으로 값이 하나의 중앙 집중 관리되는 위치에서만 변경되기 때문에 보다 쉽게 값을 리팩토링 및 업데이트할 수 있다       
              
              : 모던 타입스크립트에서는 enum 키워드 대신 as const 어셔션을 사용해서 이늄을 만들 수 있다
              : as const는 상태 객체의 각 속성을 리터럴 타입으로 만든다. 이를 활용하면 고정된 값을 갖는 읽기 전용 객체를 만들 수 있다
              : 이는 이늄과 유사하며 실젯값을 직접 사용하고자 할 때 유용하며, 이 값들이 변경되지 않음을 보장한다

              : 이늄은 다른 UI 컴포넌트 혹은 요소를 리액트 애플리케이션의 특정한 상태 혹은 조건에 기반해 렌더링할 때도 효과적이다
              : 예를 들어 LoadingIndicator 라는 컴포넌트를 만들고, status 상수 이늄을 사용해 다양한 UI 상태(로딩, 성공, 에러)를 간략하고 타입 안전한 방법으로 관리한다         
                * LoadingIndicator.tsx 참고

            - 제네릭 컴포넌트
              : 타입스크립트에서 제네릭은 단일 타입이 아닌 다양한 타입에 대해 작동하는 재사용 가능한 함수를 만들 수 있게 하는 기능이다
              : 리액트 컴포넌트에 제네릭을 사용하면 컴포넌트가 다른 형태의 데이터(e.g. props)를 받게 할 수 있다
              
              : 먼저 단일 컴포넌트를 사용해 여러 데이터 타입을 받는 것을 처리해보자 (DataTable.tsx 참고)
              : 다른 형태의 데이터를 위해 동일한 컴포넌트를 재사용하고 싶다면 어떻게 할까?
              : 만약 기존의 사용자 데이터 대신 제품 정보의 데이터를 렌더링하고 싶다면 '유니언 타입'을 사용할 수 있다

              : 유니언 타입을 도입하면 컴포넌트가 다양한 데이터 형태를 지원하도록 유연성을 더할 수 있다
              : 하지만 해당 방식은 계속해서 다른 데이터 타입을 추가해야 한다면 잘 확장할 수 없다
              : 더 많은 데이터 형태가 추가되거나 기존 데이터 형태가 변경되면 유지보수 비용이 기하급수적으로 늘어나기 때문이다

              : 컴포넌트가 다양한 여러 데이터 형태를 받을 수 있게 하는 또 다른 접근 방법은
                간단히 any 타입을 사용해서 컴포넌트가 모든 형태의 데이터를 받을 수 있게 선언하는 것이다
              : any 타입을 사용하는 것은 적응적인 컴포넌트를 만드는 쉬운 해결책처럼 보일 수 있지만, 타입스크립트가 제공하는 이점을 누리지 못하게 된다
              : 다시 말해, any를 사용하면 타입 안전성 체크를 할 수 없게 되며 이는 잠재적으로 런타임 에러를 발생시킬 수 있다
              : 이때 타입스크립트 제네릭을 활용하면 타입 안전성을 유지하면서 여러 데이터 형태를 처리하는 유연성을 확보할 수 있다     

              : 타입스크립트는 명시적으로 타입을 지정할 것을 요구하지 않고도 데이터의 형태를 추론할 수 있다
              : 컴파일러는 데이터의 타입을 명싲거으로 지정하지 않아도 DataTable 컴포넌트에 전달한 데이터의 형태가 일치하는지 확인한다
              : 원한다면 타입 추론을 제거하고 명시적으로 데이터 prop의 타입을 정의할 수 있다

              : 컴포넌트 사용에 대한 엄격한 계약을 강제해야 하는 경우도 종종 유용하다. 컴포넌트의 소비자는 기대되는 데이터의 형태를 
                정확하게 인지할 수 있기 때문이다
              
              >>> 리액트 및 타입스크립트 컴포넌트 패턴들에 관해 알고 싶다면 <React TypeScript Cheatsheets>를 참고할 수 있다.
                  오픈소스 자료이며 몇 가지 추가 예시와 팁들을 제공해준다

    - 선언 파일들
      : 타입스크립트가 가진 잠재력을 완전히 활용하려면 사용하는 서드파티 라이브러리 역시 동적 타입을 지원해야 한다
      : 하지만 사용할 만한 대부분의 서드파티 라이브러리들은 네이티브 자바스크립트(e.g. lodash) 혹은 자바스크립트 확장으로만 작성되어 있다
      : 이러한 경우, 타입스크립트 선언 파일을 사용한다

      : 선언 파일은 타입스크립트로 작성되지 않은 모듈 혹은 라이브러리의 타입을 선언한 파일이다
      : 이 파일들은 '.d.ts' 확장자를 가지며 구현 코드가 없는 라이브러리의 함수, 클래스, 변수에 관한 타입 정보를 포함한다
      : 이와 관련된 타입을 갖지 않는 라이브러리를 임포트해 사용하는 경우 커스텀 선언 파일을 만들거나 'DefinitelyTyped' 저장소로부터 적절한 선언 파일을 임포트할 수 있다

       - DefinitelyTyped
        : DefinitelyTyped는 널리 알려진 다양한 자바스크립트 라이브러리에 대한 고품질 타입스크립트 선언 파일을 포함하고 있는 저장소이다
        : 이 저장소는 커뮤니티가 주도해 관리하고 있으며 누구나 타입 정의를 추가하거나 개선함으로써 기여할 수 있다
        : 타입 정의를 포함하지 않는 외부 라이브러리를 사용할 때는 가장 먼저 DefinitelyTyped를 호출하는 것이 좋다
        : 예를 들면 lodash 라이브러리를 사용한다면 다음을 실행해 타입 정의를 설치할 수 있다
          - 개발 의존성으로 @types/lodash 설치하기
            : yarn add @types/lodash -D
            : 이 명령을 실행하면 lodash 타입 정의가 설치되고 타입스크립트는 자동으로 프로젝트에서 이를 인식하고 활성화한다

      - 커스텀 선언 파일
        : DefinitelyTyped에서 특정한 라이브러리에 대한 타입 선언을 호스팅하지 않는다면 커스텀 선언 파일을 만들어야 할 수 있다
        : 커스텀 선언 파일을 만들려면 새로운 .d.ts 파일을 만들고 원하는 라이브러리에 대한 타입 정의를 수동으로 작성해야 한다
        : 다음은 가상의 라이브러리를 위한 커스텀 선언 파일의 기본 예시이다
          - 커스텀 선언 파일 예시, index.d.ts 참고                               

        : 커스텀 선언 파일을 생성했다면, 다음으로 타입스크립트 구성 파일을 조정해 타입스크립트가 해당 커스텀 선언 파일을 컴파일에 포함하게 해야 한다
        : 선언 파일의 경로를 추가하거나 선언 파일이 저장된 폴더를 tsconfig.json 파일의 include 옵션에 포함시키면 된다  

      - API 결과에 타입 자동 생성
        : 대규모 리액트 애플리케이션에는 리액트 앱이 API와 상호작용함으로써 데이터를 가져오거나 액션을 수행할 때가 많다
        : 이 API들은 RESTful, GraphQL, gRPC 기반, 혹은 다른 무엇일 수 있다
        : 이런 API들과 상호작용할 때 타입스크립트가 의미 있는 값을 제공할 수 있으려면, 해당 API가 반환하거나
          받는 데이터의 구조를 반영하는 타입스크립트 타입을 가져야 한다.
        
        : RESTful API와 상호작용하는 리액트 애플리케이션이 있다고 가정할 때, 이 API의 엔드포인트는 id를 제공하면, 그 id에 해당하는 특정 속성을 가진 사용자 객체를 반환한다
        : 먼저 사용자에 대해 API로부터 기대되는 데이터 구조를 반영하는 타입스크립트 인터페이스를 만들 수 있다
        : 리액트 컴포넌트에서는 ID를 통해 API로부터 사용자 데이터를 가져올 수 있다. 이 데이터를 가져와 특정 타입에 할당함으로써
          가져온 데이터가 이 타입과 일치함을 보장한다  

        : 리액트 클라이언트 애플리케이션이 서버와 몇 안 되는 엔드포인트를 사용해 상호작용한다면, 인터페이스를 수동으로 만들어도 잘 작동할 것이다
        : 하지만 엔드포인트가 많고, 데이터 구조가 복잡하고, 스키마가 변경되는 API가 많다면 이런 타입들을 처음부터 새롭게 만드는 데
          많은 시간이 걸릴 뿐 아니라 에러가 발생하기도 쉽다
        : 수작업으로 유지보수하는 것은 API와 애플리케이션 사이의 불일치를 만들고, 결과적으로 런타임 에러를 발생시키고 디버깅 시간을 증가시킨다
        : 이런 상황에서는 API로부터 타입스크립트 타입을 자동 생성하는 기능이 대단히 유용하다

        : 타입을 자동 생성함으로써 애플리케이션의 타입이 항상 API와 동기화되는 것을 보장할 수 있다
        : 이를 통해 수작업을 줄이고 올바르지 않은, 혹은 오래된 타입으로 인해 버그가 발생할 가능성을 줄인다
        : API로부터 타입스크립트의 자동 생성을 돕는 여러 도구들을 활용할 수 있다

         - GraphQL
          : GraphQL을 사용하면 스키마, 즉 데이터의 구조가 이미 잘 정의되어 있다. GraphQL은 강한 타입 언어이고
            스키마는 데이터의 형태, 관련된 타입, 이들 사이의 관계를 기술하는 계약을 제공하기 때문이다
          : GraphQL API로부터 타입스크립트 타입을 자동 생성할 때 사용할 수 있는 잘 알려진 도구로는 GraphQL Code Generator가 있다
          : 타입스크립트 코드에서 자동 생성된 타입을 임포트를 사용할 수 있고, GraphQL API와 상호작용할 때 타입 안전성을 보장할 수 있다

         - REST
          : REST는 GraphQL 같은 강한 타입 스키마를 갖고 있지 않지만, API가 OpenAPI 같은 명세를 사용해서 기술되어 있다면, 이를 사용해 타입스크립트 타입을 생성할 수 있다
          : OpenAPI는 JSON 혹은 YAML 포맷을 사용해 RESTful API를 기술하는 표준적인 방식이다
          : 엔드포인트, 요청과 응답 타입 및 API 관련 다른 정보들을 포함해 기술한다  

          : OpenAPI 명세로부터 타입스크립트 타입을 생성할 수 있는 도구로 openapi-generator가 있다
          : 이 도구는 클라이언트 라이브러리, 서버 스텁, API 문서 및 타입스크립트를 포함한 보다 다양한 프로그래밍 언어를 생성한다
          : 이후 타입스크립트 코드에서 이 타입들을 사용하면 API 요청을 만들고 응답을 처리할 때 타입 안전성을 보장할 수 있다

        - gRPC  
          : gRPC는 고성능의 오픈소스 원격 프로시저 호출 프레임워크이며 구글이 처음 개발했다
          : 전송에는 HTTP/2를 사용하고 인터페이스 기술로는 Protocol Buffer(protobuf)를 사용한다
          : protobuf는 언어에 구애받지 않는 이진 직렬화 포맷이며 마찬가지로 구글이 개발했다

          : gRPC Web은 브라우저 클라이언트용으로 gRPC를 자바스크립트로 구현한 것이며, 구글에서 내부적으로 구글 웹 애플리케이션과
            클라우드 서비스를 위한 프론트엔드 스택의 일부로 개발되었다

          : 그 결과, 리액트 애플리케이션 gRPC Web을 사용해 gRPC 서비스와 브라우저에서 직접 소통할 수 있게 되었으며
            서버와 클라이언트의 양방향 전체 통신이 가능해졌다 (protobuf를 사용해 정의한 간단한 gRPC 서비스는 gRPC.proto 참고)

          : 다양한 도구를 사용해 protobuf로부터 타입스크립트 타입을 생성할 수 있다
          : 이런 도구 중 하나인 ts-proto는 타입스크립트를 위한 관용적인 protobuf 생성기이다
          : ts-proto 도구를 .proto 파일에 대해 실행하면 gRPC 서비스를 위한 타입스크립트 타입, 클라이언트, 서버 코드를 생성한다
          : 이를 통해 타입스크립트 코드에서 자동 생성된 타입과 메소드를 임포트 및 사용해서 gRPC 서비스와 상호작용할 수 있다

          >>> API(RESTful이든 GraphQL이든 gRPC든 관계없이)로부터 타입스크립트 타입을 자동 생성하는 것은
              시간을 절약하고, 버그를 줄이고, 강건하고 타입 안전한 코드베이스를 유지하는 데 도움을 주는 효과적이고 중요한 프랙티스이다

      - 기존 리액트 애플리케이션을 타입스크립트로 마이그레이션하기
        : 애플리케이션 규모에 따라 기존 리액트 자바스크립트 애플리케이션을 타입스크립트로 마이그레이션하는 것은 버거운 작업일 수 있다
        : 타입스크립트가 식별할 타입 에러를 이해하고 해결하는 과정을 포함하며, 이는 원래의 자바스크립트 코드에서는 분명하게 드러나지 않을 수 있다
        : 또한 대규모 애플리케이션은 복잡한 상태와 props 구조를 가진 경우가 많기 때문에 모든 컴포넌트와 함수의 타입을 정확하게 결정하는 것은 어려울 것이다

        : 애플리케이션이 타입스크립트를 지원하지 않는 외부 라이브러리 혹은 API와 통합되면 복잡성이 늘어난다
        : 이로 인해 마이그레이션 프로세스에는 많은 시간이 소요되며 기술적으로도 많은 것이 요구된다

        : 우선 이를 염두에 두고 몇 가지 단계를 밟으면 대규모 리액트 애플리케이션을 타입스크립트로 마이그레이션하는 과정을 간단히 하는데 도움이 된다
          - 마이그레이션 계획을 세우라
            : '계획을 세운 뒤' 마이그레이션을 시작하라. 애플리케이션의 어떤 부분부터 마이그레이션할 지 결정하라
            : 예를 들면, 작고, 덜 복잡한 컴포넌트들을 마이그레이션한 두 보다 복잡하고 연결된 컴포넌트들을 마이그레이션하는 것이 쉬울 수 있다
            : 또한 팀과 소통함으로써 모두가 마이그레이션 계획을 인식하고 있는지 확인하라. 이는 다른 사람의 작업에 영향을 미칠 수 있다

          - 점진적으로 마이그레이션하라
            : 점진적인 마이그레이션은 전환에서 발생하는 복잡성을 관리하는 핵심이다
            : '애플리케이션 전체를 한번에 마이그레이션할 필요는 없다' 대신 한 순간에 한 컴포넌트 혹은 한 모듈을 마이그레이션하자
            : 이 접근법을 사용하면 마이그레이션을 진행하는 동안에도 애플리케이션이 정상적으로 기능하도록 유지하는 데 도움이 된다

          - JSDoc을 활용하라
            : JSDoc은 마크업 언어로, 이를 사용해 자바스크립트 코드에 어노테이션을 할 수 있다.
            : 기존 리액트 애플리케이션에 타입스크립트를 도입할 때 JSDoc을 사용해 코드베이스에 타입스크립트를 점진적으로 도입할 수 있다
            : JSDoc 주석을 기존 자바스크립트에 추가해 타입 어노테이션을 제공하라. 충분한 시간을 들여 필요할 때
              코드를 타입스크립트로 변환할 수 있으며, JSDoc 주석을 작성해 놓은 위치부터 타입을 정의하기 시작할 수 있다

          - 필요하다면 코드를 리팩토링하라
            : 기존 자바스크립트 코드는 종종 타입스크립트로 마이그레이션하기 쉬운 구조를 갖고 있지 않을 수 있다
            : 이런 경우에는 마이그레이션을 진행하는 동안 코드를 적절하게 리팩토링하면 도움이 된다
            : 예를 들면 큰 함수들을 작은 여러 함수들로 나누거나 프로미스 혹은 async/await 등을 사용해 콜백 기반 코드로 변환할 수도 있다
          
          - 타입스크립트를 잘 지원하는 IDE를 사용하라
            : VSCode와같이 타입스크립트를 잘 지원하는 IDE를 활용하라. 이 도구들은 자동 완성, 타입 체킹, 에러 강조 같은
              유용한 기능들을 제공하며 마이그레이션 프로세스에 큰 도움이 된다

          - 점진적으로 타입스크립트 컴파일러 옵션을 구성하라
            : 느슨한 타입스크립트 구성에서 시작하라. tsconfig.json 파일에서 엄격한 strict 옵션을 false로 설정하거나
              대부분의 엄격한 체크를 개별적으로 해제할 수 있다. 컴파일러가 보다 관대해지므로 마이그레이션을 막 시작하는 시점에는 도움이 될 것이다
            : 마이그레이션을 진행함에 따라 타입스크립트에 친숙해지면, 점진적으로 엄격한 컴파일러 옵션을 활성화하자

          - DefinitelyTyped 패키지를 설치하라
            : 잘 알려진 많은 자바스크립트 라이브러리들은 DefinitelyTyped 저장소에 정의된 타입스크립트 타입 정의를 갖고 있다
            : 마이그레이션을 시작하기 전에 사용하는 라이브러리에서 타입 정의를 사용할 수 있는 지를 확인하고, 라이브러리에 해당하는 @types 패키지를 설치한다

          - any는 최후의 수단으로 사용하라
            : 마이그레이션을 하는 동안 any 타입을 사용해 타입스크립트의 타입 체크를 건너뛰고 싶은 충동에 사로잡힐 수 있다
            : 이는 단기적으로 코드가 컴파일되게 하는 데는 도움이 되겠지만, 타입스크립트를 사용하는 목적을 망가뜨린다
            : 타입스크립트는 컴파일타임에 에러를 잡아낼 수 있는 강건한 타입 시스템을 갖기 때문이다
            : 다소 기간이 걸리더라도 변수에 적절한 타입을 정의하도록 하는 것이 옳다. any는 최후의 수단으로만 사용하자

          - 타입스크립트의 추론을 활용하라
            : 타입스크립트는 타입 추론에 대단히 뛰어나다. 많은 경우 타입스크립트가 컨텍스트로부터 타입을 추론할 수 있기 때문에
              변수에 타입을 명시적으로 정의할 필요가 없다. 이를 활용하면 마이그레이션에 소요되는 많은 시간과 노력을 절약할 수 있다

          - 빌드 도구와 테스트 도구를 업데이트하라
            : 빌드 도구와 테스트 도구가 타입스크립트를 다룰 수 있게 구성되었는 지 확인하라
            : 추가 플러그인을 설치하거나 기존 도구의 구성을 변경해서 타입스크립트를 지원하게 해야 할 수도 있다

          - CI 파이프라인을 업데이트하라
            : 지속적 통합은 개발자들이 공유된 저장소에 빈번하게(하루에 여러 번이면 더욱 좋다) 개발한 코드를 통합하는 프랙티스이다
              각 통합은 자동화된 빌드와 자동화된 테스트를 통해 검증된다
            : 타입스크립트로 마이그레이션할 때는 CI 파이프라인이 타입스크립트 컴파일 단계를 포함하게 업데이트하라.
              이를 통해 타입스크립트 에러를 개발자의 로컬 머신에서뿐만 아니라 개발 프로세스의 초반에 잡아낼 수 있다

            : 이상적으로 빌드 파이프라인은 마이그레이션 프로세스를 진행하는 동안에는 타입스크립트로 마이그레이션되지 않은 
              기존 자바스크립트에 대해서는 타입스크립트 에러/경고를 찾아내지 않는 것이 좋다

          >>> 대규모 리액트 애플리케이션을 타입스크립트로 마이그레이션하는 것은 프로세스임을 기억하자.
              한 번에 한 단계씩 진행하는 것으로 충분하다

          >>> 스트라이프(Stripe)가 자사의 가장 큰 자바스크립트 코드베이스의 수백만 라인의 코드를 
              Flow(덜 일반적으로 사용되는 자바스크립트 정적 타입 체커)에서 타입스크립트로 마이그레이션한 방법에 관해서
              <Migrating millions of lines of code to TypeScript>를 통해 소개하였다        

          >>> 타입스크립트로 마이그레이션하는 데 유용한 팁은 <React TypeScript Cheatsheet> 문서의 Migration 절을 참조할 수 있다