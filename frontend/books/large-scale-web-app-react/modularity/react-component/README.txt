[리액트에서의 컴포넌트화]
    리액트 콘텍스트에서 모듈은 종종 '컴포넌트화'라고 불리는 패턴으로 적용된다
    리액트는 본질적으로 개발자들로 하여금 컴포넌트를 사용해 생각할 것을 권장한다
    각 컴포넌트는 UI의 구분된 조각이며, 올바르게 구축한다면 애플리케이션의 다양한 부분에서 재사용할 수 있다
  
    애플리케이션 규모가 늘어나면서 컴포넌트들을 확장 가능하고 유지보수 가능한 형태로 조직화할 필요성이 생각난다
    이때 컴포넌트 라이브러리, 아토믹 설계, 도메인 주도 설계 같은 개념을 사용할 수 있다
  
[재사용 가능한 컴포넌트 식별하기]
    리액트 애플리케이션 컴포넌트화의 첫 단계는 재사용 가능한 컴포넌트를 식별하는 것이다
    컴포넌트화하기 좋은 후보는 다음과 같다
        - 버튼, 메뉴, 카드 같은 반복적인 요소들
        - 헤더, 콘텐츠영역, 푸터 같은 페이지의 구역들
        - 기능의 논리적 덩어리

[디자인 시스템을 구현하라]
    디자인 시스템은 재사용 가능한 컴포넌트, 가이드라인, 애셋의 집합이며 팀이 응집된 제품을 구축하는 데 도움을 준다
    오늘날 인기 있는 디자인 시스템은 다수 존재하는데 대표적인 예는 다음과 같다
        - 구글의 머티리얼(Material)
        - 쇼피파이의 폴라리스(Polaris)
        - 애플의 Human Interface Guidelines
        - 마이크로소프트의 Fluent Design System
    
    디자인 시스템을 구축하면 리액트 애플리케이션의 컴포넌트 설계와 개발을 표준화하는 데 도움이 된다
    또한 구글의 머티리얼 같은 기존의 오픈소스 디자인 시스템을 사용하면 잘 문서화된 컴포넌트 셋과 패턴을 제공함으로써 개발을 촉진할 수 있다
    이를 활용하면 애플리케이션의 구체적인 로직과 기능에만 집중할 수 있다

[지연 로딩]
    지연 로딩은 리소스가 필요할 때만 로딩하는 기법이다
    이는 초기(최초)에 로딩되는 리소스의 데이터양을 줄임으로써 애플리케이션의 성능을 효과적으로 개선한다

    리액트에서는 컴포넌트가 요구될 때만(즉, 지연해서) 선별적으로 로딩해서 애플리케이션의 성능과 응답성을 개선할 수 있다
    이는 리액트에서 제공하는 lazy 함수와 Suspense 컴포넌트의 도움 덕분이다
        - lazy: 요청이 있을 때 컴포넌트를 로딩할 수 있게 하는 함수
        - Suspense: 지연 컴포넌트가 로딩되는 동안 대체(fallback) 컴포넌트를 표시하기 위해 사용하는 컴포넌트 
    
    리액트에서 지연 로딩을 사용해 컴포넌트를 로딩하는 방법을 예시와 함께 살펴보자 (Post.js 참조)
    컴포넌트를 정적으로 임포트하는 기본적인 예시에서 시작하여, React.lazy()와 함께
    동적 임포트를 사용해서 컴포넌트를 동적으로 로딩하는 방법을 살펴본다

    Intersection Observer API를 사용한 지연 로딩
        Intersection Observer API는 자바스크립트 API이며 이를 사용하면 뷰포트에 어떤 요소가 표시되는 시점을 식별할 수 있다
        이는 온디맨드 코드 분할을 구현할 때 유용하다. 온디맨드 코드 분할에서는 사용자가 페이지의 특정 영역에 스크롤했을 때 코드를 로딩한다

        Intersection Observer API를 리액트 애플리케이션에서 사용하려면 고유한 커스텀 기능을 만들거나
        react-intersection-observer 같은 서드파티 라이브러리에서 이 기능을 임포트해야 한다
        (커스텀 useIntersectionObserver 훅을 사용해서 컴포넌트가 뷰포트에 들어올 때 지연 로딩하는 예시는 Post.js 참고)

        > 지연 로딩 컴포넌트는 필요할 때만 리소스를 로딩함으로써 애플리케이션의 초기 로딩을 크게 최소화하고 사용자 경험과 리소스 효율을 개선한다
          코드 분할 개념은 여기에서 한 걸음 더 나아가 애플리케이션 전체를 독립적으로 로딩될 수 있는 작은 덩어리로 나눈다
        > 모놀리식 bundle.js(한 파일 안에 모든 코드)를 작은 덩어리로 분할, 현재 페이지에 관한 코드만 로딩한다
          (적은 코드 = 낮은 네트워크 + 파싱/컴파일 코드 비용)

    코드 분할
        코드 분할은 애플리케이션 코드 전체를 보다 작은, 관리 가능한 덩어리로 나눔으로써 대규모 애플리케이션의 성능을 최적화하는 기법이다

        모듈화된 혹은 컴포넌트화된 애플리케이션 구조를 갖추는 것은 효율적인 코드 분할을 위한 토대를 닦는 것이다
        컴포넌트가 독립적이고 필요한 모든 것을 가지고 있도록 설계되면 이들을 필요할 때 로딩할 수 있는 구분된 덩어리로 분리하기 더욱 쉬워진다

        이 모듈화 접근법은 코드 분할의 밑바탕에 있는 핵심 아이디어와 완벽하게 정렬된다
        코드 분할의 목표는 전체 애플리케이션을 미리 로딩하지 않고 사용자에게 필요한 순간에 필요한 코드만 로딩하는 것이다

        리액트 애플리케이션에서 코드 분할 패턴은 공통적으로 다음으르 포함한다
            - 라우트에 따라 분할하기: 사용자의 탐색에 따라 페이지 모듈을 로딩한다
            - 컴포넌트에 따라 분할하기: 그래프나 테이블 같은 큰 컴포넌트를 지연 로딩한다
            - 온디맨드 로딩: 사용자가 버튼, 드롭다운 등을 클릭할 때 코드를 로딩한다

        코드 분할을 구현하려면 가장 먼저 애플리케이션의 크리티컬 패스를 식별해야 한다
        크리티컬 패스는 애플리케이션이 사용자에게 표시되기 전에 반드시 로딩되어야 하는 리소스의 순서를 의미한다
        
        이 크리티컬 패스를 식별함으로써 어떤 리소스를 먼저 로딩해야 하는지,
        어떤 리소스를 보다 발전된 코드 분할 기법을 사용해서 지연 로딩할 수 있는지 결정할 수 있다

        다음으로는 대규모 리액트 애플리케이션에서 발전된 코드 분할 기법에 접근하는 몇 가지 전략에 관해 살펴본다
            - 엔트리 포인트 분할
                : 엔트리 포인트는 사용자가 웹사이트를 방문했을 때 로딩되는 첫 번째 자바스크립트 파일이다
                : 엔트리 포인트 분할은 '초기 자바스크립트 파일을 작은 덩어리로 자른다'
                : 이 덩어리들은 필요할 때만 로딩되며 페이지의 초기 로딩 시간을 줄인다
                
                : 예를 들어, 다음과 같은 웹사이트가 있다고 생각해보자
                    - 하나의 home 페이지
                    - 하나의 product 페이지
                    - 하나의 contact 페이지

                : 각 페이지는 고유한 자바스크립트 코드를 갖는다. 모든 코드를 한 번에 로딩하면 초기 페이지 로딩 시간은 느려질 수 있다
                : 이때 엔트리 포인트 분할을 사용해 각 페이지에 관한 코드를 별도의 덩어리로 나눌 수 있다
                : 엔트리 포인트 분할 유형을 사용하면 사용자가 방문했을 때 다음과 같이 작동한다
                    - home 페이지: home 페이지에 관한 코드만 로딩된다
                    - product 페이지: product 페이지에 관한 코드만 로딩된다
                    - contact 페이지: contact 페이지에 관한 코드만 로딩된다

                : 이 코드 분할 유형은 더 빠르 로딩 시간과 더 나은 사용자 경험을 제공할 수 있다
                : 구체적인 각 페이지에 대해 필요한 코드만 로딩하기 때문이다. 이를 통해 중복되고 불필요한 데이터를 가져오는 양을 줄일 수 있다

            - 벤더 분할
                : 벤더 분할은 코드에서 서드파티 의존성을 분리할 때 사용하는 기법이다
                : 서드파티 라이브러리나 프레임워크를 사용하면 해당 라이브러리 코드는 우리의 자바스크립트 번들에 포함된다
                : 번들의 크기는 커지고 로딩 속도를 느려지며 라이브러리가 업데이트되었을 때 캐시 무효화 이슈를 야기할 수도 있다

                : 벤더 분할을 사용하면 이 서드파티 의존성과 관련된 코드를 별도의 덩어리로 잘라내 독립적으로 캐싱할 수 있다
                : 다시 말해 우리 코드를 업데이트했을 때, 최종 사용자는 전체 라이브러리를 다시 다운로드하지 않아도 된다는 의미이다
                : 라이브러리는 이미 캐싱되어 있기 때문인데, 이것은 캐싱을 최적화하고 불필요한 데이터 다운로드를 줄임으로써
                  더 빠른 로딩 시간과 더 나은 사용자 경험을 제공한다

            - 동적 분할
                : 동적 분할은 자바스크립트 코드를 필요할 때 필요한 만큼 로딩할 때 사용하는 기법이다
                : 코드의 각 부분이 특정한 상황에서만 필요한 대규모 자바스크립트 애플리케이션에 유용하다
                
                : 예를 들면 대시보드와 설정 페이지를 갖는 애플리케이션이 있다고 가정해보자
                : 대시보드 코드는 사용자가 설정 페이지에 있을 때는 불필요하면, 반대의 경우도 마찬가지다

                : 동적 분할을 사용하면 각 페이지 혹은 컴포넌트의 코드를 필요할 때만 로딩할 수 있는데
                  이는 페이지의 초기 로딩 시간을 줄이고 전체적인 성능을 개선한다
                : 또한 자바스크립트 번들의 크기를 통제 가능한 수준으로 유지하는 데 도움을 준다. 이는 대규모 애플리케이션에서 중요하다

                : 동적 분할은 미리 정해진 엔트리 포인트에만 의존하지 않는다는 점에서 엔트리 포인트 분할과 다르다
                : 대신 동적 분할은 리액트의 lazy/Suspense 혹은 동적 import() 기능 도구나 패턴들을 사용해서
                  코드를 특정한 모듈 혹은 컴포넌트로 분할한다 
                : 개발자들은 사용자 상호작용이나 다른 런타임 조건에 따라 코드베이스의 다른 부분들이 로딩될 때 점진적으로 통제할 수 있다

            - 컴포넌트 수준 분할
                : 컴포넌트 수준 분할에서는 각 컴포넌트를 필요할 때만 지연 로딩한다.
                  즉, 애플리케이션은 현재 페이지에서 요청된 컴포넌트만 로딩한다는 의미이다
                : 이 기법은 네트워크 대역폭을 보다 효율적으로 사용할 수 있지만 경우에 따라 컴포넌트를 로딩해야 하기 때문에 지연을 증가시키기도 한다

            - 라우트 기반 분할
                : 라우트 기반 분할에서는 애플리케이션이 라우트에 기반해 각각의 번들로 나뉜다 
                : 사용자가 다른 라우트를 방문하면 적절한 번들을 필요에 따라 로딩하며, 초기에 다운로드해야 할 코드의 양을 줄인다
                : 이 기법은 애플리케이션의 초기 로딩 시간을 줄이는 데 도움을 줄 수 있지만, 네트워크 대역폭 사용 관점에서는
                  컴포넌트 수준 코드 분할보다 효율적이지 않을 수 있다

            - 공격적인 코드 분할의 트레이드오프
                : 공격적인 코드 분할은 애플리케이션의 자바스크립트를 수많은 작은 덩어리로 과도하게 자르는 프랙티스를 가리킨다
                : 코드 분할은 주어진 뷰 혹은 동작에 관한 필요한 코드만 로딩한다는 관점에서는 이익이 있지만,
                  공격적인 코드 분할로 인해 야기되는 몇 가지 어려움들도 있다
                    - 입도(세분성) 트레이드오프
                        : 공격적인 코드 분할은 수많은 작은 코드 덩어리를 만든다. 이것은 캐싱이나 중복 제거 관점에서는 좋을 수 있지만
                          압축이나 브라우저 성능 관점에서는 좋지 않을 수 있다
                        : 각각 압축된 작은 덩어리들의 압축률은 더 작으며, 로딩 성능에도 영향을 미칠 수 있다
                          25개 정도의 덩어리에서 영향이 나타나기 시작하며 100개 이상의 덩어리로 분할하면 그 영향이 심각하게 나타난다

                    - 상호 운용성
                        : 브라우저, 서버, CDN마다 코드 분할을 다르게 구현할 수 있으며 이는 호환성 이슈로 이어질 수 있다

                    - 오버헤드
                        : 코드 분할은 로딩 성능을 개선하지만 다른 한편으로 여러 파일의 처리, 가져오기,
                          파싱을 위해 필요한 추가적인 오버헤드를 발생시킬 수 있다. 이는 종종 애플리케이션의 속도를 늦추며
                          느린 기기나 네트워크에서 속도 저하가 두드러진다

                    - 디버깅
                        : 수많은 작은 덩어리들로 구성된 코드가 어러 파일에 분산되어 있기 때문에 코드를 디버그하고 이슈를 식별하기 어려울 수 있다

                    - 빌드 복잡성
                        : 공격적인 코드 분할은 빌드 프로세스를 한층 복잡하며 오랜 시간을 소요하게 만든다
                        : 코드베이스가 여러 작은 덩어리로 나뉘어 있어 각각 관리해야 하고 때때로 개별적으로 빌드해야 하기 때문이다

    > 컴포넌트화를 통해 모듈성을 확보하면 애플리케이션을 유지보수 가능하고 확장 가능하게 만드는 동시에
      개발자 경험을 향상시킬 수 있다. 이는 모듈성은 컴포넌트의 명확한 구조와 재사용성을 제공하기 때문이다

    > 애플리케이션의 복잡성이 늘어나면서 성능과 사용자 경험 최적화가 무척 중요해졌다
      코드 분할을 사용하면 애플리케이션을 관리 가능한 덩어리로 나룰 수 있고,  
      이를 통해 사용자가 필요한 코드를 적절한 시점에 로딩하도록 보장할 수 있다

    > 애플리케이션을 컴포넌트로 자르면 사용자의 상호작용이나 현재 뷰에 기반해 개별 컴포넌트를
      동적으로 로딩할 수 있으므로 코드 분할을 효율적으로 구현할 수 있다  

