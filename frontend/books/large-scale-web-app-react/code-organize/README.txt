[코드 조직화하기]
웹 애플리케이션이 성장함에 따라 아키텍처의 복잡성, 잠재적인 버그, 새로운 기능 혹은 변경 도입의 어려움도 함께 증가한다.
잘 조직화된 코드베이스는 잘 정리된 도서관과 같은데, 모든 것이 제자리에 있고 개발자들은 그들이 원하는 것을 빠르고 효율적으로 찾을 수 있다
이는 시간이 지남에 따라 코드베이스의 유지보수성, 확장성을 높이고 협업을 증진하는 데 도움이 된다

    - 폴더와 파일 구조
        : 잘 조직화된 폴더와 파일 구조는 대규모 리액트 애플리케이션을 유지하는 데 필수적이다
          애플리케이션 폴더와 파일을 구조를 조직화할 수 있는 몇 가지 가이드는 다음과 같다

            - 루트 수준 폴더
                : 프로젝트 디렉토리 컨텍스트에서 루트 수준 폴더들은 처음 프로젝트를 열 때 확인하는 주요 디렉토리이다
                : 해당 폴더들은 일반적으로 프로젝트 계층의 최상위에서 찾을 수 있으며 프로젝트 콘텐츠에 관한 분류를 제공한다
                : 루트 수준 폴더를 구조화하는 단순하고 효과적인 방법은 이들을 다음과 유사한 형태로 세분화하는 것이다
                    - 루트 수준 디렉토리의 단순한 구조
                        : src/
                        : public/
                        : tests/
                        : build/
                        : docs/
                    - 각 폴더의 일반적인 역할은 다음과 같다
                        src/
                        : 애플리케이션의 본체가 위치, 메인 디렉토리로써 모든 소스 코드를 포함한다
                        : 내용 > 컴포넌트, 애셋, 유틸리티, 구성 파일 등

                        public/
                        : 애플리케이션에 필요하지만 빌드 프로세스(최소화, 트랜스파일, 빌딩 프로세스 등 개발 코드를 최적화된 프로덕션 준비 파일로 변환하는 프로세스)에
                          반드시 필요하지 않은 모든 정적 파일들을 포함한다
                        : 내용 > 메인 index.html 파일, 이미지 및 웹서버로부터 직접 제공되는 다른 비 소스 코드 파일

                        tests/
                        : 테스팅(반드시 필요한)과 관련된 프로젝틍니 경우, 이 코드는 테스트 구성 및 글로벌/통합 테스트 스위트 전용으로 사용된다
                        : 내용 > 테스트 구성 파일

                        build/ (생성됨)
                        : 일반적으로 빌드 도구(Vite 또는 Webpack 등)에 의해 생성된 파일과 배포를 위해 컴파일된 코드를 포함한다

                        docs/
                        : 프로젝트 수준에 관계없는 문서를 편리하게 저장, 이는 외부 사용자는 물론 다른 개발자를 위한 공간이기도 하다
                        : 아키텍처 의사 결정, 컴포넌트 사용 가이드 등을 포함한다
                        : 내용 > 애플리케이션의 중요한 부분, 아키텍처 다이어그램, API 사용 가이드 등에 관한 README.md

                        src/ 디렉토리
                        : src/ 디렉토리는 주로 웹 애플리케이션의 중심이 되며 소스 코드 파일이 위치한다
                        : 해당 디렉토리의 구조는 매우 중요한데, 개발자들이 코드를 탐색하고 애플리케이션 아키텍처를 이해하기 쉬운 정도를 결정하기 때문
                        : src/ 디렉토리를 논리적이고 애플리케이션 도메인과 고려 사항을 반영하도록 조직화하는 것은 개발 프로세스의 속도와 효율성에 큰 영향을 줄 수 있다

                         * src/ 디렉토리의 콘텐츠를 정렬하는 방법의 예
                            : src/
                                components/
                                pages/
                                hooks/
                                services/
                                store/
                                utils/
                                assets/
                                constants/
                                types/

                            >>> 위 src 디렉토리 구조는 다음과 같다
                                : components/ 디렉토리는 기능 혹은 도메인에 의해 조직화된 모든 재사용 가능한 컴포넌트를 포함한다
                                : pages/ 디렉토리는 개별 라우트를 나타내는 최고 수준 컴포넌트 혹은 애플리케이션 뷰를 포함한다
                                : hooks/ 디렉토리는 재사용 가능한 로직(예를 들면 데이터 가져오기 또는 상태 관리 등)을 캡슐화한 훅을 포함한다
                                : services/ 디렉토리는 외부 서비스(예를 들면 API 클라이언트 또는 다른 통합)를 나타낸다
                                : store/ 디렉토리는 중앙 집중화된 상태 관리 설정 및 액션, 리듀서, 미들웨어(예를 들면 리덕스)를 포함한다
                                : utils/ 디렉토리는 유틸리티 함수와 공통 헬퍼 모듈을 포함한다
                                : assets/ 디렉토리는 정적 애셋(이미지, 아이콘, 폰트, 스타일 등)을 나타낸다
                                : constant/ 디렉토리는 상수(API 엔드포인트, 구성값 또는 이늄 등)를 포함한다
                                : types/ 디렉토리는 타입스크립트 코드베이스를 위한 공유 타입 정의 및 인터페이스를 포함한다
                                >>> 위 디렉토리 모두 반드시 코드베잇으에 필요하지는 않다. 프로젝트의 복잡성, 목표, 구체적인 요구사항에 따라 앞서
                                    설명한 디렉토리의 일부만 갖거나 추가 디렉토리를 가질 수 있다          

                    - 기능/도메인 기반 조직화
                        : 메인 src/ 디렉토리 안의 콘텐츠를 조직화할 때는 기능과 도메인에 기반할 수도 있다
                        : 관련된 컴포넌트, 훅, 유틸리티, 애셋을 기능 혹은 도메인에 따라 조직된 같은 폴더에 그룹으로 묶는다

                    - 기능에 따라 src 디렉토리 안의 콘텐츠 정렬하기(예시)
                        : src/
                            features/
                                Authentication/
                                    components/
                                        LoginForm/
                                            LoginForm.js
                                            LoginForm.module.css
                                        SignupForm
                                            SignUpForm.js
                                            SignUpForm.module.css
                                    hooks/
                                        useAuth.js
                                    services/
                                        authService.js
                                UserProfile
                                    components/
                                        ProfileCard/
                                            ProfileCard.js
                                            ProfileCard.module.css
                                    hooks/
                                        useUserProfile.js
                                    services/
                                        userService.js                                                                                        

                    - 명명 규칙
                        : 코드베이스의 명명 규칙은 일관성, 명확성, 예측성을 보장함으로써 다른 개발자들이 
                          파일, 디렉토리, 변수의 목적과 기능을 한눈에 쉽게 이해할 수 있게 돕는다.
                        
                        : 컴포넌트 > 컴포넌트 이름 및 각 파일 이름에 UpperCamelCase를 사용한다(e.g. Header.js)
                        : 훅 > 커스텀 훅의 접두사로 use를 사용하고 이후 이름에 camelCase를 사용한다 (e.g. useFetchData.js)
                        : 서비스 > camelCase를 사용하고 서비스나 도메인 이름을 포함한다 (e.g. authService.js)
                        : 유틸리티 > camelCase를 사용하고 유틸리티의 목적을 설명한다 (e.g. arrayHelpers.js)
                        : 스타일 > CSS 모듈을 사용하는 경우 CSS 혹은 SCSS 파일에 대해 각각 .module.css 혹은 .module.scss 확장자를 사용한다
                                  e.g. Header.module.css

                    - 배럴 익스포트
                        : 배럴 익스포트는 자바스크립트 및 타입스크립트 프로젝트의 디자인 패턴으로 한 모듈의 여러 익스포트를 하나의 편리한 모듈로 집약하는 것이다
                        : 해당 패턴은 애플리케이션의 다른 부분에서 실행하는 임포트를 단순화할 때 유용하다
                        
                        : 실질적으로 배럴 익스포트는 한 디렉토리 안에 있는 index.js 또는 index.ts 파일이며 다른 파일의 대상을
                          재익스포트함으로써 보다 통합된 임포트를 가능하게 한다
                        : 예를 들면, src/features/Authentication/components/ 폴더에 index.js 파일을 만들고 해당 디렉토리 안의 
                          모든 컴포넌트의 익스포트를 책임지게 할 수 있다

                            - Authentication/components/ 디렉토리 안의 모든 컴포넌트 익스포트하기
                            // .../Authentication/components/index.js
                            export { LoginForm } from './LoginForm';
                            export { SignUpForm } from './SignUpForm';

                            - 위 설정을 한 뒤에는 다음과 같은 일반적인 컴포넌트 임포트 방법이 바뀐다

                            - 컴포넌트가 위치한 파일에서 해당 컴포넌트를 곧바로 임포트하기
                            // .../Authentication/Authentication.jsx
                            import { LoginForm } from './components/LoginForm';
                            import { SignUpForm } from './components/SignUpForm';  

                            - 이를 다음과 같이 그룹화된 형태로 임포트할 수 있다
                            
                            - '배럴'로부터 임포트하기
                            // .../Authentication/Authentication.jsx
                            import {
                                LoginForm,
                                SignUpForm,
                            } from "./components";

                        : 배럴 익스포트를 사용하면 깔끔하고 통합된 임포트를 할 수 있으며 배럴 index.js 파일만 
                          업데잍하면 되기 때문에 때로 파일을 쉽게 이동할 수도 있다

                        : 배럴 익스포트는 유용하기는 하지만 배럴 파일이 너무 커지거나 복잡해지지 않도록 항상 유념해야 한다
                        : 마찬가지로 모든 상위 디렉토리마다 배럴 파일을 갖는 것 또한 애플리케이션의 툴링 성능이나 빌드 프로세스에 영향을 줄 수 있다
                         - Speeding up the JavaScript ecosystem, 마빈 하게마이스터, PreactJS 참고  

                    - 그 밖의 다른 좋은 프랙티스들
                        : 코드를 모듈화하라
                            - 컴포넌트, 함수, 서비스들을 작고 재사용 가능한 모듈로 나누기
                            - 이는 DRY(don't repeat yourself) 원칙을 촉진함과 동시에 코드를 쉽게 테스트 및 리팩토링 할 수 있게 도와준다  
                            - 리액트 컴포넌트에 국한해서 보자면 각 컴포넌트가 한 가지 혹은 작은 몇 가지 작업을 잘 해야 할 때
                              규모가 작고 해당 작업에 집중하는 컴포넌트를 만들어야 하며 추가로 다음을 고려해야 한다
                                : 컴포넌트 상태와 로직을 캡슐화하라
                                    - 컴포넌트의 상태와 관련된 로직을 컴포넌트 안에 유지해야 한다. 즉, 자급자족하고 쉽게 이해할 수 있도록 해야 한다
                                : 훅과 함께 함수형 컴포넌트를 사용하라
                                    - 클래스 컴포넌트보다 함수형 컴포넌트를 선호하자, 가독성을 향상하고 리액트 훅의 장점을 취할 수 있다  

                        : 명확한 관심사 분리를 유지하라
                            - 명확한 관심사 분리는 코드베이스의 각 모듈, 컴포넌트 혹은 함수가 구별된 책임을 갖는 것을 보장하는 것이다
                            - 다음은 이를 달성하는 데 도움을 주는 몇 가지 전략이다
                                : 계층화된 아키텍처를 갖추라
                                    - 코드를 프레젠테이션, 로직, 데이터 등으로 계층화해 조직
                                    - 예를 들어 리액트 애플리케이션에서 프레젠테이션 꼐층은 컴포넌트, 로직은 훅이나 유틸리티 함수,
                                      데이터는 상태 관리 도구 혹은 API 통합 등을 통해 관리할 수 있다

                                : (가능하다면) 사이드 이펙트를 피하라
                                    - 함수 혹은 컴포넌트는 사이드 이펙트(범위를 벗어난 의도하지 않은 혹은 관찰할 수 없는 변경)를 피해야 한다
                                    - 혹시 사이드 이펙트가 발생한다면 명시적이어야 한다
                                        - 순수한 함수(동일한 입력에 대해 항상 동일한 출력을 만들어내며 사이드 이펙트를 발생시키지 않는 함수)는 테스트하고 이해하기 쉽다

                                : 외부 의존성을 분리하라
                                    - 외부 서비스 혹은 API를 컴포넌트 안에서 직접 부르는 대신, 서비스 계층이나 어댑터를 사용하라
                                    - 해당 방식을 사용하면 미래에 나머지 코드에 영향을 주지 않고도 외부 서비스를 쉽게 변경할 수 있게 된다

                        : 프레젠테이션 로직과 데이터 가져오기 로직을 분리하라
                            - 데이터 가져오기 로직을 프레젠테이션 로직과 분리하라. 데이터 가져오기와 관리를 전담하는 커스텀 훅이나 서비스를 만들고 사용하자
                            - 대안으로 리덕스, MobX 혹은 리액트 컨텍스트 API 같은 상태 관리 도구를 사용할 수 있다
                            - 해당 도구들을 사용하면 데이터 가져오기 로직을 애플리케이션의 컴포넌트 로직과 뒤섞지 않고 구분해서 조직화할 수 있다

                        : CSS 방법론을 따르라
                            - 일관성 있는 CSS 방법론과 접근법을 도입함으로써 스타일시트를 확장 가능하고, 유지보수 가능한 방식으로 구조화할 수 있다    
                            - 이는 충돌 및 특수성 이슈를 피할 수 있을 뿐만 아니라 개발자들이 보다 쉽게 스타일링 코드를 이해하고 기여하는 데 도움을 준다  
                            - 특정한 CSS 접근법을 준수하는 데 유용한 지침은 다음과 같다
                                : 팀이 선호하는 CSS 접근법을 선택하자, BEM, SMACSS, CSS-in-JS(StyleX) 등을 사용할 수 있다
                                : 스타일의 범위를 특정한 컴포넌트로 한정해 예기치 못한 사이드 이펙트를 야기할 수 있는 글로벌 스타일을 피하라
                                : 공통된 디자인 패턴을 위한 재사용 가능한 CSS 클래스 혹은 스타일 컴포넌트를 만들라
                    
                    - 단위 테스트와 통합 테스트를 구현하라
                        : 테스팅 코드는 버그를 조기에 잡아내고 애플리케이션이 기대한 대로 작동함을 보장하는 것들을 돕는다
                        : 또한 간접적으로 코드 조직화를 돕고 코드베이스의 전반적인 디자인과 유지보수성을 향상시키기도 한다
                        : 테스트는 안전망을 제공, 코드 구조를 개선하기 위해 리팩토링을 하는 경우 단위 테스트는 해당 과정에서
                          새로운 버그나 리그레션을 유입시키지 않았음을 보장하는 데 도움을 준다

                        : 테스트 가능한 코드를 작성하려면 컴포넌트나 함수가 단일 책임을 갖도록 모듈화한다
                        : 해당 디자인은 단위 테스트를 구현하기 쉬우며, 보다 테스트 가능한 코드를 만들기 위해 단순화 혹은 리팩토링한다 

                    - 일관성 있는 코드 스타일 적용
                        : 프로젝트 사이에서 일관성 있는 코딩 스타일을 유지함으로써 다른 개발자들은 코드를 쉽게 읽고 이해할 수 있다
                        : ESLint, Prettier 같은 도구들을 사용하면 코딩 표준과 스타일 가이드라인을 적용하는 데 도움이 된다

                    - 타입스크립트를 사용하라
                        : 타입스크립트는 정적 타입 체킹 기능을 제공, 컴파일 시점에 에러를 잡아냄으로써
                          코드를 보다 강건하고 유지보수 가능하도록 유지하게 해준다 (개발자들은 데이터 구조와 함께 함수 시그니처를 위한 타입과 인터페이스를 정의해야 한다)                        
                        : 타입스크립트는 명확한 계약을 강요하고, 향상된 VSCode Intellisense 지원을 제공하고, 정적 타입 체킹을 통한 안전망에 기반한
                          쉬운 리팩토링을 지원함으로써 코드 구조화에 매우 중요한 역할을 한다

                    - 코드를 문서화하라
                        : 좋은 문서화는 모든 프로젝트에서 필수적이다. 좋은 문서화는 새로운 개발자들이 코드베이스를 쉽게 이해하게 하며
                          모든 개발자를 위한 참조를 제공한다
                        : 좋은 문서화에는 README 파일, API나 라이브러리에 관한 보다 자세한 문서, 코드 내 주석도 포함된다

                    - 버전 관리를 사용하라 
                        : 코드 조직화의 컨텍스트에서 깃 같은 버전 관리 시스템은 구조, 추적성, 협업을 보장하는 중추적인 역할을 한다
                        : 버전 관리는 코드베이스에 이뤄진 모든 변경에 관한 연대 기록을 유지한다
                        : 해당 로그를 통해 언제, 누가 특정 코드를 추가하거나 수정했는지 쉽게 식별할 수 있다
                        : 추적성은 시간에 따른 코드 구조의 진화를 인해하고자 할 때 매우 중요하다

                        : 브랜칭을 사용하면 개발자들은 메인 코드베이스에 영향을 주지 않고 격리된 환경에서 다른 기능이나 버그에 관한 작업을 할 수 있다
                        : 이는 기본 브랜치가 항상 깨끗하고 구조화되어 있음을 보장한다. 각 기능들은 개발이 완료되고 테스트된 후에만 병합된다

                        : 커밋 메시지와 관련 문서(README 파일) 등 특정한 조직적 의사 결정이 내려진 이유에 관한 통찰을 제공한다
                        : 좋은 커밋 메시지는 프로젝트 진화와 구조 변경에 관한 로드맵 역할을 한다

                    - 정기적으로 리팩토링하라
                        : 정기적인 리팩토링을 통해 코드의 구조와 가독성을 크게 개선할 수 있으며, 코드베이스를 유지하는 데 도움을 준다
                        : 코드 규모가 커지더라도 쉽게 새로운 기능을 추가하고 버그를 수정할 수 있게 해주며, 정기적인 리팩토링은 다음을 포함할 수 있다
                            - 코드 악취를 식별하고 수정하라
                                : 코드베이스에서 코드 악취(과도하게 복잡한 컴포넌트, 중복된 코드, 강하게 결합된 컴포넌트)가 나는 영역을 찾는다
                            - 점진적으로 개선하라
                                : 일상 업무를 하면서 코드베이스에 작고, 점진적인 개선을 만든다. 대규모 리팩토링을 기다리지 않는다
                            - 코드 리뷰를 사용하라
                                : 코드 리뷰를 개선과 리팩토링을 위한 영역을 식별하는 기회로 사용한다

                            >>> 팀 안에서의 소통이 핵심이다. 정기적으로, 특히 애플리케이션이 성장하고 진화할 때 코드 조직화 접근법에 관해 논의하고 재평가하라
                                시간을 내어 정기적으로 리팩토링하고, 버전 관리를 현명하게 사용하고, 의사 결정을 문서화하고, 모든 사람이 동일한 인식을 갖고 
                                행동하게 하는 것은 장기적인 관점에서 이익을 가져다줄 것이다                                                                                                                   

