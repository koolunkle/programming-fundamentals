[테스팅]
소프트웨어 개발에서 테스팅은 시스템 혹은 그 컴포넌트를 평가하는 프로세스이며, 이를 통해 이들이 명시된 요구사항을 만족하는지 결정한다
테스팅의 목적은 애플리케이션이 기대한 대로 작동하고 모든 기능적/비기능적 요구사항을 만족함을 보장하는 것이다
다시 말해, 테스팅은 소프트웨어가 해야 할 일을 하고 있는지 확인하는 방법이다

대규모 리액트 자바스크립트 애플리케이션에서 테스팅은 매우 중요한데, 큰 애플리케이션들은 복잡하며 디버그하기 어렵기 때문이다
테스팅은 개발 프로세스 조기에 버그를 잡아낼 수 있게 도와주며, 버그가 심각한 이슈를 일으키기 전에 쉽게 수정할 수 있게 한다

추가로 테스팅이 지속적 통합 파이프라인(코드 변경을 자동으로 빌드, 테스트, 배포하는 프로세스)의 일부라면
모든 코드 변경을 완전히 테스트한 뒤 기본 브랜치에 병합하거나 프로덕션에 배포할 수 있다

이를 통해 버그 또는 다른 이슈들이 프로덕션 환경을 방해할 리스크를 줄일 수 있고,
동시에 수동 테스팅이나 버그 수정에 드는 시간과 노력을 아낄 수 있다

규모에 관계없이 리액트 애플리케이션의 신뢰성과 기능을 보장하기 위해서는 다양한 유형의 테스팅을 활용해야 한다
이는 단위 테스팅, 엔드-투-엔드 테스팅, 통합 테스팅, 스냅숏 테스팅 등을 포함한다

    - 단위 테스팅
        : 단위 테스트는 애플리케이션의(나머지 코드베이스와 격리된) 개별 컴포넌트 또는 기능 검증에 초점을 둔다
        : 단위 테스트는 각 컴포넌트 혹은 함수가 기대한 대로 작동하며 그 기능 요구사항을 만족시키는지 검증한다
        : Jest와 React Testing Library는 단위 테스트를 작성하고 실행하는 도구로 많이 권장된다
            - Jest      
                : 잘 알려진 자바스크립트 테스팅 프레임워크이며, 이를 사용하면 리액트 애플리케이션을 위한 테스트를 쉽게 작성하고 실행할 수 있다
                : Jest는 모킹(Mocking), 코드 커버리지, 병령 테스트 실행 등 유용한 여러 기능을 제공한다
            - React Testing Library
                : 리액트 컴포넌트 테스팅에 특화된 경량 라이브러리이다. 구현 세부 사항보다 사용자의 경험에 초점을 둔 테스트를 효과적으로 작성할 수 있다
                  (Counter 예제 참고)
                : React Testing Library가 제공하는 유틸리티 기능들을 사용하면, 마치 사용자처럼 리액트 컴포넌트와 상호작용할 수 있다
                  이 함수들은 클릭, 타이핑, 스크롤 같은 사용자 이벤트를 시뮬레이션해 이 이벤트들에 대해 컴포넌트가 올바르게 작동하는지 확인할 수 있다

        : 대규모 리액트 애플리케이션에서 비동기 동작(에를 들면 API로부터 데이터 가져오기 혹은 지연이 있는 사용자 입력 처리하기 등),
          컨텍스트 혹은 리덕스 스토어에 의존하는 컴포넌트를 테스트해야 하는 보다 복잡한 시나리오를 테스트해야 할 때가 있다
        
        : 테스트의 기본 형태는 React Testing Library가 제공하는 유틸리티 함수를 사용해서 컴포넌트를 렌더링하고 그 컴포넌트와 상호작용해야 한다
        : 이상적으로는 잘 알려져 있는 정리, 동작, 확인 패턴을 따라 테스트를 수행하게 된다

    - 정리, 동작, 확인(arrange, act, assert pattern)
        : 정리, 동작, 확인 패턴은 단위 테스트를 명확하고 간결한 형태로 구조화하기 위해 널리 받아들여지는 접근법이다
        : 해당 패턴은 테스트 프로세스를 다음 세 단계로 나눈다
            - 정리
                : 이 단계에서는 테스트 대상 컴포넌트 혹은 시스템의 초기 단계를 설정한다. 특정 props를 사용해 컴포넌트를 렌더링하거나,
                  목 객체를 만들거나, 필요한 의존성들을 초기화한다
            - 동작
                : 이 단계에서는 동작을 수행하거나 사용자 상호작용 또는 시스템 운영을 시뮬레이션하는 이벤트를 트리거한다
                : 이 동작에는 클릭이나 키 입력, 함수 호출, 컴포넌트 상태 업데이트 같은 이벤트를 트리거하는 것 등이 포함된다
            - 확인
                : 마지막 단계에서는 이전 단계에서 동작을 수행한 뒤 컴포넌트나 함수가 기대한 대로 작동했는지 확인한다
                : assertion을 사용해서 특정한 조건이 참(true)을 유지하는지 확인한다
                : 예를 들면 어떤 요소가 DOM 안에 존재하는지 확인하거나, 업데이트된 상태값을 기대 결과와 비교하거나,
                  특정 함수가 적절한 인수와 함께 호출되었는지 검증한다                  

    - 엔드-투-엔드 테스트
        : 단위 테스트와 달리, 엔드-투-엔드 테스트는 여러 컴포넌트와 서비스에 걸쳐 발생하는 실세계의 사용자 상호작용을
          시뮬레이션해 애플리케이션의 완전한 기능을 평가한다
        : 엔드-투-엔드 테스트는 프론트엔드, 백엔드, 외부 시스템과의 모든 통합을 포함한 모든 시스템이 사용자의 관점에서 기대한 대로 작동함을 보장한다
        
        : 엔드-투-엔드 테스팅 시나리오에서는 개별 함수나 컴포넌트를 격리한 상태에서 테스트하는 것이 아니라 어떻게 하면 애플리케이션 전체,
          즉 한쪽 끝에서 다른 쪽 끝까지 테스트할 수 있을 지 생각해야 한다
        : 엔드-투-엔드 테스트는 컴포넌트와 API 서비스 사이의 통합 및 전체적인 사용자 경험에 초점을 두어야 한다

        : Cypress는 잘 알려진 웹 애플리케이션용 엔드-투-엔드 테스팅 도구로 테스트를 작성하고 실행하는 데 필요한 강건한 기능 셋을 제공한다
        : Cypress는 사용자 상호작용을 시뮬레이션 할 수 있는 직관적인 API, 실시간 재로딩, 시간을 오가며 디버깅할 수 있는 기능을 제공한다  

        : 실제 API 요청
            - 테스트에서 실제 API 요청을 사용해 테스트가 정확하게 애플리케이션의 실제 행동을 실제 환경에서 시뮬레이션 하는 것을 보장할 수 있다
            - 하지만 이 접근법은 네트워크 이슈 혹은 외부 의존성으로 인해 테스트 속도를 느리게 하거나 테스트가 안정적이지 못하게 만들 수 있다
        : 스텁/목 API 응답
            - 스텁 혹은 목 API 응답을 사용하면 테스트를 보다 빠르고 안정적으로 실행할 수 있다
            - 테스트가 네트워크 지연, 서버 가용성 같은 외부 요소에 의존하지 않기 때문이다
            - 하지만 이 접근법은 애플리케이션이 실제 API와 상호작용할 때의 동작을 완전히 나타내지 못하기 때문에
              스텁이나 목이 실제 API를 정확하게 모방하게 해야 한다

        : Cypress가 제공하는 네트워크 요청 가이드 문서는 애플리케이션의 크리티컬 패스(로그인, 회원 등록, 결제 등)를 테스트할 때는
          반드시 실제 API 요청을 사용하되 너무 많이 사용하지 말라고 권장한다
        : 크리티컬 패스가 아닌 경우에는 대부분의 테스트에서 스텁 API 응답을 사용해야 한다   

        : 엔드-투-엔드 테스팅 접근법은 보다 통합된 관점을 요한다
        : 개별 함수 혹은 컴포넌트의 테스트를 고려하지 않고 전체 애플리케이션의 흐름 및 다양한 부분들 사이의 상호작용을 검증하는 데 초점을 둔다

    - 통합 테스트
        : 통합 테스트에서는 일반적으로 애플리케이션의 여러 단위 혹은 컴포넌트 사이의 상호작용을 테스트하는 데 초점을 둔다
        : 명확하게 정의하기는 어렵지만, 통합 테스트는 단위 테스트와 엔드-투-엔드 테스트의 중간에 위치한다
            E2E
            Integration
            Unit
        
        : 예제에서는 Counter 컴포넌트와 이 컴포넌트가 의존하는 API 서비스 사이의 기능을 확인하는 통합 테스트를 작성하는 방법에 관해 살펴본다
        : 사용자가 증가 버튼 혹은 감소 버튼을 클릭한 뒤, Counter 컴포넌트가 API로부터 새로운 데이터를 받아 성공적으로 마크업을 업데이트하는지 확인한다
        : 테스트는 Jest와 React Testing Library를 사용한다                                             

    > API 요청을 모의 구현하지 않고, 실제 테스트 환경을 활용하고, 테스팅을 위해 백엔드에 데이터를 주입하는 것은 보다 실질적인 엔드-투-엔드 테스팅 환경과 유사하다
    > 반대로 컴포넌트 사이의 상호작용을 테스트하고, API 요청을 모의 구현하고, 애플리케이션 흐름의 특정 부분에 초점을 두는 것은 통합 테스팅에 일반적을 관련된 특성이다
    > 통합 테스트는 엔드-투-엔드 테스트의 충분함과 단위 테스트의 효율성의 균형을 제공하는 것을 목적으로 하며, 개별 컴포넌트가 함께 잘 작동하고
      전체 애플리케이션 컨텍스트 안에서 예상한 대로 기능함을 보장한다

    - 스냅숏 테스트
        : 스냅숏 테스트는 특정 시점에서의 컴포넌트의 UI 출력을 캡처하고 이를 미래의 출력과 비교함으로써 의도하지 않은 변경이 발생하지 않았음을 보장하는 데 초점을 둔다
        : 이 접근법은 코드를 업데이트하거나 리팩토링할 때 발생할 수 있는 UI의 잠재적인 리그레션을 발견하는데 유용하다
        : 스냅숏 테스트는 Jest를 사용해 작성할 수 있다. Jest는 컴포넌트의 렌더링한 스냅숏을 만든 뒤 이를 참조 파일로 저장한다              

        : 스냅숏 테스트를 처음 실해하면 Jest는 컴포넌트의 직렬화된 출력을 포함하는 스냅숏 파일을 생성한다
        : 해당 파일은 테스트와 함께 저장되고 미래의 테스트에 대한 참조를 제공한다. 아래는 스냅숏 파일의 에시이다
            * Link 컴포넌트의 초기 스냅숏
                exports[`renders correctly 1`] = `
                <a
                    href="http://www.facebook.com"
                >
                    Facebook
                </a>    
                `

            * Jest 스냅숏 업데이트 하기
                jest --updaetSnapshot

        : 스냅숏 테스팅 프로세스
            - 테스트 실행 > 스냅숏이 존재하는가? > 예 > 새로운 스냅숏을 만들고 기존 스냅숏과 비교한다 > 테스트 성공/실패(스냅숏 일치/불일치)
                                               아니오 > 새로운 스냅숏 파일을 만들고 저장한다 > 테스트 성공

    - 애플리케이션을 어떻게 테스트해야 하는가?
        : 언제 스냅숏 테스트를 작성해야 하는가?
            - 스냅숏 테스트는 UI의 일관성이 중요한 경우, 예를 들면 디자인 시스템 혹은 복잡한 시각적 세부 요소를 가진 컴포넌트를 사용하는 경우에 매우 적합하다
            - 스냅숏 테스트를 작성할 때는 다음을 고려할 수 있다
                : 스냅숏 테스트는 보조적으로 작성하라 
                    - 스냅숏 테스트는 UI 일관성을 검증하는 데 뛰어나지만 이들이 기본 테스트 방법이 되어서는 안 된다
                    - 단위 테스트를 사용해 개별 기능과 컴포넌트를 테스트하고, 통합 테스트를 사용해 애플리케이션의 서로 다른 부분들의 상호작용을 검증하고,
                      엔드-투-엔드 테스트를 사용해 전반적인 사용자 경험과 기능을 확인하자
                : 스냅숏을 작게 유지하라
                    - 전체 페이지보다 개별 컴포넌트 테스트에 초점을 두는 편이 차이를 식별하고 해결하는 과정을 단순화할 수 있다
                    - 작은 스냅숏은 쉽게 이해하고 유지보수 가능하며, 의도하지 않은 변경을 덜 간과하는 데 도움을 준다
                : 테스트 케이스를 문서화하라
                    - 가능한 한 각 스냅숏 테스트로 커버하는 테스트 케이스를 문서화한다. 이는 다른 개발자들이 해당 테스트의 목적과
                      스냅숏 테스트가 어떤 결과/UI를 검증하는 지 이해하도록 돕는다

        : 100%의 코드 커버리지를 항상 목표로 해야 하는가?
            - 코드 커버리지는 테스트로 커버된 코드베이스의 비율을 나타내는 지표이다
            - Jest는 기본적으로 코드 커버리지 추적을 지원한다. 보다 세세한 보고서와 추적 결과를 확인하고 싶다면 Istanbul 같은 코드 커버리지 도구를 사용할 수 있다
              e.g. yarn jest --coverage (yarn run v1.12.3)
            
            - 높은 코드 커버리지느 애플리케이션의 안정성에 관한 확신을 가질 수 있게 해준다. 그러나 100%의 코드 커버리지가 항상 필요한 것은 아니며 오히려 때로는 비생산적일 수 있다
            - 종종 불필요한 테스트를 작성하게 되거나 애플리케이션의 덜 중요한 부분에 집중하게 되어 가치 있는 시간과 리소스를 소비하게 되기도 한다
            - 100%의 코드 커버리지를 달성하기 위해 무작정 노력하기보다는 팀의 입장에서 합리적으로 결정한 구체적인 커버리지 임곗값을 추구하는 것이 훨씬 바람직하다
            - 예를 들면 코드베이스 품질에 대한 확신을 갖기 위해 60% 혹은 80%의 코드 커버리지가 충분하다고 결정할 수도 있다
            - Codecov 혹은 Coveralls 같은 도구를 사용해 시간 경과에 따른 코드 커버리지를 모니터링하고 테스트 커버리지가 특정 임곗값보다 낮아지면
              알림을 보내도록 설정하는 것도 고려할 수 있다. 이를 활용해 테스트의 간극을 지속적으로 인지할 수 있고 필요하다면 적극적으로 대응할 수 있다

        : 모든 코드를 TDD 마인드셋으로 작성해야 하는가?
            - 테스트 주도 개발은 코드에 대한 테스트를 작성한 '뒤에' 실제 코드를 작성하는 개발 접근법이다
            - TDD는 개발 프로세스에 다음과 같은 여러 이익을 준다
                : 개선된 코드 품질
                    - 테스트를 작성한 뒤 실제 코드를 작성함으로써 이른 시점부터 코드의 기대 동작과 결과에 초점을 둘 수 있다
                    - 이는 종종 잘 정의된, 보다 강건한 코드 구현으로 이어진다
                : 쉬운 디버깅과 유지보수
                    - 테스트가 실패했을 때, 기대 결과를 이미 알고 있기 때문에 쉽게 이슈를 식별하고 수정할 수 있다
                    - 이는 장기적으로 디버깅에 소요되는 수고를 줄이고 애플리케이션을 보다 관리 가능한 상태로 유지할 수 있다
                : 빠른 개발
                    - TDD는 특정 시점에 구체적인 기능과 컴포넌트에 초점을 둠으로써 개발자들이 큰 태스크를 작고, 관리 가능한 덩어리로 나누도록 독려한다
                    - 이는 생산성을 높이고 시간에 지남에 따라 기술 부채가 발생할 가능성을 줄인다

                >>> 위와 같은 장점에도 불구하고 작성하는 모든 코드에 TDD를 적용하는 것은 고품질의 리액트 애플리케이션 개발에서 엄격한 요구사항은 아니다
                >>> 다른 테스팅 방법을 선호할 수 있고, TDD가 기존 워크플로나 프로젝트 요구사항과 잘 맞지 않는다고 판단할 수도 있다

        : 단위 테스트 vs 통합 테스트 vs 엔드-투-엔드 테스트
            - 어떤 유형의 테스트를 다른 유형의 테스트보다 강조해야 하는지 결정하는 문제에 올바른 답은 없다
            - 프로젝트 규모, 복잡성, 팀 전문성 및 가용 리소스 등 다양한 요소에 기반해 테스트 접근법을 권장하고 적용하는 다양한 테스트 전략들이 존재한다

            - 테스팅 피라미드는 마이크 콘이 '경험과 사례로 풀어낸 성공하는 애자일'에서 처음 소개했으며, 이후 구글의 유명한 아티클인
              'Just Say No to More End-to-End Tests'를 통해 심도 있게 논의되었다
            - 테스팅 피라미드는 단위 테스트 수가 가장 많아야 하고, 그다음으로 통합 테스트, 엔드-투-엔드 테스트 순으로 그 수가 적어야 함을 강조한다
            - 테스팅 피라미드 접근법은 테스트 커버리지를 최대화하면서 동시에 테스팅에 들이는 시간과 리소스를 최소화하려는 접근법이다

            - 그외 테스팅 트로피 또는 테스트 다이아몬드 등 통합 테스트에 더욱 초점을 둔 테스팅 전략도 있다 (Write tests. Not too many. Mostly itegration)
            - 통합 테스트 다음으로 단위 테스트, 엔드-투-엔드 테스트 순으로 구현하라고 강조하며, 정적 타이핑(타입스크립트 같은) 사용이 타입과 관련된 에러를 예방하는 데 중요한 역할을 한다고 강조한다
              (이 정적 타입이 테스팅 트로피 전략의 기반이 된다)
            - 통합 테스트의 우선순위를 높임에 따라 테스트 신뢰성과 개발 효율 사이의 균형이 깨질 수 있다
            - 통합 테스트를 활용하면 엔드-투-엔드 테스팅과 관련된 오버헤드를 발생시키지 않으면서도 실세계 시나리오에서 컴포넌트들이 상호작용하는 방법을 보다 종합적으로 이해할 수 있다

            - 한편 테스트 전략 중 공통적으로 엔드-투-엔드 테스트는 가장 적게 작성한다는 것을 확인할 수 있다
            - 엔드-투-엔드 테스트는 단위 테스트나 통합 테스트에 비해 만들고 유지보수하는 데 더 많은 시간이 소요되며, 실행 시간 역시 많이 소요된다
            - 때문에 엔드-투-엔드 테스트는 사용자 인증, 지불 프로세스 및 다른 중요한 경로 같은 핵심 애플리케이션 흐름에 대해서만 작성할 것이 권장된다
            >>> 어떤 테스트에 초점을 둘 것인지는 궁극적으로 프로젝트의 구체적인 니즈와 컨텍스트, 테스팅의 깊이와 범위에 대한 팀의 선호에 달려있다 
