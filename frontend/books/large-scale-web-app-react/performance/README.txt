[성능]
웹 성능은 웹페이지가 로딩되고 작동하는 속도와 효율성을 측정한 것이다 
대규모 웹 애플리케이션에서 최적의 성능을 유지하는 것은 긍정적인 사용자 경험을 보장하는 데 매우 중요하다
애플리케이션의 규모가 커지면 트래픽 증가, 무거운 리소스 사용, 광범위한 기능으로 인해 점점 성능 유지가 어려워지기 때문이다

우리가 최적화에 집중하는 대상이 핵심 웹 중요성 지표(Core Web Vitals metrics)이든, 직접 고안한 사용자 시점 지표(user timing metric)든,
혹은 다른 어떤 것이든 성능과 관련된 여러 가지 중요한 주제들을 항상 염두에 두어야 한다

이런 관점에서 성능은 매우 방대한 주제이다. 수많은 뉘앙스, 복잡함, 방법론이 존재하며 각각 심오하게 다루기에 충분한 영역이다
이번에는 웹 개발과 자바스크립트 영역에서의 성능 최적화에 관한 몇 가지 핵심 개념을 살펴본다

    - 브라우저는 어떻게 작동하는가?
        : 우리는 웹 애플리케이션이 빠르게 로딩되고, 응답성이 좋고, 매끄러운 사용자 경험을 제공하기를 원한다
        : 이를 달성하기 위해 먼저 브라우저가 어떻게 콘텐츠를 렌더링하고, 칠하고, 로딩하는지 이해하자
            * 모던 브라우저들은 어떻게 작동하는가(고수준 다이어그램)
                        사용자 인터페이스 ---------------
                               |                       |
                          브라우저 엔진 --- 데이터 보존  |
                               |                       |
                           렌더링 엔진                  |
                               |                       |
                네트워킹 | 자바스크립트 해석기 | UI 백엔드

    - 렌더링
        : 렌더링부터 살펴보자. 브라우저는 HTML 문서를 받으면 파싱 처리를 진행한다
        : 파서는 받은 문서를 읽어 문서 객체 모델(DOM) 트리를 생성한다. (DOM은 문서의 구조를 나타낸다)
        : 다음은 간단한 HTML 문서의 예시이다 (sample-page.html 참고)
            - 브라우저는 이 DOM 트리를 사용해 페이지에 콘텐츠를 렌더링한다.
              브라우저는 HTML을 파싱해 DOM을 생성하면서 CSS를 처리해 CSS 객체 모델(CSSOM)을 만든다
              CSSOM은 DOM 요소에 적용될 CSS 스타일의 표현이다

        : 하지만 렌더링은 그저 콘텐츠를 화면에 표시하는 것만은 아니다. 렌더링의 두 가지 주요 단계는 '레이아웃'과 '페인트'이다
          레이아웃 단계에서 브라우저는 CSS에 정의된 스타일과 레이아웃 규칙을 기반으로 페이지에서 각 요소의 크기와 위치를 계산한다
        : 레이아웃을 완료하면 브라우저는 페인트 단계에 진입한다. 페인트 단계에서 브라우저는 각 요소를 화면에 그린다

        : 이러한 처리 과정을 이해하는 것은 애플리케이션의 성능을 최적화하는 데 도움이 되므로 매우 중요하다
          예를 들면 페이지 안에 수많은 요소들이 존재하는 경우, 브라우저는 레이아웃을 계산하는 데 많은 시간을 소요할 수 있다
          이 애플리케이션의 속도는 느리고 응답성이 낮을 것이다

        : 페이지의 요소 수를 최소화하거나, CSS 그리드를 사용하거나 Flexbox를 사용해 레이아웃을 단순화함으로써 애플리케이션의 성능을 개선할 수 있다

    - 로딩
        : 브라우저 성능에 중요한 또 다른 측면은 로딩이다.
        : 브라우저는 HTML 문서를 받으면 문서에 참조된 리소스(예를 들면 이미지, 스타일시트, 스크립트 등)를 로딩하기 시작한다
        : 이 프로세스는 특히 로딩해야 할 리소스가 매우 많을 경우 병목이 될 수 있다

        : 로딩 프로세스를 이해하는 것 또한 애플리케이션 성능을 최적화하는 데 도움을 준다
        : 예를 들면 지연 로딩을 사용해 리소스가 필요할 때만 로딩할 수 있다
        : 또한 미리 가져오기나 미리 로딩하기 같은 리소스 힌트를 사용할 수 있다
          이들을 사용하면 브라우저에게 미래에 사용할 리소스에 관한 정보를 제공할 수 있다

    - 성능 병목 식별하기
        : 브라우저 엔지니어링에 관해 자세히 이해해야 하는 중요한 이유는 성능 병목을 식별하고 해결하기 위해서일 것이다
        : Chrome DevTools 같은 브라우저 개발자 도구를 사용하면 애플리케이션 성능을 조사하고 속도를 늦추는 영역을 식별할 수 있다
        : 이를 활용하면 코드를 최적화하고 애플리케이션 성능을 개선하는 데 도움이 된다

        : 브라우저 엔지니어링에 관해 더 자세히 알고 싶다면 구글 크롬 개발자 블로그의 '최신 웹브라우저 들여다보기' 시리즈를 읽어보자
        : 이 시리즈는 브라우저의 다양한 컴포넌트 및 이들이 함께 작동해 웹페이지를 렌더링하는 방법에 관한 종합적인 시각을 제공한다
        : DOM과 CSSOM의 내부 동작에 관해 더 자세히 알고 싶다면 web.dev의 아티클 <객체 모델 생성>과 <렌더링 트리 생성, 레이아웃 및 페인트>를 읽어보자

        > 무료로 제공되는 <Web Browser Engineering>도 추천하는데, 이 책은 브라우저 엔지니어링에 관해
          자세히 다루며 파싱, 레이아웃, 렌더링, 네트워킹 같은 주제도 커버한다
        > 브라우저가 작동하는 방법에 관해 밑바닥부터 이해하고 싶어 하는 모든 개발자들을 위한 훌륭한 리소스다

    - 자바스크립트에서의 비용 이해하기와 줄이기
        : 자바스크립트는 상호작용 할 수 있는 사용자 경험과 동적 콘텐츠를 사용 가능하게 함으로써 모던 웹 개발의 핵심 요소가 되었다
        : 하지만 자바스크립트를 사용하는 비용은 성능, 구체적으로는 다운로드 시간과 CPU 실행 시간 관련해 부정적인 영향을 미칠 수 있다
        : 이는 페이지 로딩 시간을 늦추고, 상호작용성을 줄이고, 형편없는 사용자 경험(특히 느린 CPU가 탑재된 랩톱과 모바일 기기를 사용하는 사용자들)을 만든다

        : 자바스크립트 CPU 실행 최적화를 통해 총 차단 시간 및 다음 페인트와의 상호작용 같은 상호작용성 지표를 개선할 수 있다
        : 여기에서 2024년 기준 자바스크립트 비용에 관해 자세히 살펴보자. 자바스크립트 성능을 개선하고, 빠르고, 응답성이 뛰어난
          웹 경험을 전달하기 위한 최신 기법들과 모범 사례들을 확인해보자

    - 다운로드 시간(네트워크 전송)
        : 자바스크립트와 관련된 가장 큰 어려움은 다운로드 시간을 줄이는 것이다
        : 5G 같은 고속 네트워크의 성장에도 불구하고 많은 사용자들은 여전히 느린 네트워크 연결 속도(특히 이동 중)를 경험하고 있다
        : 다운로드 시간을 최적화하려면 '자바스크립트 번들의 크기를 작게(특히 모바일 기기를 위해) 유지해야 한다'
          번들의 크기가 작을수록 다운로드 속도가 개선되고, 메모리를 적게 사용하고, CPU 비용이 낮아진다

        > '하나의 거대한 번들의 사용을 피하는 것'도 중요하다. 번들의 크기가 50-100 KB를 초과한다면 작은 번들로 나눠야 한다
           이때 HTTP/2 멀티플렉싱을 사용하면 복수의 요청과 응답 메시지를 동시에 전송할 수 있다
           이를 통해 추가적인 요청의 오버헤드를 줄일 수 있다

    - 실행 시간
        : 다운로드를 완료한 뒤에는 이제 스크립트 실행 시간이 대다수의 비용을 차지한다.
        : 브라우저의 메인 스레드가 자바스크립트를 실행하느라 바쁘면 사용자 상호작용은 지연될 수 있다
        : 따라서 스크립트 실행 시간과 네트워크 관련 병목을 최적화하는 것이 영향을 미칠 수 있다
        : 이를 최적화하기 위해서는 다음을 고려하자
            - 메인 스레드를 바쁘게 유지시킬 수 있는 '긴 태스크를 피하라' 그리고 페이지들이 상호작용할 수 있는 상태가 되면 곧바로 내보낸다
            - 긴 태스크들은 메인 스레드를 점유하므로 이를 작은 작업들로 분할하는 것이 중요하다
            - 코드를 분할하고 로드되는 순서의 우선순위를 지정하면 페이지들이 보다 빠르게 상호작용 가능하게 만들 수 있고, 입력 지연을 줄일 수 있을 것이다

            - '거대한 인라인 스크립트를 피하라'(이들 역시 메인 스레드에서 파싱 및 컴파일된다) 첫 번째 규칙을 기억하자.
              스크립트 크기가 1 KB를 넘으면 인라인으로 작성하지 말라. 1 KB는 외부 스크립트에 관한 코드 캐싱을 실행하는 크기이기도 하다

    - 파싱과 컴파일
        : 지난 몇 년 간 자바스크립트 관련 비용의 가장 주목할 만한 변화는 브라우저의 스크립트 파싱 및 컴파일 속도가 크게 향상되었다는 것이다
        : 2024년 기준으로 파싱과 컴파일 비용은 더 이상 과거만큼 높지 않다(즉, 느리지 않다).
        : 구글의 자바스크립트 엔진 V8의 원시 자바스크립트 파싱 속도는 크롬 60 이후로 계속 빨라졌으며,
          크롬의 다른 최적화들로 인해 원시 파싱 및 컴파일 비용은 덜 가시적이고 덜 중요해지게 되었다

        : V8에서는 메인 스레드의 파싱과 컴파일양이 평균 40% 줄었고, 워커 스레드로 하여금 이를 수행하게 했다
          이것은 기존의 오프-메인-스레드 스트리밍 파싱 및 컴파일에 추가된다
        : V8은 메인 스레드를 중지시키지 않고 자바스크립트를 파싱 및 컴파일할 수 있다. 이는 이전 버전의 크롬에 비해 눈에 띄게 개선된 것이다
          이전 버전의 크롬은 스크립트 전체를 다운로드한 뒤 파싱을 시작했다

        : V8 엔진의 (바이트)코드 캐싱 최적화도 도움이 된다. 스크립트가 처음 요청되면 크롬은 해당 스크립트를 다운로드하고 V8에게 컴파일을 지시한다
        : 또한 해당 파일을 브라우저의 온-디스크 캐시에 저장한다. JS 파일이 두 번째로 요청되면 크롬은 요청받은 파일을 브라우저 캐시에 꺼내고
          V8에게 재컴파일을 지시한다. 하지만 이번에는 컴파일된 코드는 직렬화되어 캐싱된 스크립트 파일에 메타데이터로 추가된다
        : 파일이 세 번째로 요청되면 크롬은 두 파일을 모두 꺼내고 캐시에서 해당 파일의 메타데이터를 꺼내 V8에 전달한다
        : V8은 메타데이터를 역직렬화하고 컴파일을 건너뛴다. 첫 두 번의 방문이 72시간 안에 발생하면 코드 캐싱을 실행한다

    - 모바일 기기
        : 앞서 언급한 요소들 외에 자바스크립트는 모바일 기기의 배터리 수명에도 영향을 미칠 수 있다
        : 자바크스립트를 실행하기 위해서는 많은 CPU 리소스가 필요하며, 배터리가 빨리 소진되게 할 수 있고 로우-엔드 기기일수록 이런 현상은 두드러진다
        : 그래서 느린 CPU가 탑재된 휴대전화에서는 자바스크립트를 실행 시간이 중요하다

        : CPU, GPU, 서멀 스로틀링의 차이로 인해 하이엔드/로엔드 휴대전화의 성능에는 큰 차이가 발생한다
        : 자바스크립트 실행은 CPU와 연관되므로 이는 자바스크립트 성능에 매우 중요하다

        : 이 이슈를 해결하기 위해 웹 개발자들은 그들이 작성한 자바스크립트 코드의 다운로드 시간과 실행 시간 최적화에 집중해야 했다
        : 다음을 통해 이를 달성할 수 있다
            - 자바스크립트 번들의 크기를 줄인다
            - 큰 번들을 작은 번들로 나눈다
            - 메인 스레드를 블로킹할 수 있는 긴 태스크를 피한다

    - 상호작용 최적화
        : 상호작용 대비는 사용자의 상호작용에 대해 웹페이지가 얼마나 빠르게 반응할 수 있는지를 평가하는 웹 성능 지표이다
        : 해당 지표는 웹 성능의 핵심 측면이다. 사용자는 웹페이지가 자신의 입력(예를 들면 클릭, 스크롤, 타이핑 등)에 즉각 반응하기를 원하기 때문이다
          웹페이지가 느리게 응답하면 사용자는 답답함을 느끼고 해당 사이트를 떠날 것이다
        : 상호작용 대비는 네트워크 지연, 서버 처리 시간, 브라우저 렌더링 성능 등 다양한 요소의 영향을 받는다
        : 상호작용 대비를 다양한 측면에서 측정하는 여러 지표들을 찾아볼 수 있다. 상호작용 시작 시간 혹은 TBT 지표를 예로 들 수 있다

        : INP도 사용자 상호작용에 관한 웹페이지의 응답성을 측정하는 지표이다. 하지만 INP는 사용자가 상호작용을 시작한 순간부터
          스크린에 다음 프레임이 그려지는 순간까지의 응답성을 측정한다. 이 지표는 웹페이지의 로딩 및 런타임 응답에 관한 보다 정확한 추정을 제공한다

        : startTransition과 Suspense 를 통해 구현되는 React.js 타임 슬라이싱을 사용하면 선택적이고 점진적인 흡수를 활성화할 수 있으며
          언제든 방해를 받을 수 있는 작은 슬라이스 안에서 흡수할 수 있다. 이 접근법은 INP의 개선을 도우며 리액트 앱이 자동 완성 같은
          대규모 트랜지션을 하는 동안에도 키 스트로크, 호버 효과, 클릭에 보다 잘 반응하게 한다

        : Next.js는 새로운 라우팅 프레임워크인 앱 라우터를 개발하고 있는데, 앱 라우터는 기본적으로 startTransition을 사용해 라우트를 전환한다
        : Next.js 사이트 소유자들은 이를 활용해 리액트 타임 슬라이싱을 도입함으로써 라우트 전환의 반응성을 개선할 수 있다

    - 네트워킹
        : HTTP/3은 HTTP의 새로운 버전이며 인터넷에 관한 성능과 보안을 개선하기 위해 설계되었다
        : HTTP/3은 QUIC 전송 프로토콜을 사용한다. 이 프로토콜은 지연과 혼잡을 줄이고
          멀티플렉스 스트림과 커넥션 마이그레이션을 지원하기 위해 설계되었다

        : 구글 크롬, 모질라 파이어폭스, 마이크로소프트 엣지 같은 모든 주요 브라우저들은
          HTTP/3을 기본적으로 지원하거나 설정에서 활성화하여 지원할 수 있다

        : 스트리밍은 전체 파일 혹은 리소스가 로딩될 때까지 기다리지 않고 데이터를 덩어리 혹은 조각으로 보내고 받을 수 있는 능력을 가리킨다
        : 스트리밍은 사용자들이 콘텐츠를 보다 빠르게 소비하게 함으로써 성능을 개선할 수 있다

        : 플러싱은 전체 응답이 생성되기 전에 데이터를 브라우저에게 보낼 수 있는 능력을 가리킨다
        : 플러싱은 콘텐츠를 스트리밍하는 데 유용하며 동시에 모든 리소스가 로딩되기 전에 페이지 렌더링을 시작함으로써 인지된 성능을 개선하는 데도 유용하다

        : 대규모 자바스크립트 웹 애플리케이션에서 이 기술과 기법들은 성능을 개선하는 데 중요할 수 있다
        : 특히 인터넷 연결이 느린 사용자들이나 원격지에서 애플리케이션에 접속하는 사용자들에게 그렇다
        : HTTP/3, 스트리밍, 플러싱을 사용함으로써 지연을 줄이고 인지된 성능을 개선할 수 있다는 사용자의 참여와 유지를 증가시킨다

    - 서드파티 의존성의 영향 줄이기
        : 대규모 자바스크립트와 리액트 애플리케이션에서 작업할 때 서드파티 의존성은 때때로 성능 병목에 가장 큰 영향을 주는 요소가 될 수 있다
        : 이 의존성들은 라이브러리와 프레임워크에서 위젯, 분석, 스크립트에 이르기까지 다양하다. 이들은 중요한 기능을 제공하고
          개발 시간을 줄여줄 수 있지만 추가적인 오버헤드를 야기하기도 한다

        : 리액트 애프리케이션에서 서드파티 의존성의 영향을 줄이는 것은 도전적인 태스크이다.
        : 하지만 이 의존성을 사용하는 비용을 줄이기 위해 따를 수 있는 몇 가지 단계가 있다

         - 가장 비싼(느린) 의존성을 식별하라
            : 서드파티 의존성과 성능에 미치는 그들의 영향을 감사할 때, 첫 번째 단계는 로딩과 실행에 가장 많은 시간을 사용하는
              서드파티 의존성이 무엇인지 식별하는 것이다. 이때 Chrome DevTools, Lighthouse, WebPageTest 같은 도구를 활용해서
              가장 느리게 로딩되는 서드파티 의존성을 식별한다

        - 각 의존성의 필요성을 평가하라
            : 가장 느린 의존성을 우선 식별했다면 그들의 필요성을 평가한다. 이들이 애플리케이션의 핵심 기능에 필수적인가?
              이들을 더 작거나 빠른 대안으로 대체할 수 있는가?
            : 각 의존성의 필요성을 정기적으로 평가해 성능 비용에 적합한지 결정하는 것은 매우 중요하다

        - 대체 라이브러리를 고려하라
            : 어떤 의존성이 우리 애플리케이션의 핵심 기능에 필수적이지 않다면 해당 의존성을 더 작고 빠른 대안 라이브러리로 대체할 것을 고려하자
            : 대체 라이브러리로 사용할 수 있는 유명한 서드파티 의존성이 많으며, 이들을 사용해 같은 결과를 달성할 수 있다

        - 의존성 로딩을 최적화하라
            : 지연 로딩, 코드 분할, 트리 셰이킹 같은 기법을 사용해 서드파티 의존성의 로딩을 최적화할 수 있다
            : 지연 로딩은 의존성이 필요할 때만 로딩하게 하고, 코드 분할은 코드를 작은 덩어리로 나누고 이들을 필요할 때만 로딩하게 할 수 있다

            : 트리 셰이킹은 번들러와 Vite, Webpack 같은 빌드 도구들이 사용하는 기법으로 죽은 코드 혹은 최종 번들에서 사용되지 않는 익스포트를 제거한다
            : 트리 셰이킹을 통해 사용되는 의존성에서 사용되지 않는 코드를 제거할 수 있다

        - CDN 호스팅을 사용하라
            : 서드파티 의존성을 위해 CDN 호스팅을 사용하면 로딩 시간을 줄이고 애플리케이션 성능을 개선하는 데 도움이 될 수 있다
            : CDN은 전 세계 각지에 위치한 서버들을 가지고 있다. 이는 사용자들이 자신과 가장 가까운 서버로부터 의존성들을 다운로드할 수 있음을 의미한다

            : 더블 키 캐싱을 사용하면 CDN 캐싱의 이익을 크게 줄일 수 있다는 점에 유의하라. 하지만 에지에서 스크립트를 제공함으로써 여전히 이익을 얻을 수 있다

        - 번들을 분석하라
            : Webpack Bundle Analyzer 및 Lighthouse Treemap 같은 도구를 사용하면 번들을 분석하고
              가장 많은 공간을 차지하는 의존성을 식별하는 데 도움을 얻을 수 있다
            : 가장 큰 의존성을 식별했다면 이들을 보다 작거나 빠른 대안으로 대체하는 것을 시도할 수 있다

        - 서드파티 의존성 구성을 최적화하라
            : 몇몇 서드파티 의존성은 그 성능을 개선하기 위해 최적화될 수 있는 구성을 갖는다. 예를 들면 데이터 시각화 라이브러리를
              사용한다면 표시되는 항목의 수를 제한함으로써 렌더링하는 데이터 양을 줄일 수 있다

        - 렌더링 패턴
            : 렌더링 패턴을 이해하는 것은 가능한 최상의 사용자 경험을 제공하는 대규모 자바스크립트와 리액트 애플리케이션을 구축하기 위해 매우 중요하다
            : 렌더링 패턴은 시간이 지남에 따라 지속적으로 진화해왔다. 서버 사이드 렌더링과 클라이언트 사이드 렌더링을 넘어서는 복잡한 패턴들이 등장했으며,
              이 패턴들은 오늘날 다양한 포럼에서 논의 및 평가되고 있다.
            : 수많은 옵션을 사용할 수 있기 때문에 프로젝트에 적절한 대상을 선택하는 것에 압도될 수 있다. 하지만 각 패턴은 특정한 유스 케이스를
              해결하기 위해 설계된 것이며, 한 유스 케이스에 효과적인 패턴이 다른 유스 케이스에는 적합하지 않을 수 있다는 점을 반드시 기억해야 한다

            : 또한 같은 웹사이트에 존재하는 다른 유형의 페이지들은 다른 렌더링 패턴을 요구할 수 있다.
              크롬 팀은 완전한 흡수 접근 방법 대신 정적 혹은 서버 사이드 렌더링 사용을 권장한다

            : 모던 프레임워크와 함께 사용되는 점진적 로딩과 렌더링 기법은 시간이 지남에 따라 성능과 기능 전달 사이의 균형을 맞추는 데 도움이 될 수 있다
            : 다음은 patterns.dev와 stateofjs.com에서 영감을 받은 유용한 렌더링 패턴을 요약한 것이다
                - 클라이언트 사이드 렌더링, 단일 페이지 애플리케이션
                    : 브라우저에서 완전하게 실행되는 애플리케이션
                - 멀티 페이지 애플리케이션
                    : 최소한의 클라이언트 사이드의 동적 동작과 함께 서버에서 완전하게 실행되는 애플리케이션
                - 정적 사이트 생성을 위한 정적 렌더링
                    : 사전 렌더링된 정적 콘텐츠, 클라이언트 사이드의 동적 요소를 포함할 수 있음
                - 서버 사이드 렌더링
                    : HTML 콘텐츠를 클라이언트에서 재흡수하기 전에 서버에서 동적으로 렌더링함
                - 부분적 흡수
                    : 클라이언트에서 컴포넌트의 일부만 흡수함(e.g. 리액트 서버 컴포넌트)
                - 점진적 흡수
                    : 클라이언트에서 컴포넌트 흡수 순서 통제하기
                - 아일랜드 아키텍처
                    : 정적 사이트에 여러 엔트리 포인트가 있는 동적 행동의 고립된 섬
                - 점진적인 정적 생성
                    : 초기 구축 이후에도 정적 사이트를 동적으로 증강하거나 수정할 수 있는 능력(Next.js ISR, Gatsby DSG)
                - 스트리밍 SSR
                    : 서버 측에서 렌더링된 콘텐츠를 작은 스트림 덩어리로 나누는 것
                - 재개 가능성 
                    : 서버에서 프레임워크 상태를 직렬화해 클라이언트가 중복된 코드 없이 실행을 재개할 수 있음
                - 에지 렌더링
                    : 렌더링된 HTML을 에지에서 대체한 뒤 이를 클라이언트로 보냄

        - 인지된 성능 최적화하기
            : 인지된 성능은 웹사이트 혹은 애플리케이션의 로딩 및 응답 속도와 관련된 주관적인 경험이며,
              실제 로딩(혹은 실행)되는 정확한 시간과 대비된다
            : 인지적 성능은 시각적 단서, 피드백, 애니메이션 같은 다양한 요소에 영향을 받는다.
              인지적 성능을 개선함으로써 실제 로딩(혹은 실행) 시간이 느리더라도 종종 보다 나은 사용자 경험을 만들 수 있다
            : 애플리케이션의 인지된 성능을 최적화하는 것은 중요하지만, 핵심적인 사용자 경험이 실질적으로 더 빨리 로딩되도록
              하기 위해 완료해야 하는 작업을 방해해서는 안 된다

            : 점진적 로딩은 인지된 성능을 개선하는 기법의 하나이다. 전체 페이지 혹은 애플리케이션이 로딩되어 모든 내용이
              표시될 때까지 기다리는 대신, 점진적 로딩은 가장 중요한 콘텐츠 먼저 로딩하고, 백그라운드에서 추가적인 콘텐츠를 계쏙해서 로딩한다
            
            : 스켈레톤 스크린은 점진적 로딩의 널리 알려진 접근법 중 하나이다

        - 스켈레톤 스크린과 플레이스홀더 UI
            : 스켈레톤 스크린은 스켈레톤 로더 또는 콘텐츠 플레이스홀더라 불리며, 웹 애플리케이션의 인지된 성능을 개선하기 위해 사용하는 설계 패턴이다
            : 스켈레톤 스크린은 단순한 아웃라인 혹은 스켈레톤으로 구성되며 여기에 최종적으로는 콘텐츠(이미지, 텍스트, 다르미디어 등)가 로드되어 표시된다
            
            : 스켈레톤 스크린의 목적은 콘텐츠를 지금 당장 사용할 수는 없지만 현재 로딩하고 있다는
              즉각적인 시각적 피드백을 사용자에게 주는 것이다. 이 기법은 인지적 로딩 시간을 줄이고 
              애플리케이션에 관한 사용자의 참여와 만족을 높이는 데 도움을 준다

            : 스켈레톤 스크린은 다양한 방법으로 구현할 수 있다. 하지만 전형적으로 HTML과 CSS를 사용해서
              최종 콘텐츠와 비슷한 형태의 플레이스홀더 구조를 만드는 방법을 포함한다
              이 구조는 실제 콘텐츠를 백그라운드에서 가져오거나 로딩하는 동안 표시된다

            : 또 다른 관련 기법으로 페이지 안의 개별 컴포넌트 혹은 UI 요소별로 스켈레톤 로더를 사용할 수 있다
            : 예를 들면 복잡한 데이터 테이블의 실제 데이터를 로딩하는 동안 비어 있는 셀을 표시하는
              단순한 테이블 구조를 표시할 수 있다. 이 기법은 사용자가 테이블 레이아웃을 이해하고 실제 데이터가 곧 표시될 것임을 기대할 수 있게 한다

            : 플레이스홀더 UI는 이와 다른 접근법으로 미리 존재하는 시각 요소를 사용해서 아직 사용할 수 없는 콘텐츠를 표시한다
            : 예를 들면 뉴스 애플리케이션은 기본 이미지 플레이스홀더를 사용해서 실제 관련된 이미지를 갖지 않은 아티클을 표시한다
            : 이 기법은 인지된 로딩 시간을 줄이는 데 효과적일 수 있지만 스켈레톤 스크린만큼 시각적으로 정보를 제공하지는 않는다

            : 스켈레톤 스크린과 관련 기법들은 인지된 성능 개선에 효과적이지만 잠재적인 단점도 갖고 있다
            : 예를 들면 스켈레톤 스크린은 최종 콘텐츠를 정확하게 반영하지 않기 때문에 사용자를 혼란스럽게 하거나 불만을 갖게 만들 수 있다
            : 이와 유사하게 실제 콘텐츠를 로딩하는 데 시간이 너무 많이 걸린다면 스켈레톤 스크린은 진척을 전달하는 유용한 수단이 아니라
              짜증을 유발하는 원인이 될 수 있다. 스켈레톤 스크린과 다른 점진적 로딩 테크닉을 사용하는 장단점을 다음과 같이 정의할 수 있다

            - 장점
                : 인지된 성능 개선
                    - 앞서 설명했듯 스켈레톤 스크린은 인지된 대기 시간을 줄이고 웹사이트나 애플리케이션의 인지된 성능을 전반적으로 개선할 수 있다
                : 보다 나은 참여
                    - 가능한 한 빠르게 콘텐츠를 표시함으로써 점진적 로딩은 사용자가 전체 페이지가 로딩될 때까지 기다리는 대신
                      콘텐츠에 참여하고 흥미를 가질 수 있도록 유지하는 데 도움을 준다
                : 보다 효율적인 리소스 사용
                    - 가장 중요한 콘텐츠의 우선순위를 높임으로써 점진적 로딩은 서버와 네트워크에 걸리는 부하를 줄이는 데
                      도움을 주며, 이는 웹사이트와 애플리케이션의 효율을 높인다

            - 단점
                : 복잡성 증가
                    - 점진적 로딩을 구현하기 위해서는 종종 보다 복잡한 코딩과 설계가 필요할 수 있으며 이는 구현과 유지보수에 부담을 줄 수 있다
                : 시각적 주의 산만 위험
                    - 스케렐톤 스크린은 올바르게 구현하지 않으면 사용자의 주의를 산만하게 하거나 심지어 사용자를 혼란스럽게 함으로써
                      잠재적으로 나쁜 사용자 경험을 야기할 수 있다
                : 기능 제한
                    - 점진적 로딩은 모든 콘텐츠에 적합하지는 않을 수 있다(특히 상호작용 요소 혹은 복잡한 인터페이스에)

            >>> 마지막으로 점진적 로딩 기법은 다양한 기기 혹은 플랫폼에서 접근할 수 있고 잘 호환되는 방식으로 구현되도록 해야 한다

    - 성능 최적화 자료
        : 웹 성능 개선과 관련된 수많은 기법과 전략들이 존재한다. 다음 영역과 리소스들을 탐험함으로써 대규모 웹 애플리케이션의
          웹 성능 최적화에 관한 더 깊은 통찰을 얻을 수 있다

          - 서비스 워커, 사전 캐싱, 네비게이션 사전 로딩
            : 서비스 워커 개요
            : Workbox로 사전 캐싱
            : 탐색 미리 로드로 서비스 워커 속도 향상

        - 스트리밍
            : Streams API
            : fetch API를 사용한 스트리밍 요청
            : Streams API: TransformStream

        - V8 코드 캐싱과 바이트코드 캐시
            : Code caching
            : The V8 JavaSscript Engine
            : How to make your Electron app launch 1,000ms faster

        - Stale-While-Revalidate
            : 비활성 상태 재검증을 통해 최신 상태 유지
            : Google에서 재확인 중 비활성으로 광고 실적을 개선한 방법

        - 브로틀리 압축
            : Brotli
            : Brotli Compression: The secret weapon for faster websites (and why you need it!)
            : Enable Brotli when using a Web Server

        - 조기 힌트, 우선 힌트, HTTP/3
            : HTTP/3: From Root to Tip
            : How to get Faster Websites With Early and Priority Hints
            : How to Optimize Resource Loading With The FetchPriority Attribute

        - 클라이언트 힌트
            : 클라이언트 힌트로 리소스 선택 자동화
            : Leaner Responsive Images with Client Hints
            : What Are Client Hints and Are They Worth Implementing 

        - 적응적 로딩
            : 적응형 로드: 느린 기기에서 웹 성능 개선
            : Adaptive Loading: Improving web performance on low-end devices

        - 리스트 가상화
            : List Virtualization
            : Infinite Scroll without Layout Shifts
            : Rendering large lists with React Virtualized

        - 콘텐츠 가시성 
            : 콘텐츠 가시성: 렌더링 성능을 향상시키는 새로운 CSS 속성

        - 이미지 최적화
            : 이미지 알아보기
            : 빠른 로드 시간
            : 최대 콘텐츠 렌더링 시간 최적화
        
        > 이 목록에 표시한 기법들을 이해하고 구현하면 대규모 애플리케이션의 웹 성능을 상당히 개선할 수 있고,
          이를 통해 더 나은 사용자 경험과 사용자 참여의 증가를 만들 수 있다
    
    - 성능 문화
        : 알렉스 러셀이 쓴 아티클 <A Management Maturity Model for Performance(성능 관리 성숙도 모델)>은 읽을 만한 가치가 있다
          대규모 조직에서 이런 문화로 움직이는 데까지는 시간이 걸린다. 하지만 '빨라지는 것'이 하나의 도전이라면
          '빠름을 유지하는 것'은 또 다른 도전임을 깨닫는 것에 의의가 있다

        : 성능 문화는 조직이 웹 성능에 관해 갖는 태도나 접근법을 가리키며, 여기에서 성능은 비즈니스 성공을 위한 핵심적인 지표이다
        : 건강한 성능 문화는 과학적인 방법론들을 프로세스와 접근법에 도입하는 것, 모던 시스템의 복잡성을 깨닫는 것, 
          협업을 통해 미지의 대상을 학습하고 조사하는 것을 포함한다

        : 성능 문화를 갖는 것은 매우 중요하다. 웹 성능이 비즈니스 결과(고객 만족, 사용자 참여, 이익을 포함)와 직결되기 때문이다
        : 따라서 지연, 변동 및 다른 성능 속성 관리는 OKR(objectives and key results)과 연계되어 성능이 우선되어야 한다
        : 이를 통해 성능이 항상 논의 대상에 있음을 보장해야 한다

        : 대규모 자바스크립트 애플리케이션을 구축할 때 성능 문화에 효과적으로 접근하기 위해서는 성능 관리 성숙도 수준에 관해 
          명확하게 이해해야 한다. 성능 관리 성숙도 수준은 다음과 같이 구분된다
            - 수준 0: 행복
            - 수준 1: 불 끄기
            - 수준 2: 글로벌 기준 & 지표
            - 수준 3: P75+, 사이트별 기준 & 지표

        : 각 수준에 따라 성능 문화에 관한 접근법이 달라진다. 수준 0에서 조직은 성능 관리 전략과 관련된 어떠한 문제나 결여를 깨닫지 못한다
        : 수준 1에서 관리자들은 성능 문제를 깨닫고 이를 고치기 위해 시도한다. 수준 2에서 팀은 성능을 평가하기 위해 글로벌 기준 지표와
          벤치마크를 위해 움직인다. 한편, 수준 3에서 팀은 사이트별 성능 지표에 관해 자세히 이해하고 자신들의 접근법에 과학적 방법론을 통합한다
        
        : 요약하면 건강한 성능 문화를 구축하는 것은 웹 성능을 우선하고, 과학적 방법론을 프로세스에 통합하고, 데이터 주도 접근법을 사용해 
          시간이 지남에 따라 성능을 개선하는 것을 포함한다. 성능 문화는 조직이 지속적인 속도를 달성하고, 잠재력을 최대화하면서 동시에
          보다 나은 사용자 경험을 제공하고 비즈니스 성공을 이끄는 데 도움을 준다