[국제화]
국제화는 애플리케이션이 전 세계 사용자들이 접근할 수 있고, 올바르게 기능하고, 문화적으로 적절한 것을 보장한다 

국제화는 종종 il8n으로 줄여서 표기하며(l8은 i문자와 n문자 사이에 생략된 문자의 수를 나타냄)
애플리케이션이 다른 언어, 지역, 문화적 컨텍스트에 맞게 손쉽게 지역화 될 수 있게 셜계하고 개발하는 프로세스를 가리킨다
국제화를 위해서는 사용자 인터페이스와 콘텐츠를 애플리케이션 코드베이스에서 분리해 번역과 적용을 쉽게 해야 한다

좋은 국제화 프랙티스를 통해 얻을 수 있는 결과는 다음과 같다
    - 사용자 기반 증가
        : 다른 지역과 로케일에서 개발한 애플리케이션을 도입함으로써 보다 큰 글로벌 청중을 얻을 수 있고
          사용자 기반과 잠재적인 고객 기반을 얻을 수 있다
    
    - 사용자 경험 향상
        : 사용자들이 선호하는 언어, 문화적 컨텍스트 안에서 애플리케이션에 접근할 수 있게 함으로써
          보다 개인화된, 참여도가 높은 경험을 제공할 수 있다

    - 규제 준수
        : 일부 국가에서는 해당 지역의 언어로 애플리케이션에 접근할 수 있어야 한다는 법적 요구사항이 존재한다
        : 예를 들면 캐나다의 공식 언어 법규에 따르면 연방 서비스는 캐나다의 공식 국어인 영어와 프랑스어로 사용할 수 있어야 한다

애플리케이션의 효과적인 국제화를 달성하고자 할 때 유념해야 할 몇 가지 핵심 포인트들에 관해 살피면 다음과 같다
    - 코드에서 텍스트와 콘텐츠를 분리하라
        : 대규모 자바스크립트 애플리케이션에서 쉬운 번역과 도입을 활성화하기 위해 할 수 있는 가장 중요한 것은
          '사용자가 보는 텍스트 문자열을 코드에서 분리해 외부 리소스 파일이나 데이터베이스에 저장하는 것'이다
        
        : 예를 들면 자바스크립트 또는 템플릿 코드 안의 텍스트 문자열을 하드코딩하는 대신 분리된 파일(en.json 등)에 저장해 처리할 수 있다      
        
        : 텍스트 문자열을 분리된 파일에 저장하면 자바스크립트/템플릿에서 리소스 파일 혹은 데이터베이스에서 적절한 키를 사용해 이들을 참조하면 된다
            * 키를 사용해 en.json 파일의 텍스트에 접근하기
                const greeting = {{ greeting }};     

        : 지원하고 싶은 언어가 추가될 때마다 해당 프로세스를 반복할 수 있다.(fr.json, es.json, de.json 등)
          각 언어에 관한 새로운 번역 파일을 만들어 적절한 번역을 제공하면 된다
        : 각 번역 파일은 동일한 구조체, 즉 원본 리소스 파일(여기서는 en.json)과 동일한 키를 갖는다. 하지만 번역된 값은 대상 언어의 것이다
        : 이 텍스트 문자열 안에서는 변수들을 통합하는 경우 플레이스 홀더를 사용해 런타임에 이들이 바뀌도록 할 수 있다
        : 예를 들어 사용자의 이름과 함께 환영 메시지를 보내고 싶다고 가정하면 다음과 같이 할 수 있다
            - 텍스트 문자열을 변수에 저장하기
                {
                    "greeting": "Hello, {{name}}!" 
                }                                         

            - 자바스크립트 혹은 템플릿 코드에서는 이 변수를 다음과 같이 삽입할 수 있다 (텍스트 문자열 삽입)
                const userName = "Addy"
                const greetingMessage = interpolate(
                    "{{ greeting }}", 
                    { name: userName }
                )    

    - 서드파티 지역화 라이브러리를 활용하라
        : 대규모 자바스크립트 애플리케이션에서 il8n을 구현하는 가장 쉬운 방법은 reacct-intl 또는 i18next 같은 서드파티 라이브러리를 사용하는 것이다
        : 서드파티 라이브러리를 사용하면 il8n 해결책을 처음부터 직접 만드는 것에 비해 많은 시간과 노력을 덜 수 있다
        : 해당 라이브러리들은 번역 관리(메시지 형식, 단수/복수 처리, 날짜/시간 형식 등)와 언어의 동적 교환을 위한 편리한 메서드와 도구를 제공한다

        : react-intl 라이브러리를 사용해 기존의 리액트 애플리케이션에 국제화를 추가하는 간단한 실습 하기
            설치: yarn add react-intl

    - 지역화 라이브러리 구성하기
        : 애플리케이션의 root 인스턴스에서 애플리케이션의 컴포넌트 트리를 react-intl 컴포넌트가 제공하는 IntlProvider 컴포넌트로 감싼다
        : 이렇게 하면 애플리케이션의 모든 컴포넌트에 il8n 컨텍스트를 제공할 수 있다
        : IntlProvider 컴포넌트는 locale, messages 라는 두 가지 props를 요구한다
            - locale: 애플리케이션에서 사용하고자 하는 언어 로케일을 나타내는 문자열 값
            - messages: 애플리케이션에서 표시하고자 하는 실제 텍스트 메시지(문자열)를 포함하는 객체
        : IntlProvider 컴포넌트에 전달하는 초깃값으로 기본 로케일은 영어('en') 및 영어 메시지 사전에 관한 참조를 전달할 수 있다

    - 텍스트와 콘텐츠 렌더링하기
        : react-intl을 구성하였다면 react-intl의 컴포넌트(FormattedMessage 컴포넌트 등)를 사용해 번역 파일로부터 텍스트를 표시할 수 있다  
        : 다른 언어를 사용하거나 다르 국가를 여행 중인 사용자들에게 사용자 친화적인 애플리케이션으로 만들기 위해서는 로케일 전환을 구현한다
        : 로케일 전환은 사용자들이 애플리케이션 안에서 언어와 로케일을 전환할 수 있게 하는 기능이다          
        : 로케일 전환을 구현할 때는 먼저 로케일을 컴포넌트 상태에 저장한다 (useState)  

    - 동적 로딩
        : 애플리케이션 루트에서 모든 언어 파일을 직접 임포트할 수 있지만 이는 종종 모든 파일들이 메인 번들에 포함되는 결과를 야기한다
        : 상대적으로 적은 번역 파일이 최소한으로 존재하는 애플리케이션이라면 위 방식을 용인할 수 있지만, 수많은 번역 파일을 포함하는 
          보다 큰 애플리케이션에서는 이런 방식으로 사용하면 성능에 좋지 않는 영향을 미칠 수 있다

        : 위와 같은 우려를 완화하기 위해 때때로 번역 파일을 동적으로 임포트하고 로딩하게 함으로써
          사용자 선호나 브라우저 설정에 기반해 필요한 파일들만 로딩할 수 있다
        : 이때 동적 임포트(import())를 사용하면 동적으로 필요한 번역 파일을 임포트할 수 있다      

        >>> 애플리케이션의 빌드 툴링, 여러분이 사용하는 모듈 번들러(Webpack 혹은 Vite)의 종류에 따라 정확한 구현이나 구성 방법은 달라진다
        >>> 일부 번들러는 동적 임포트를 기본 지원하지만 또 다른 일부는 추가 플러그인 혹은 구성 설정을 요구할 수 있다

        : 지역화와 국제화를 가능하게 하기 위해 수행한 단계의 패턴은 사용하는 서드파티 라이브러리에 관계없이 일반적으로 적용할 수 있다
        : 전형적인 워크플로는 다음을 포함한다
            - 필요한 라이브러리 설치하기
            - 구분된 구성 파일에 언어 메시지 정의하기
            - 애플리케이션의 root 인스턴스에서 라이브러리 구성(설정)하기
            - 설치한 라이브러리가 제공하는 컴포넌트나 함수를 사용해 콘텐츠 렌더링하기
            - 마지막으로 로케일 전환을 구현해 사용자 친화적인 언어 전환을 지원하기

    - 여러 언어에서의 복수형 처리하기
        : 전 세계 사용자를 대상으로 하는 웹 애플리케이션을 만들 때는 단순한 복수 규칙(e.g. 영어에서 끝에 s를 붙여 하나 이상을 표현하는 것)이 보편적으로 적용되지 않는다
        : 각 언어마다 복수를 나타내는 규칙이 다르며, 어떤 규칙은 다른 규칙보다 복잡하다 (e.g. 아랍어는 0, 1, 2, 몇몇, 많이 등을 서로 다른 복수 규칙으로 표현)  
        : react-intl 같은 서드파티 라이브러리들은 복수를 다루는 도구를 제공한다. FormattedMessage 컴포넌트도 복수 형식을 가지며 이를 사용하면 다양한 언어의 복수형을 다룰 수 있다

        : You have {itemCount} items 라는 메시지를 애플리케이션에서 표시하고 싶다고 가정하면, 영어 로케일에서는 이를 전달하기 위해 3개의 다른 문장을 표시해야 한다
            - itemCount가 0일 때: You have no items
            - itemCount가 1일 때: Yout have 1 item
            - itemCount가 2 이상일 때: You have {itemCount} items     
        : 이때 FormattedMessage 컴포넌트의 내장 복수형을 사용해서 이를 표시할 때는 먼저 영어 로케일에 관한 복수 규칙을 정의할 수 있다
            - 아이템 수 메시지에 관한 복수 규칙 정의하기
                {
                    "itemCountMessage": "{
                        itemCount, plural, =0
                        {No items} one {1 item} other {You have {itemCount} items}}"
                }       
                >>> =0, one, two, few, many, other 등이 있다
            
            - 위 규칙은 react-intl의 ICU 메시지 문법을 사용, 해당 문법은 ICU 형식에 기반해 구현되었다
            - ICU 메시지 형식은 국제화 및 지역화 컨텍스트에서 소프트웨어가 제공하는 메시지를 구현하고 형식을 지정하기 위한 표준화된 방법이다            

    - 날짜, 시간, 숫자 형식 나타내기
        : 날짜, 시간, 숫자는 로케일에 따라 다른 형식을 갖는 경우가 많다. 따라서 라이브러리나 프로그램 언어에서 지원하는 내장 언어 기능을 사용해
          날짜, 시간, 숫자가 정확하게 로케일에 맞는 형식을 갖게 해야 한다
        : 자바스크립트의 경우 Intl 객체가 다른 로케일에서의 날짜, 시간, 숫자의 형식을 나타내는 일련의 기능을 제공한다

        : react-intl 라이브러리 같은 서드파티 라이브러리들도 날짜, 시간, 숫자 형식을 지정할 수 있는 컴포넌트와 API를 제공한다
        : FormattedDate 컴포넌트를 사용하면 표준 숫자 표현을 넘어 보다 길고 설명적인 형식으로 날짜를 렌더링할 수 있다
            - 예를 들면 공식 문서, 가독성을 강조하는 사용자 인터페이스, 혹은 주중 요일 등을 중요하게 표현해야 하는 등 자세한 날짜 형식이 필요한 컨텍스트에서 유용하다  
        : react-intl은 FormattedTime 컴포넌트와 FormattedNumber 컴포넌트도 지원하며 각각 지역화된 시간과 숫자 형식을 지정할 때 사용할 수 있다 
        : react-intl 라이브러리는 useIntl 훅도 제공하며 이를 사용하면 JSX와 컴포넌트의 렌더링 컨텍스트를 벗어나 날짜, 시간, 숫자 형식을 명령적으로 지정할 수 있다.
            -  react-intl 라이브러리가 제공하는 세부적인 기능의 목록은 API 문서 및 Components 문서에서 확인할 수 있다   

    - 오른쪽에서 왼쪽으로 쓰는 언어를 고려하라
        : 다양한 언어의 지원과 함께 아랍어, 히브리어, 우르두어와 같이 오른쪽에서 왼쪽으로 쓰는 언어(RTL)에 관한
          레이아웃, CSS 스타일, 텍스트 정렬에 관해서도 반드시 고려해야 한다
        : 애플리케이션에 RTL 언어에 관한 레이아웃과 텍스트 방향을 도입하는 것은 해당 지역의 사용자들에게 매끄러운 경험을 제공하기 위해 중요하다

        - 텍스트 방향(dir)
            : HTML은 dir 속성을 가지며, 이를 활용하면 RTL 텍스트를 다룰 수 있다.
            : dir 속성을 rtl로 설정하면(혹은 auto로 설정해 사용자 에이전트가 결정하게 하면), 애플리케이션 안의 텍스트와 요소들이 
              URL 언어에 맞춰 올바르게 정렬됨을 보장할 수 있다

        - 텍스트 정렬(text-align)
            : textx-align CSS 속성을 사용해 텍스트 정렬을 설정할 때, 전통적으로 사용하는 left, right 값과 함께 start, end 값을 사용하면 편리하다
            : start, end 값을 사용하면 문서 방향에 기반해 텍스트를 정렬하는데 도움이 된다
            : 예를 들어 LTR 컨텍스트에서 text-align: start 를 사용하면 텍스트를 왼쪽 기준으로 정렬하고, RTL 컨텍스트에서는 텍스트를 오른쪽 기준으로 정렬한다
            : 반대로 text-align:end 속성을 사용하면 left, right 같은 방향을 지정하지 않고도 문서 끝을 기준으로 각 텍스트가 정렬되는 형태를 확인할 수 있다

        - 폰트
            : RTL 언어를 디자인할 때 폰트 선택은 매우 중요하다. 폰트는 시각적으로 매력적이고 브랜드와 어울릴 뿐만 아니라
              RTL 스크립트의 문자와 뉘앙스를 적절하게 지원해야 한다
            : 일부 폰트들은 특정한 문자를 지원하지 않거나 충분한 지원을 하지 않으며 이는 부적절한 혹은 일관성 없는 사용자 경험으로 이어질 수 있다
            : CSS에서 대체 폰트 리스트를 제공하는 것은 가장 좋은 프랙티스이다. 기본 폰트가 로딩되지 않거나 특정 문자가 지원되지 않으면 브라우저는 리스트의 다음 폰트를 사용한다
                - 대체 폰트
                    body {
                        font-family: 'Noto', 'Monotype SST', '...';
                    }              

            : 언어 방향에 맞는 폰트 스택을 설정함으로써 각 스크립트에 관한 뉘앙스와 고유한 문자들을 제공할 수 있다
            : 이를 통해 해당 텍스트가 합법적이고 애플리케이션 디자인 원칙에 미적으로 적합함을 보장할 수 있다

        - 레이아웃
            : RTL 언어를 다룰 때 텍스트 방향과 정렬만 고려해서는 안 된다. 바깥쪽 여백(margin), 안쪽 여백(padding), 위치(positioning)와 같은 
              다른 CSS 속성들도 방향의 변화에 영향을 받는다
            : 예를 들어 영어로 작성된 텍스트가 있고, LTR 컨텍스트에서 해당 텍스트 왼쪽에 하나의 아이콘이 위치해 있다고 가정할 때
              아이콘과 텍스트 사이의 간격을 만들고 싶으면 표준 margin-right CSS 속성을 사용해 간격을 만들 수 있다
            
            : RTL 언어 설정과 LTR 언어 설정 모두에서 유사한 사용자 경험을 제공하기 위해서는
              아이콘의 바깥 여백을 항상 아이콘과 텍스트 사이에 적용해야 한다
            : 이때 다른 언어 설정에 따라 적용되는 별도의 클래스를 만드는 방법도 있지만, 'CSS 논리적 속성'을 활용하면
              보다 효과적으로 같은 목적을 달성할 수 있다

        - CSS 논리적 속성
            : CSS 논리적 속성을 사용하면 레이아웃의 방향과 차원 매핑을 물리적이 아니라 논리적으로 통제할 수 있다
            : 전통적인 CSS는 물리적 차원과 방향(top, right, bottom, left)에 기반한다
            : 하지만 논리적 속성을 사용하면 콘텐츠의 흐름과 방향의 관계에 기반해 스타일을 기술할 수 있다(start, end, inline, block)

            : 논리적 속성을 사용할 때의 주요한 장점은 요소에 적용된 텍스트 작성 모드와 방향이 자동으로 적용된다는 점이다
            : 이는 매우 강력하며 서로 다른 텍스트 방향에 관한 별도의 클래스 혹은 스타일을 필요로 하지 않고도 다양한 방향의 레이아웃을 구축할 수 있게 해준다
            
            : 예를 들어 margin-right CSS 속성 대신 margin-inline-end를 사용할 수 있다.
              이는 LTR 컨텍스트에서는 margin-right와 등가이며 RTL 컨텍스트에서는 margin-left와 등가이다
            : 텍스트 방향에 관계없이 margin-inline-end는 바깥쪽 여백이 아이콘과 텍스트 사이에 적용되는 것을 보장하며
              언어 종류와 텍스트 방향에 관계없이 레이아웃의 일관성이 유지된다                                           

    >>> 국제화는 다양한 지역과 로케일의 사용자가 애플리케이션을 사용할 수 있게 하는 웹 개발에 매우 중요한 프로세스이다           
    >>> 텍스트를 코드에서 분리하고, react-intl 같은 지역화 라이브러리를 활용하고, 날짜/시간/숫자의 형식을 적절하게 지정하고
        RTL 언어를 고려함으로써 보다 접근 가능하고, 기능적이고, 글로벌 사용자에게 문화적으로 적절한 애플리케이션을 만들 수 있다 